<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024 ciscn&amp;ccb RE wp</title>
    <url>/2024/12/20/2024-ciscn-ccb-Re-wp/</url>
    <content><![CDATA[<h1 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h1><p>运行程序 输入几个字符 观察回显</p>
<span id="more"></span>

<p><img src="/../images/image1-1734689935552-1.png" alt="image1"></p>
<p>随后看了一下flag头的映射</p>
<p><img src="/../images/image2-1734689953905-3.png" alt="image2"></p>
<p>跟flag的前几位一样</p>
<p><img src="/../images/image3-1734689962295-5.png" alt="image3"></p>
<p>发现是单字节加密 所以将所有的可打印字符输入进去dump一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import string  </span><br><span class="line">all_char = string.printable  </span><br><span class="line">print(all_char)</span><br><span class="line">#0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~ 	</span><br></pre></td></tr></table></figure>
<p>得到映射表<br><img src="/../images/image4-1734689969850-7.png" alt="image4"></p>
<p>001c1d000000000000001e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b00000000000000000000000000000000000100000000000000000038003900</p>
<p>随后将flag一一映射过去即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import string  </span><br><span class="line">all_char = string.printable  </span><br><span class="line">#print(all_char)  </span><br><span class="line">table = list(bytes.fromhex(&quot;001c1d000000000000001e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b000000000000000000000000000000000100000000000000000038003900&quot;))  </span><br><span class="line">flag = list(bytes.fromhex(&quot;23 29 1E 24 38 0E 15 20 37 0E 05 20 00 0E 37 12 1D 0F 24 01 01 39&quot;))  </span><br><span class="line">for x in flag:  </span><br><span class="line">    if x in table:  </span><br><span class="line">        print(all_char[table.index(x)], end=&quot;&quot;)</span><br><span class="line">#flag_MTczMDc0MzQ2Ng;;&#123;</span><br></pre></td></tr></table></figure>
<p>手动修改一下flag 结合提示第十四位是4 直接改一下即可<br> flag{MTczMDc4MzQ2Ng=&#x3D;}</p>
<h1 id="ezCsky"><a href="#ezCsky" class="headerlink" title="ezCsky"></a>ezCsky</h1><p>ida打开附件 得选择arm去分析 这里走了好多弯 </p>
<p>发现有RC4 猜测rc4加密 找key和密文</p>
<p><img src="/../images/image5-1734689976784-9.png" alt="image5"></p>
<p>找到key 跟进unk_8AA0</p>
<p><img src="/../images/image6-1734689981410-11.png" alt="image6"></p>
<p>找到密文</p>
<p><img src="/../images/image7-1734689987048-13.png" alt="image7"></p>
<p>直接解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import ARC4  </span><br><span class="line">encrypt_data= [0x96, 0x8F, 0xB8, 0x08, 0x5D, 0xA7, 0x68, 0x44, 0xF2, 0x64,  </span><br><span class="line">  0x92, 0x64, 0x42, 0x7A, 0x78, 0xE6, 0xEA, 0xC2, 0x78, 0xB8,  </span><br><span class="line">  0x63, 0x9E, 0x5B, 0x3D, 0xD9, 0x28, 0x3F, 0xC8, 0x73, 0x06,  </span><br><span class="line">  0xEE, 0x6B, 0x8D, 0x0C, 0x4B, 0xA3, 0x23, 0xAE, 0xCA, 0x40,  </span><br><span class="line">  0xED, 0xD1] # 加密key  </span><br><span class="line">key = b&#x27;testkey&#x27;     # 加密方法  </span><br><span class="line">key1=ARC4.new(key)  </span><br><span class="line">print(key1.encrypt(bytes(encrypt_data)))         # 解密方法</span><br><span class="line">#b&#x27;\n\r\x06\x1c\x1fTVSWQ\x00\x03\x1d\x14XV\x03\x19\x1c\x00T\x03K\x14X\x07\x02IL\x02\x07\x01Q\x0c\x08\x00\x01\x00\x03\x00O&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>最后一位是} 前面的都不对 结合左边的符号表有xor函数</p>
<p><img src="/../images/image8-1734689992869-15.png" alt="image8"></p>
<p>猜测进行了异或 但是最后一位没有异或 所以猜测加密的异或可能是<br>flag[i]^&#x3D;flag[i+1]<br>直接写逆向脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import ARC4  </span><br><span class="line">encrypt_data= [0x96, 0x8F, 0xB8, 0x08, 0x5D, 0xA7, 0x68, 0x44, 0xF2, 0x64,  </span><br><span class="line">  0x92, 0x64, 0x42, 0x7A, 0x78, 0xE6, 0xEA, 0xC2, 0x78, 0xB8,  </span><br><span class="line">  0x63, 0x9E, 0x5B, 0x3D, 0xD9, 0x28, 0x3F, 0xC8, 0x73, 0x06,  </span><br><span class="line">  0xEE, 0x6B, 0x8D, 0x0C, 0x4B, 0xA3, 0x23, 0xAE, 0xCA, 0x40,  </span><br><span class="line">  0xED, 0xD1] # 加密key  </span><br><span class="line">key = b&#x27;testkey&#x27;     # 加密方法  </span><br><span class="line">key1=ARC4.new(key)  </span><br><span class="line">print(key1.encrypt(bytes(encrypt_data)))         # 解密方法  </span><br><span class="line">flag = b&#x27;\n\r\x06\x1c\x1fTVSWQ\x00\x03\x1d\x14XV\x03\x19\x1c\x00T\x03K\x14X\x07\x02IL\x02\x07\x01Q\x0c\x08\x00\x01\x00\x03\x00O&#125;&#x27;  </span><br><span class="line"># 将 flag 转换为 list，便于修改  </span><br><span class="line">flag = list(flag)  </span><br><span class="line">for i in range(len(flag)-1,0,-1):  </span><br><span class="line">    flag[i-1] ^= flag[i]  </span><br><span class="line">    print(chr(flag[i]),end=&#x27;&#x27;)  </span><br><span class="line">chr_flag=&#x27;&#125;22110084edca-dfa9-fe11-47a9-033b5f0d&#123;gal&#x27;  </span><br><span class="line">print(chr_flag[::-1])</span><br><span class="line">#lag&#123;d0f5b330-9a74-11ef-9afd-acde48001122&#125;</span><br></pre></td></tr></table></figure>
<p>少了个f 在前面加上就是正确的flag</p>
<h1 id="kiwi"><a href="#kiwi" class="headerlink" title="kiwi"></a>kiwi</h1><p>打开附件 给了一个流量包和一个exe程序 分析一下exe<br><img src="/../images/kiwi.png" alt="kiwi"></p>
<p>跟进一下sub_140082974<br>首先根据word_140111152生成了一个伪随机数 起调试取出来 是0x69<br><img src="/../images/kiwi-1.png" alt="kiwi-1"><br>交叉引用这个伪随机数发现下面进行了异或 并且和随机数进行相加<br><img src="/../images/kiwi-2.png" alt="kiwi-2"></p>
<p>起调试取出随机数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7d, 0x2e, 0x10, 0x3d, 0x2d, 0x27, 0x44, 0x79, 0x27, 0x69, 0x33, 0x55, 0x5c, 0x2d, 0x7a, 0x4, 0x2, 0x65, 0x16,  0x22, 0x14, 0x2d, 0x4, 0x47, 0x1a, 0x7f, 0x26, 0x5b, 0x2a, 0x26, 0x69, 0x2c, 0x2f, 0x75, 0x25, 0x3d, 0x69, 0x38,  0x45, 0x62, 0x35, 0x6b, 0x27, 0x9, 0xf, 0x2a, 0x46, 0x5b, 0x55, 0x69, 0x16, 0x4, 0x4d, 0x65, 0x2f, 0x4e, 0x6a, 0x5a, 0x2e, 0x75, 0x4b, 0x77, 0x58, 0x37, 0x5, 0xf, 0x1, 0x2a, 0x22, 0x11, 0x2d, 0x52, 0x6a, 0x3a, 0x74, 0x73,  0x61, 0x9, 0x2b, 0x24, 0x10, 0x74, 0x40, 0x25, 0x8, 0x59, 0x66, 0x72, 0x25, 0x37, 0x72, 0x18, 0x10, 0x1e, 0x5, 0x48, 0x7, 0x64, 0x6c, 0x2a, 0x61, 0x1a, 0x44, 0x73, 0x4c, 0x3e, 0x62, 0x3a, 0x5a, 0x32, 0x72, 0x8, 0x3c, 0x6d,  0x5d, 0x2e, 0x4d, 0x71, 0x71, 0x5b, 0x52, 0x7d, 0x3c, 0x6d, 0x7f, 0x3, 0x38, 0x8, 0x3e, 0x5c, 0x2e, 0x65, 0x2d,  0x3b, 0x54, 0x6d, 0x65, 0x60, 0x38, 0x7, 0x2, 0xe, 0x62, 0x2e, 0x60, 0x3e, 0x35, 0x46, 0x22, 0x15, 0x17, 0x30, 0x79, 0x14, 0x52, 0x1c, 0x23, 0xf, 0x39, 0x1e, 0x31, 0x60, 0xe, 0x5, 0xe, 0x5c, 0x23, 0x68, 0x3d, 0x6, 0x40, 0x1, 0x62, 0x3, 0x45, 0x3e, 0x4, 0x4e, 0x10, 0x16</span><br></pre></td></tr></table></figure>
<p>最后是一个变表的base64<br><img src="/../images/kiwi-3.png" alt="kiwi-3"><br>写个脚本提取一下码表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import idaapi</span><br><span class="line">import idautils</span><br><span class="line">import idc</span><br><span class="line">start = 0x140111070</span><br><span class="line">end = 0x1401110EE</span><br><span class="line">for addr in range(start, end + 1):</span><br><span class="line">    byte = idaapi.get_byte(addr)</span><br><span class="line">    if 32 &lt;= byte &lt;= 126:</span><br><span class="line">        print(chr(byte), end=&quot;&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/../images/kiwi-4.png" alt="kiwi-4"></p>
<p>得到码表为d+F3DwWj8tUckVGZb57S1XsLqfm0vnpeMEzQ2Bg&#x2F;PTrohxluiJCRIYAyH6N4aKO9<br>所以总的逻辑就是密文异或0x69加上随机数然后base64换表编码<br>随后看sub_140082774函数 发现密文是流量包的upload流<br><img src="/../images/kiwi-5.png" alt="kiwi-5"></p>
<p>去流量包里找一下<br><img src="/../images/kiwi-6.png" alt="kiwi-6"></p>
<p>发现密文<br>先解码一下<br><img src="/../images/kiwi-7.png" alt="kiwi-7"></p>
<p>然后写个脚本解密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc = [0xb9, 0x48, 0x1c, 0x58, 0x81, 0x4f, 0x51, 0x7d, 0x27, 0x70, 0x33, 0x6f, 0x79, 0x48, 0x82, 0x21,  </span><br><span class="line">       0x08, 0x80, 0x79, 0x49, 0x51, 0x52, 0x28, 0x9b, 0x7d, 0xbb, 0x40, 0x67, 0x45, 0x7a, 0x96, 0x38,  </span><br><span class="line">       0x3e, 0x7d, 0x41, 0x42, 0x86, 0x60, 0x4f, 0x6c, 0x3b, 0x87, 0x2e, 0x26, 0x72, 0x51, 0x83, 0x80,  </span><br><span class="line">       0x79, 0xbd, 0x79, 0x40, 0x67, 0x71, 0x4a, 0xa2, 0x98, 0x76, 0x3a, 0x8f, 0x68, 0xda, 0x7f, 0x74,  </span><br><span class="line">       0x2a, 0x33, 0x55, 0x8d, 0x5e, 0x2b, 0x39, 0x6d, 0xbe, 0x5f, 0x74, 0x74, 0x7d, 0x11, 0x8e, 0x4b,  </span><br><span class="line">       0x4d, 0x99, 0x64, 0x79, 0x63, 0xb3, 0x73, 0xca, 0x31, 0x90, 0xc3, 0x77, 0x1b, 0x6f, 0x61, 0x52,  </span><br><span class="line">       0x11, 0xbc, 0xbd, 0x86, 0xb2, 0x78, 0x4f, 0x7e, 0x56, 0x8f, 0x6c, 0x94, 0xb4, 0x3a, 0x7f, 0x14,  </span><br><span class="line">       0x4b, 0x79, 0xb6, 0x8c, 0xb0, 0xad, 0x8b, 0x67, 0x6d, 0xd1, 0x7a, 0x9a, 0xa7, 0x31, 0x74, 0x25,  </span><br><span class="line">       0x3e, 0x61, 0x2e, 0x82, 0x3d, 0x63, 0x5e, 0x77, 0x6b, 0x7c, 0x3f, 0x24, 0x65, 0x35, 0x9f, 0x53,  </span><br><span class="line">       0x84, 0x92, 0x42, 0xa0, 0x7d, 0x66, 0x70, 0x3b, 0xd3, 0x65, 0xa2, 0x6d, 0x7f, 0x19, 0x92, 0x7a,  </span><br><span class="line">       0x8c, 0xb8, 0x6b, 0x12, 0x18, 0x66, 0x74, 0xc0, 0x48, 0x64, 0x9d, 0x0e, 0x6f, 0x53, 0x96, 0x49,  </span><br><span class="line">       0x61, 0x5d]  </span><br><span class="line">sub = [0x7d, 0x2e, 0x10, 0x3d, 0x2d, 0x27, 0x44, 0x79, 0x27, 0x69, 0x33, 0x55, 0x5c, 0x2d, 0x7a, 0x4, 0x2, 0x65, 0x16,  </span><br><span class="line">       0x22, 0x14, 0x2d, 0x4, 0x47, 0x1a, 0x7f, 0x26, 0x5b, 0x2a, 0x26, 0x69, 0x2c, 0x2f, 0x75, 0x25, 0x3d, 0x69, 0x38,  </span><br><span class="line">       0x45, 0x62, 0x35, 0x6b, 0x27, 0x9, 0xf, 0x2a, 0x46, 0x5b, 0x55, 0x69, 0x16, 0x4, 0x4d, 0x65, 0x2f, 0x4e, 0x6a,  </span><br><span class="line">       0x5a, 0x2e, 0x75, 0x4b, 0x77, 0x58, 0x37, 0x5, 0xf, 0x1, 0x2a, 0x22, 0x11, 0x2d, 0x52, 0x6a, 0x3a, 0x74, 0x73,  </span><br><span class="line">       0x61, 0x9, 0x2b, 0x24, 0x10, 0x74, 0x40, 0x25, 0x8, 0x59, 0x66, 0x72, 0x25, 0x37, 0x72, 0x18, 0x10, 0x1e, 0x5,  </span><br><span class="line">       0x48, 0x7, 0x64, 0x6c, 0x2a, 0x61, 0x1a, 0x44, 0x73, 0x4c, 0x3e, 0x62, 0x3a, 0x5a, 0x32, 0x72, 0x8, 0x3c, 0x6d,  </span><br><span class="line">       0x5d, 0x2e, 0x4d, 0x71, 0x71, 0x5b, 0x52, 0x7d, 0x3c, 0x6d, 0x7f, 0x3, 0x38, 0x8, 0x3e, 0x5c, 0x2e, 0x65, 0x2d,  </span><br><span class="line">       0x3b, 0x54, 0x6d, 0x65, 0x60, 0x38, 0x7, 0x2, 0xe, 0x62, 0x2e, 0x60, 0x3e, 0x35, 0x46, 0x22, 0x15, 0x17, 0x30,  </span><br><span class="line">       0x79, 0x14, 0x52, 0x1c, 0x23, 0xf, 0x39, 0x1e, 0x31, 0x60, 0xe, 0x5, 0xe, 0x5c, 0x23, 0x68, 0x3d, 0x6, 0x40, 0x1,  </span><br><span class="line">       0x62, 0x3, 0x45, 0x3e, 0x4, 0x4e, 0x10, 0x16]  </span><br><span class="line">sand = 0x69  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    flag.append(((enc[i] - sub[i]) ^ sand))  </span><br><span class="line">    print(chr(flag[i]), end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="/../images/kiwi-8.png" alt="kiwi-8"><br>找个在线网站解一下Lihua的NTML即可<br><img src="/../images/kiwi-9.png" alt="kiwi-9"><br>flag{memeallme!}</p>
]]></content>
  </entry>
  <entry>
    <title>2024领航杯本科组 RE wp</title>
    <url>/2025/01/02/2024%E9%A2%86%E8%88%AA%E6%9D%AF-%E6%9C%AC%E7%A7%91%E7%BB%84Re-wp/</url>
    <content><![CDATA[<h1 id="ezsystd"><a href="#ezsystd" class="headerlink" title="ezsystd"></a>ezsystd</h1><p>jadx打开文件 找到主函数</p>
<span id="more"></span>

<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd.png" alt="本科组 easystd-1"></p>
<p>分析 主要的判断在check</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-1.png" alt="本科组 easystd-1"></p>
<p>调用本地native 所以分析native层 ida打开libcma.so 进入sub_904函数 发现一个类似sbox的数组</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-6.png" alt="本科组 easystd-6"></p>
<p>跟7异或 跑一下异或之后的sbox</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [ 0xD1, 0x97, 0xEE, 0xF9, 0xCB, 0xE6, 0x3A, 0xB0, 0x11, 0xB1]  </span><br><span class="line">for i in range(len(a)):  </span><br><span class="line">    a[i]^=7  </span><br><span class="line">    print(hex(a[i]),end=&#x27; &#x27;)</span><br><span class="line">#0xd6 0x90 0xe9 0xfe 0xcc 0xe1 0x3d 0xb7 0x16 0xb6</span><br></pre></td></tr></table></figure>

<p>发现是sm4的sbox 而且轮数也是32轮 所以猜测是sm4加密 找密文和密钥<br>跟进sub_75C函数 在最下面找到密文byte_C14</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-5.png" alt="本科组 easystd-5"></p>
<p>密钥在这个地方</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-7.png" alt="本科组 easystd-7"></p>
<p>跟进之后可以发现是将后八位替换为0x5A30303939383634</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-8.png" alt="本科组 easystd-8"></p>
<p>注意是小端序存储 所以密钥应该是A11223574689900Z 扔赛博厨子里跑一下</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-9.png" alt="本科组 easystd-9"></p>
<p>得到flag</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-10.png" alt="本科组 easystd-10"></p>
]]></content>
  </entry>
  <entry>
    <title>DASCTF 2024最后一战 RE wp</title>
    <url>/2024/12/24/DASCTF-2024%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98-RE/</url>
    <content><![CDATA[<p><strong>前言：期末周 要做课设 还要复习考试 所以今天才复现整理完wp</strong></p>
<h2 id="tryre"><a href="#tryre" class="headerlink" title="tryre"></a>tryre</h2><p>真正的签到题！ida打开附件 发现密文和更换的base64码表</p>
<span id="more"></span>

<p><img src="/../images/img_dasctf1.png" alt="img_dasctf1"></p>
<p>随后继续看发现异或2</p>
<p><img src="/../images/img_das2.png" alt="img_das2"></p>
<p>所以解密就是异或2然后换码表解码 直接写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc=&#x27;M@ASL3MF`uL3ICT2IhUgKSD2IeDsICH7Hd26HhQgKSQhNCX7TVL3UFMeHi2?&#x27;  </span><br><span class="line">flag=[]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    flag.append(ord(enc[i])^2)  </span><br><span class="line">    print(chr(flag[i]),end=&#x27;&#x27;)  </span><br><span class="line">print()  </span><br><span class="line">import base64  </span><br><span class="line">import string  </span><br><span class="line">string = &quot;OBCQN1ODbwN1KAV0KjWeIQF0KgFqKAJ5Jf04JjSeIQSjLAZ5VTN1WDOgJk0=&quot;  </span><br><span class="line">tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">tableNew =    &quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;  </span><br><span class="line">flag = base64.b64decode(string.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">print (flag)</span><br><span class="line">b&#x27;DASCTF&#123;454646fa-2462-4392-82ea-5f809ad5ddc2&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="黑客不许哭"><a href="#黑客不许哭" class="headerlink" title="黑客不许哭"></a>黑客不许哭</h2><p>ida打开附件 交叉引用一下输入的值 </p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp.png" alt="黑客不许哭wp"></p>
<p>发现是对输入进行了*1.020123456789<br>往下翻找到比较的地方</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-1.png" alt="黑客不许哭wp-1"></p>
<p>最终比较的数据很大 猜测是对输入进行了乘法操作</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-2.png" alt="黑客不许哭wp-2"></p>
<p>写个脚本解一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qword_7FF64E34A170 = [  </span><br><span class="line">    4358.58716, 6122.2983, 2158.74574, 5973.017537, 9173.840881,  </span><br><span class="line">    6164.67827, 12293.528276, 4091.327439, 3360.696562, 2403.667017,  </span><br><span class="line">    3199.455077, 4962.117508, 8266.407604, 2863.062918, 1044.626306,  </span><br><span class="line">    1067.5308730000002, 3217.476319, 6260.942959, 3278.952568, 160.724197,  </span><br><span class="line">    596.797742, 3277.973032, 6368.757598, 842.858109, 5925.142209,  </span><br><span class="line">    3046.937162, 12752.384458, 2442.54747, 1827.164764, 4903.961921,  </span><br><span class="line">    5619.869598, 3851.247916, 4472.987644, 13135.636855, 1640.630636,  </span><br><span class="line">    975.429551, 2174.379531, 2289.845471, 2605.707441, 1488.586824,  </span><br><span class="line">    12216.019619, 4588.270425, 4803.36317, 13035.30263  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A010 = [  </span><br><span class="line">    60.51846366284686, 89.4737043286176, 24.031047113523933, 84.68873702464015,  </span><br><span class="line">    104.66953644646323, 83.75627693648984, 96.41044018110416, 75.27071882034213,  </span><br><span class="line">    60.33140727998576, 46.10475987767577, 56.28563000222285, 86.68936481373537,  </span><br><span class="line">    80.87786332435297, 55.29894355978243, 9.261748448423328, 20.6272127322797,  </span><br><span class="line">    31.189741971747896, 116.18656005122571, 30.859918262868042, 1.0633446004217317,  </span><br><span class="line">    10.591447767777225, 55.64965261721374, 122.95044769452201, 7.140637105592679,  </span><br><span class="line">    55.44977106531295, 62.827038867512506, 125.30574894504994, 45.94487116254584,  </span><br><span class="line">    32.57185367060958, 92.37291765689986, 117.68050783530462, 63.422414786033976,  </span><br><span class="line">    84.08593452538155, 125.30354189600813, 26.504600725852114, 15.6085145259943,  </span><br><span class="line">    35.687075116213585, 37.67352051379848, 24.32434117146088, 25.692484908155073,  </span><br><span class="line">    116.46382825728031, 86.30264794289376, 79.51984419851664, 100.65174601005425  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A000 = 1.020123456789  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(44):  </span><br><span class="line">    value = (((qword_7FF64E34A170[i]) / qword_7FF64E34A000)-1) / qword_7FF64E34A010[i]  </span><br><span class="line">    flag.append(chr(int(value)))  </span><br><span class="line">print(&quot;&quot;.join(flag))</span><br><span class="line">#FCXEUH|56378d2n2e4h792sh/c464.;4f&lt;=;;h8f4;~</span><br></pre></td></tr></table></figure>

<p>解不开 但是已知flag头是DASCTF 直接测试一下 发现和最终的结果差了100左右</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-3.png" alt="黑客不许哭wp-3"></p>
<p>修改一下脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">test1 = (((ord(&quot;D&quot;)) * 1.020123456789) + 1) * 60.51846366284686  </span><br><span class="line">print(test1)  </span><br><span class="line">test2 = (((ord(&quot;A&quot;)) * 1.020123456789)+ 1) * 89.4737043286176  </span><br><span class="line">print(test2)  </span><br><span class="line">test3 = (((ord(&quot;S&quot;)) * 1.020123456789)+ 1) * 24.031047113523933  </span><br><span class="line">print(test3)  </span><br><span class="line">  </span><br><span class="line">qword_7FF64E34A170 = [  </span><br><span class="line">    4358.58716, 6122.2983, 2158.74574, 5973.017537, 9173.840881,  </span><br><span class="line">    6164.67827, 12293.528276, 4091.327439, 3360.696562, 2403.667017,  </span><br><span class="line">    3199.455077, 4962.117508, 8266.407604, 2863.062918, 1044.626306,  </span><br><span class="line">    1067.5308730000002, 3217.476319, 6260.942959, 3278.952568, 160.724197,  </span><br><span class="line">    596.797742, 3277.973032, 6368.757598, 842.858109, 5925.142209,  </span><br><span class="line">    3046.937162, 12752.384458, 2442.54747, 1827.164764, 4903.961921,  </span><br><span class="line">    5619.869598, 3851.247916, 4472.987644, 13135.636855, 1640.630636,  </span><br><span class="line">    975.429551, 2174.379531, 2289.845471, 2605.707441, 1488.586824,  </span><br><span class="line">    12216.019619, 4588.270425, 4803.36317, 13035.30263  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A010 = [  </span><br><span class="line">    60.51846366284686, 89.4737043286176, 24.031047113523933, 84.68873702464015,  </span><br><span class="line">    104.66953644646323, 83.75627693648984, 96.41044018110416, 75.27071882034213,  </span><br><span class="line">    60.33140727998576, 46.10475987767577, 56.28563000222285, 86.68936481373537,  </span><br><span class="line">    80.87786332435297, 55.29894355978243, 9.261748448423328, 20.6272127322797,  </span><br><span class="line">    31.189741971747896, 116.18656005122571, 30.859918262868042, 1.0633446004217317,  </span><br><span class="line">    10.591447767777225, 55.64965261721374, 122.95044769452201, 7.140637105592679,  </span><br><span class="line">    55.44977106531295, 62.827038867512506, 125.30574894504994, 45.94487116254584,  </span><br><span class="line">    32.57185367060958, 92.37291765689986, 117.68050783530462, 63.422414786033976,  </span><br><span class="line">    84.08593452538155, 125.30354189600813, 26.504600725852114, 15.6085145259943,  </span><br><span class="line">    35.687075116213585, 37.67352051379848, 24.32434117146088, 25.692484908155073,  </span><br><span class="line">    116.46382825728031, 86.30264794289376, 79.51984419851664, 100.65174601005425  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A000 = 1.020123456789  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(44):  </span><br><span class="line">    value = (((qword_7FF64E34A170[i]) / qword_7FF64E34A000)-1) / qword_7FF64E34A010[i]  </span><br><span class="line">    flag.append(chr(int(value)))  </span><br><span class="line">print(&quot;&quot;.join(flag))</span><br><span class="line">#DASCTF&#123;34056b0c-a3d7-71ef-b132-92e8688d4e29&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h2 id="刻板印象"><a href="#刻板印象" class="headerlink" title="刻板印象"></a>刻板印象</h2><p>ida打开附件 乍一看逻辑很简单 只有一个异或</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1.png" alt="刻板印象"></p>
<p>写脚本解一下 发现是fake的flag </p>
<p>This_is_clearly_a_fake_flag_so_try_to_find_more.</p>
<p>随后看一下汇编 发现有花 nop掉重新f5即可恢复原本的函数</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-1.png" alt="刻板印象-1"></p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-2.png" alt="刻板印象-2"></p>
<p>发现是一个xtea＋异或 写个脚本解一下 还是fakeflag</p>
<p>fakeflag_plz_Try_more_hard_to_find_the_true_flag</p>
<p>于是打算看看函数 发现了一个tls没有用到 起调试跑一下 发现从xtea出来进入了一个新的函数 那个新函数刚好是tls函数中的</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-3.png" alt="刻板印象-3"></p>
<p>单步运行到最后 发现跳转到一个新的地址 有很多一段一段的汇编</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-4.png" alt="刻板印象-4"></p>
<p>运行一会 问了一下gpt 大概是xxtea<br>发现密钥{What_is_this_?} delta是0x11451419</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-6.png" alt="刻板印象-6"></p>
<p>跑到最后还有一个xor 提取一下 所以总体逻辑就是 xor xtea xor xxtea xor<br>写逆向脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define MX (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z)))</span><br><span class="line">typedef unsigned char BYTE;</span><br><span class="line">unsigned char aLaughterIsPois[] = &quot;Laughter_is_poison_to_fear&quot;;</span><br><span class="line">unsigned char xor_xtea_num[48] = &#123;0xDA, 0x30, 0x23, 0xE3, 0xDC, 0x39, 0x82, 0x60, 0xA5, 0x44,</span><br><span class="line">                                  0x68, 0xC2, 0x43, 0x7A, 0xBB, 0xE4, 0x50, 0xE1, 0x02, 0xC2,</span><br><span class="line">                                  0x81, 0x59, 0xEA, 0x1E, 0xC6, 0x8B, 0x71, 0x38, 0x27, 0x83,</span><br><span class="line">                                  0x94, 0xD8, 0xF4, 0x8D, 0x1A, 0x2A, 0x56, 0x8A, 0x4A, 0xD4,</span><br><span class="line">                                  0x54, 0xDC, 0x24, 0x3F, 0xB9, 0xED, 0x7B, 0x9A&#125;;</span><br><span class="line">unsigned char xor_xxtea_num[48] = &#123;0x8f, 0x6c, 0xa6, 0x3f, 0x94, 0x3d, 0xf5, 0xd9, 0x36, 0x66, 0x51, 0xd7, 0x66,</span><br><span class="line">                                   0x2f, 0xb3, 0x8f, 0xc0, 0x61, 0x9e, 0xce, 0xe9, 0xd7, 0xe1, 0xbf, 0x13, 0x14,</span><br><span class="line">                                   0x16, 0x14, 0xc2, 0xe7, 0xc3, 0x3a, 0x7f, 0x94, 0xa1, 0xe7, 0x24, 0x0e, 0xa7,</span><br><span class="line">                                   0x5c, 0xd3, 0x77, 0xfe, 0x4f, 0x11, 0xdc, 0x69, 0x23&#125;;</span><br><span class="line">void xtea_decrypt(unsigned char *data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= xor_xtea_num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned int *v = (unsigned int *)data;</span><br><span class="line">    unsigned char key_xtea[] = &quot;&#123;you_find_it_!?&#125;&quot;;</span><br><span class="line">    unsigned int *v8 = (unsigned int *)key_xtea;</span><br><span class="line">    for (int l = 0; l &lt; 12; l += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned int v6 = v[l], v5 = v[l + 1], v4 = 0;</span><br><span class="line">        unsigned int delta = 0x61C88647;</span><br><span class="line">        v4 = -1 * 32 * delta;</span><br><span class="line">        for (int i = 0; i &lt; 32; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v5 -= (v8[(v4 &gt;&gt; 11) &amp; 3] + v4) ^ (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6);</span><br><span class="line">            v4 += delta;</span><br><span class="line">            v6 -= (v8[v4 &amp; 3] + v4) ^ (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5);</span><br><span class="line">        &#125;</span><br><span class="line">        v[l] = v6;</span><br><span class="line">        v[l + 1] = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= aLaughterIsPois[i % 26];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void xxtea_decrypt(uint8_t *data)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= xor_xxtea_num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int n = -12;</span><br><span class="line">    uint32_t *v = (uint32_t *)data;</span><br><span class="line">    unsigned char *key_xxtea = &quot;&#123;What_is_this_?&#125;&quot;;</span><br><span class="line">    uint32_t *key = (unsigned int *)key_xxtea;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    unsigned int delta = 0x11451419;</span><br><span class="line">    if (n &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52 / n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n - 1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += delta;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p = 0; p &lt; n - 1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p + 1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n - 1] += MX;</span><br><span class="line">        &#125; while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52 / n;</span><br><span class="line">        sum = rounds * delta;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p = n - 1; p &gt; 0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p - 1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n - 1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= delta;</span><br><span class="line">        &#125; while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char data[48] = &#123;0x18, 0x09, 0x1C, 0x14, 0x37, 0x1D, 0x16, 0x2D, 0x3C, 0x05,</span><br><span class="line">                              0x16, 0x3E, 0x02, 0x03, 0x10, 0x2C, 0x0E, 0x31, 0x39, 0x15,</span><br><span class="line">                              0x04, 0x3A, 0x39, 0x03, 0x0D, 0x13, 0x2B, 0x3E, 0x06, 0x08,</span><br><span class="line">                              0x37, 0x00, 0x17, 0x0B, 0x00, 0x1D, 0x1C, 0x00, 0x16, 0x06,</span><br><span class="line">                              0x07, 0x17, 0x30, 0x03, 0x30, 0x06, 0x0A, 0x71&#125;;</span><br><span class="line">    xxtea_decrypt(data);</span><br><span class="line">    xtea_decrypt(data, 48);</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#DASCTF&#123;You_come_to_me_better_than_all_the_good.&#125;</span><br></pre></td></tr></table></figure>



<h2 id="secret-of-inkey"><a href="#secret-of-inkey" class="headerlink" title="secret_of_inkey"></a>secret_of_inkey</h2><p>ida打开附件 打开字符串发现key</p>
<p><img src="/../images/img_das3.png" alt="img_das3"></p>
<p>先放程序里跑一下 得到了别的格子的key 所以应该是每个格子有对应的key 某一个格子会给flag<br>在查找Please input the key 跟进到主要逻辑的函数</p>
<p><img src="/../images/secret_of_inkey.png" alt="secret_of_inkey"></p>
<p>向下翻找到加密函数</p>
<p><img src="/../images/secret_of_inkey-1.png" alt="secret_of_inkey-1"></p>
<p>跟进此函数</p>
<p><img src="/../images/secret_of_inkey-2.png" alt="secret_of_inkey-2"></p>
<p>这里是对密文进行处理 跟密钥与下标的异或值异或 随后进行aes加密 findcrypt也可看出<br>找密文 发现sub_402350里有大量的数据 计算一下刚好是960个 跟程序里的格子数一样 猜测是密文 写个脚本提取出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import idc</span><br><span class="line">import idaapi</span><br><span class="line">import idautils</span><br><span class="line">start_address = 0x0000000000420140</span><br><span class="line">end_address = 0x000000000043E1BF</span><br><span class="line">output_file = &quot;1.txt&quot;</span><br><span class="line">def data(start, end, file_path):</span><br><span class="line">    with open(file_path, &quot;w&quot;) as f:</span><br><span class="line">        current_address = start</span><br><span class="line">        while current_address &lt;= end:</span><br><span class="line">            byte = idc.get_wide_byte(current_address)</span><br><span class="line">            f.write(f&quot;&#123;byte:02x&#125;&quot;)</span><br><span class="line">            current_address += 1</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    data(start_address, end_address, output_file)</span><br></pre></td></tr></table></figure>

<p>所以可以循环解密 发现密钥则更改密钥再次解密 直到爆破出flag 当时比赛做的时候这个脚本搓了好久没出 赛后看师傅们的wp才搓出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import AES  </span><br><span class="line">import re  </span><br><span class="line">  </span><br><span class="line">def aes_decrypt(ciphertext, key):  </span><br><span class="line">    cipher = AES.new(key.encode(), AES.MODE_ECB)  </span><br><span class="line">    return cipher.decrypt(ciphertext)  </span><br><span class="line">  </span><br><span class="line">def xor_with_key(data, key):  </span><br><span class="line">    result = bytearray(data)  </span><br><span class="line">    for i in range(len(data)):  </span><br><span class="line">        result[i] ^= i ^ ord(key[i % len(key)])  </span><br><span class="line">    return result  </span><br><span class="line">  </span><br><span class="line">def process_encryption(enc, key):  </span><br><span class="line">    enc_aes = [enc[i * 32:(i + 1) * 32] for i in range(len(enc) // 32)]  </span><br><span class="line">    keys = key.copy()  </span><br><span class="line">  </span><br><span class="line">    blast = True  </span><br><span class="line">    while blast:  </span><br><span class="line">        blast = False  </span><br><span class="line">        for key_id, key_value in list(keys.items()):  </span><br><span class="line">            #print(f&quot;&#123;key_id&#125;,&#123;key_value&#125;&quot;)  </span><br><span class="line">            de_aes = AES.new(key_value.encode(), AES.MODE_ECB)  </span><br><span class="line">            for i in enc_aes[:]:  </span><br><span class="line">                enc1 = xor_with_key(i, key_value)  </span><br><span class="line">                dec = aes_decrypt(bytes(enc1), key_value)  </span><br><span class="line">  </span><br><span class="line">                if dec[:6] == b&#x27;key_of&#x27;:  </span><br><span class="line">                    x = re.findall(&#x27;key_of_(\d+)_is_&quot;([0-9a-f]+)&quot;&#x27;, dec.decode())  </span><br><span class="line">                    if x and x[0][0] not in keys:  </span><br><span class="line">                        keys[x[0][0]] = x[0][1]  </span><br><span class="line">                    enc_aes.remove(i)  </span><br><span class="line">                    blast = True  </span><br><span class="line">  </span><br><span class="line">    return keys, enc_aes  </span><br><span class="line">  </span><br><span class="line">def final_decrypt(enc_aes, keys):  </span><br><span class="line">    for key_id, key_value in keys.items():  </span><br><span class="line">        print(f&quot;&#123;key_id&#125;,&#123;key_value&#125;&quot;)  </span><br><span class="line">        for i in enc_aes:  </span><br><span class="line">            enc1 = xor_with_key(i, key_value)  </span><br><span class="line">            dec = aes_decrypt(bytes(enc1), key_value)  </span><br><span class="line">            if all(32 &lt;= b &lt;= 126 for b in dec):  </span><br><span class="line">                print(f&quot;Key &#123;key_id&#125;: &#123;dec.decode()&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">enc = bytes.fromhex(&#x27;c9ef...1797&#x27;)  # 这里应该填入密文  </span><br><span class="line">key = &#123;&#x27;565&#x27;: &#x27;9fc82e15d9de6ef2&#x27;&#125;  </span><br><span class="line">keys, enc_aes = process_encryption(enc, key)  </span><br><span class="line">final_decrypt(enc_aes, keys)</span><br></pre></td></tr></table></figure>

<p>爆破完就能看见各个选项里的值 找到key和flag</p>
<p><img src="/../images/secret_of_inkey-3.png" alt="secret_of_inkey-3"></p>
<blockquote>
<p>参考博客：<a href="https://blog.csdn.net/sln_1550/article/details/144635181">DASCTF 2024最后一战RE题wp-CSDN博客</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Preface</title>
    <url>/2024/12/20/Preface/</url>
    <content><![CDATA[<p>各位师傅好 我是一名ctfer Re选手 隶属于某不知名小战队 活跃在各大比赛之中 最近想进阶一下自己的逆向技术 <span id="more"></span><br>整理了各大比赛的Re题目 并在近期准备学习一下 不会的题目稍后复现 在此期间也想学习pwn的一些知识 所以这个博客记录一下这些Re题目的wp 也作为一个pwn知识笔记 后续参加各大比赛和公开赛的wp也会放在这里 以便自己学习和参考 也希望有地方可以帮助到各位师傅</p>
]]></content>
  </entry>
  <entry>
    <title>2025 ccsssc RE wp</title>
    <url>/2025/01/05/2025-ccsssc-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：还是太菜了 三个RE就出了一个┭┮﹏┭┮ 算是个二血？</strong></p>
<h1 id="donntyousee"><a href="#donntyousee" class="headerlink" title="donntyousee"></a>donntyousee</h1><p>ida打开附件 发现有很多retn花 从start的汇编开始一点一点往下去花 </p>
<span id="more"></span>

<p><img src="/../images/donntyousee-1.png" alt="donntyousee-1"></p>
<p><img src="/../images/donntyousee-2.png" alt="donntyousee-2"></p>
<p><img src="/../images/donntyousee-3.png" alt="donntyousee-3"></p>
<p><img src="/../images/donntyousee-4.png" alt="donntyousee-4"></p>
<p><img src="/../images/donntyousee-5.png" alt="donntyousee-5"></p>
<p><img src="/../images/donntyousee-6.png" alt="donntyousee-6"></p>
<p><img src="/../images/donntyousee-7.png" alt="donntyousee-7"></p>
<p>花都去差不多之后 开始看代码</p>
<p><img src="/../images/donntyousee-8.png" alt="donntyousee-8"></p>
<p>RC4密钥流生成 继续往下看</p>
<p><img src="/../images/donntyousee-9.png" alt="donntyousee-9"></p>
<p>RC4加密</p>
<p><img src="/../images/donntyousee-10.png" alt="donntyousee-10"></p>
<p>找到密文数据 dump下来 注意小端序<br>25CD54AF511C58D3A84B4F56EC835DD4F6474A6FE073B0A5A8C317815E2BF4F671EA2FFFA8639957</p>
<p><img src="/../images/donntyousee-11.png" alt="donntyousee-11"></p>
<p>异或0x23</p>
<p><img src="/../images/donntyousee-12.png" alt="donntyousee-12"></p>
<p>前十三位是密钥 异或0x45 起个调试dump下来<br>D7596E5AFFBEE7BA422C38325DC9<br>赛博厨子跑一下 发现解不开</p>
<p><img src="/../images/donntyousee-13.png" alt="donntyousee-13"></p>
<p>所以密钥应该是有问题 猜测可能有个反调试会修改密钥 使其进行异或 那么直接取出来密钥就好<br>921C2B1FBAFBA2FF07697D77188C</p>
<p><img src="/../images/donntyousee-14.png" alt="donntyousee-14"></p>
<p>拿到flag</p>
]]></content>
  </entry>
  <entry>
    <title>2024 春秋杯夏季赛 RE wp</title>
    <url>/2025/01/13/2024-%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%A4%8F%E5%AD%A3%E8%B5%9B-Re-wp/</url>
    <content><![CDATA[<p><strong>前言：这两天做了一下去年春秋杯夏季赛的RE 难度不是很大 知识面涉及的很广 希望今年的冬季赛也可以多做出来几个题</strong></p>
<h1 id="snake"><a href="#snake" class="headerlink" title="snake"></a>snake</h1><p>python的exe程序 环境python3.8解包即可 把snake.pyc扔在线反编译里看一下 发现是一个RC4加密 最后异或的地方加了个跟循环次数的异或</p>
<span id="more"></span>

<p><img src="/../images/snake.png" alt="snake"></p>
<p>密文已知 在反编译一下key.pyc 找到密钥V3rY_v3Ry_Ez 直接写脚本解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def KSA(key):  </span><br><span class="line">    S = list(range(256))  </span><br><span class="line">    j = 0  </span><br><span class="line">    for i in range(256):  </span><br><span class="line">        j = (j + S[i] + key[i % len(key)]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">    return S  </span><br><span class="line">  </span><br><span class="line">def PRGA(S):  </span><br><span class="line">    i, j = 0, 0  </span><br><span class="line">    while True:  </span><br><span class="line">        i = (i + 1) % 256  </span><br><span class="line">        j = (j + S[i]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">        K = S[(S[i] + S[j]) % 256]  </span><br><span class="line">        yield K  </span><br><span class="line">  </span><br><span class="line">def RC4(key, text):  </span><br><span class="line">    S = KSA(key)  </span><br><span class="line">    keystram = PRGA(S)  </span><br><span class="line">    res = []  </span><br><span class="line">    for i, char in enumerate(text):  </span><br><span class="line">        res.append(i ^ char ^ next(keystram))  </span><br><span class="line">    return bytes(res)  </span><br><span class="line">  </span><br><span class="line">key = b&#x27;V3rY_v3Ry_Ez&#x27;  </span><br><span class="line">plaintext = [101, 97, 39, 125, 218, 172, 205, 3, 235, 195, 72, 125, 89, 130, </span><br><span class="line">             103, 213, 120, 227, 193, 67, 174, 71, 162, 248, 244, 12, 238,  </span><br><span class="line">             92, 160, 203, 185, 155]  </span><br><span class="line">ciphertext = RC4(key, plaintext)  </span><br><span class="line">print(ciphertext)</span><br><span class="line">#b&#x27;flag&#123;KMLTz3lT_MePUDa7A_P5LpzCBT&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h1 id="HardSignin"><a href="#HardSignin" class="headerlink" title="HardSignin"></a>HardSignin</h1><p>打开附件 发现修改了UPX的特征码 010打开修改回去然后脱壳</p>
<p><img src="/../images/HardSignin.png" alt="HardSignin"></p>
<p>ida打开附件 main的函数看不出来什么逻辑</p>
<p><img src="/../images/HardSignin-1.png" alt="HardSignin-1"></p>
<p>发现TLS函数 跟进交叉引用一下</p>
<p><img src="/../images/HardSignin-2.png" alt="HardSignin-2"></p>
<p>发现花指令 去除</p>
<p><img src="/../images/HardSignin-3.png" alt="HardSignin-3"></p>
<p><img src="/../images/HardSignin-8.png" alt="HardSignin-8"></p>
<p><img src="/../images/HardSignin-9.png" alt="HardSignin-9"></p>
<p>随后分析一下逻辑<br>TLS0是个smc 把main函数跟0x66异或 设置第一个随机数种子 用于TLS1生成变换的码表</p>
<p><img src="/../images/HardSignin-6.png" alt="HardSignin-6"></p>
<p>写个脚本解密一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpAddress = 0x00401890</span><br><span class="line">dwSize = 170</span><br><span class="line">for i in range(170):</span><br><span class="line">    main = (get_wide_byte(lpAddress + i)) ^ 0x66</span><br><span class="line">    patch_byte(lpAddress + i , main)</span><br></pre></td></tr></table></figure>

<p>成功恢复main函数</p>
<p><img src="/../images/HardSignin-7.png" alt="HardSignin-7"></p>
<p>随后看TLS1<br>进行了一个码表的变换 设置第二个随机数种子 用于TLS2生成rc4的key和xtea的key</p>
<p><img src="/../images/HardSignin-10.png" alt="HardSignin-10"></p>
<p>TLS2是进行了两个数的生成 交叉引用可以知道分别是rc4的key和xtea的key</p>
<p><img src="/../images/HardSignin-13.png" alt="HardSignin-13"></p>
<p>这几个函数都有反调试 直接patch即可<br>然后看主函数 逻辑很清晰 对密文进行base64换表编码 随后RC4加密 最后xtea加密</p>
<p><img src="/../images/HardSignin-12.png" alt="HardSignin-12"></p>
<p>xtea魔改了一下 轮数是100</p>
<p><img src="/../images/HardSignin-14.png" alt="HardSignin-14"></p>
<p>密文就是下面比对的unk_374000<br>我这里不知道为什么调试总是起不来 猜测可能是因为smc我手动解密之后 他TLS0重新跑了一次 把main函数异或回去了 所以索性静态写个脚本 跑一下key和变换后的base码表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void swap(char *a1, char *a2)</span><br><span class="line">&#123;</span><br><span class="line">    char v3;</span><br><span class="line">    v3 = *a1;</span><br><span class="line">    *a1 = *a2;</span><br><span class="line">    *a2 = v3;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char table[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line">    srand(0x114514u);</span><br><span class="line">    for (int i = 0; i &lt; 100; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int v3 = rand() % 64;</span><br><span class="line">        int v5 = rand() % 64;</span><br><span class="line">        swap(&amp;table[v3], &amp;table[v5]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%s\n&quot;, table);</span><br><span class="line">    srand(0x1919810u);</span><br><span class="line">    for (int j = 0; j &lt; 16; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        int rc4_key = rand() % 255;</span><br><span class="line">        int xtea_key = rand() % 255;</span><br><span class="line">        printf(&quot;%d,%d\n&quot;, rc4_key, xtea_key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">new_table=4yZRiNP8LoK/GSA5ElWkUjXtJCz7bMYcuFfpm6+hV0rxeHIdwv32QOTnqg1BDsa9</span><br><span class="line">rc4_key=[118, 137, 51, 73, 25, 19, 195, 199, 173, 216, 228, 104, 252, 72, 4, 188]</span><br><span class="line">xtea_key=[221, 91, 170, 12, 36, 105, 132, 214, 184, 30, 4, 81, 6, 171, 42, 139]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>得到rc4_key和xtea_key的key后 已知密文 直接写脚本解密即可<br>先解xtea</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void xtea_decrypt(unsigned int round, uint32_t enc[2], uint32_t key[4])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    unsigned int j;  // [esp+4Ch] [ebp-18h]</span><br><span class="line">    unsigned int v5; // [esp+54h] [ebp-10h]</span><br><span class="line">    unsigned int v6; // [esp+58h] [ebp-Ch]</span><br><span class="line">    unsigned int v7; // [esp+5Ch] [ebp-8h]</span><br><span class="line">    v7 = enc[0];</span><br><span class="line">    v6 = enc[1];</span><br><span class="line">    v5 = 0 - round * 0x61C88647;</span><br><span class="line">    for (j = 0; j &lt; round; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        v6 -= (key[((v5 &gt;&gt; 11) &amp; 3)] + v5) ^ (v7 + ((v7 &gt;&gt; 5) ^ (16 * v7)));</span><br><span class="line">        v5 += 0x61C88647;</span><br><span class="line">        v7 -= (key[((v5 &amp; 3))]) + v5 ^ (v6 + ((v6 &gt;&gt; 5) ^ (16 * v6)));</span><br><span class="line">    &#125;</span><br><span class="line">    enc[0] = v7;</span><br><span class="line">    enc[1] = v6;</span><br><span class="line">&#125;</span><br><span class="line">unsigned char enc[] = &#123;0x59, 0x1B, 0xFD, 0xB4, 0x6B, 0xB8, 0xBE, 0xD9, 0xB3, 0xD3, 0x77, 0xD6, 0xF0, 0x65, 0x5F, 0x18,0xA0, 0x9D, 0x3A, 0x53, 0x6D, 0x4A, 0x7B, 0x26, 0x74, 0x3A, 0x9C, 0x4E, 0x20, 0x43, 0x19, 0xD8, 0x72, 0xED, 0x95, 0xB5, 0x9C, 0x05, 0x22, 0x56, 0xCB, 0x7A, 0x11, 0x91, 0x9F, 0x7A, 0xBC, 0x0C,0x4A, 0x69, 0x6D, 0xCE, 0x3D, 0xB4, 0xAB, 0x29, 0x61, 0xFA, 0x62, 0x32, 0xB4, 0xEC, 0x4C, 0xB6, 0x00&#125;;</span><br><span class="line">    uint32_t xtea_key[] = &#123;0x0CAA5BDD, 0xD6846924, 0x51041EB8, 0x8B2AAB06&#125;;</span><br><span class="line">    for (int k = 0; k &lt; sizeof(enc) / 8; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        xtea_decrypt(100, (uint32_t*)enc + k * 2, xtea_key);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int m = 0; m &lt; 64; m++)</span><br><span class="line">        printf(&quot;0x%x,&quot;, enc[m]);</span><br></pre></td></tr></table></figure>

<p>得到RC4的密文<br>0xbc 0xed 0x0 0x7b 0x86 0xf4 0x16 0x93 0x95 0xf9 0x87 0xdc 0x67 0xa8 0xa2 0x7f 0x4d 0xe2 0x62 0x9f 0x7b 0x34 0xae 0xe9 0x45 0x3 0x7e 0x35 0x42 0xd0 0x8b 0x70 0xf0 0xfb 0x2e 0xc7 0xdd 0xe9 0xb9 0x73 0xe3 0xcc 0x1a 0x75 0xad 0xdc 0xfd 0x14 0xa8 0xc8 0x45 0x16 0x31 0x6e 0x2a 0x8 0x2c 0xf 0x1d 0x9f 0x7 0xba 0xd5 0xef</p>
<p>随后解密RC4 + 换表base64</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64  </span><br><span class="line">import string  </span><br><span class="line">#RC4解密  </span><br><span class="line">def ksa(key):  </span><br><span class="line">    S = list(range(256))  </span><br><span class="line">    j = 0  </span><br><span class="line">    key_length = len(key)  </span><br><span class="line">  </span><br><span class="line">    for i in range(256):  </span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">  </span><br><span class="line">    return S  </span><br><span class="line">  </span><br><span class="line">def prga(S, length):  </span><br><span class="line">    i = j = 0  </span><br><span class="line">    keystream = []  </span><br><span class="line">    for _ in range(length):  </span><br><span class="line">        i = (i + 1) % 256  </span><br><span class="line">        j = (j + S[i]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">        keystream.append(S[(S[i] + S[j]) % 256])  </span><br><span class="line">    return keystream  </span><br><span class="line">def rc4(key, plaintext):  </span><br><span class="line">    S = ksa(key)  </span><br><span class="line">    keystream = prga(S, len(plaintext))  </span><br><span class="line">    return bytes([p ^ k for p, k in zip(plaintext, keystream)])  </span><br><span class="line">key = [118, 137, 51, 73, 25, 19, 195, 199, 173, 216, 228, 104, 252, 72, 4, 188]  </span><br><span class="line">ciphertext = [0xbc,0xed,0x0,0x7b,0x86,0xf4,0x16,0x93,0x95,0xf9,0x87,0xdc,0x67,0xa8,0xa2,0x7f,0x4d,0xe2,0x62,0x9f,0x7b,0x34,0xae,0xe9,0x45,0x3,0x7e,0x35,0x42,0xd0,0x8b,0x70,0xf0,0xfb,0x2e,0xc7,0xdd,0xe9,0xb9,0x73,0xe3,0xcc,0x1a,0x75,0xad,0xdc,0xfd,0x14,0xa8,0xc8,0x45,0x16,0x31,0x6e,0x2a,0x8,0x2c,0xf,0x1d,0x9f,0x7,0xba,0xd5,0xef]  </span><br><span class="line">decrypted = rc4(key, ciphertext)  </span><br><span class="line">print(decrypted)  </span><br><span class="line">#base64换表  </span><br><span class="line">string = &quot;C+vFCnHRGPghbmyQMXvFMRNd7fNCG8jcU+jcbnjRJTj2GTCOGUvgtOS0CTge7fNs&quot;  </span><br><span class="line">tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">tableNew =    &quot;4yZRiNP8LoK/GSA5ElWkUjXtJCz7bMYcuFfpm6+hV0rxeHIdwv32QOTnqg1BDsa9&quot;  </span><br><span class="line">flag = base64.b64decode(string.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">print (flag)</span><br><span class="line">#b&#x27;flag&#123;C0ngr@tulat1on!Y0u_Re_suCces3fu1Ly_Signln!&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h1 id="bedtea"><a href="#bedtea" class="headerlink" title="bedtea"></a>bedtea</h1><p>ida打开附件 进入main函数<br>前面是两个反调试 还有输入的部分</p>
<p><img src="/../images/bedtea.png" alt="bedtea"></p>
<p>看下面的那个反调试 如果检测到调试是1 没检测到调试是3<br>随后往下看 发现有三个魔改的tea 修改了轮数 delta还有移位等常量值</p>
<p><img src="/../images/bedtea-1.png" alt="bedtea-1"></p>
<p><img src="/../images/bedtea-2.png" alt="bedtea-2"></p>
<p>上面有个斐波那契数列计算tea的key </p>
<p><img src="/../images/bedtea-3.png" alt="bedtea-3"></p>
<p>起个调试取出三个key 注意把第一个调试的值改为3才会生成正确的key</p>
<p><img src="/../images/bedtea-4.png" alt="bedtea-4"></p>
<p>第一组key：3,5,8,13</p>
<p><img src="/../images/bedtea-6.png" alt="bedtea-6"></p>
<p>第二组key：0x15,0x22,0x37,0x59</p>
<p><img src="/../images/bedtea-7.png" alt="bedtea-7"></p>
<p>第三组key：0x90,0xE9,0x179,0x262</p>
<p><img src="/../images/bedtea-8.png" alt="bedtea-8"></p>
<p>随后通过二叉树对数据进行处理 这个地方的逻辑静态看有点费劲 直接动态对比数据即可</p>
<p><img src="/../images/bedtea-9.png" alt="bedtea-9"></p>
<p><img src="/../images/bedtea-10.png" alt="bedtea-10"></p>
<p>发现对数据进行倒叙处理<br>中间一堆看不懂的代码 经过动态调试 发现是跟0x33异或</p>
<p><img src="/../images/bedtea-12.png" alt="bedtea-12"></p>
<p>这里过一个时间的反调试 通过汇编可以看出函数在这个地方会进行跳转</p>
<p><img src="/../images/bedtea-13.png" alt="bedtea-13"></p>
<p>所以把zf值置为1即可过掉反调试<br>最后的地方存放三段密文</p>
<p><img src="/../images/bedtea-11.png" alt="bedtea-11"></p>
<p>总的逻辑就是 先tea 然后倒置 最后异或0x33<br>直接写逆向脚本解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void tea_decrypt(uint32_t *v, uint32_t *key)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v0 = v[0], v1 = v[1], delta = 0x61CBB648, i, k0 = key[0], k1 = key[1], k2 = key[2], k3 = key[3];</span><br><span class="line">    unsigned int sum = 0x987E55D0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        v1 -= (sum + v0) ^ (k3 + (v0 &gt;&gt; 4)) ^ (k2 + 32 * v0);</span><br><span class="line">        v0 -= (sum + v1) ^ (k1 + (v1 &gt;&gt; 4)) ^ (k0 + 32 * v1);</span><br><span class="line">        sum += 0x61CBB648;</span><br><span class="line">    &#125; while (sum != 0);</span><br><span class="line">    v[0] = v0, v[1] = v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char rev;</span><br><span class="line">    unsigned char enc[] = &#123;0x76, 0x71, 0x9D, 0xE7, 0x70,</span><br><span class="line">                           0x77, 0x3F, 0xA3, 0x02, 0xF1,</span><br><span class="line">                           0x8D, 0xC9, 0x02, 0xC6, 0xA2,</span><br><span class="line">                           0x4B, 0xBA, 0x19, 0x56, 0x05,</span><br><span class="line">                           0xF2, 0x89, 0x5E, 0xE0&#125;;</span><br><span class="line">    unsigned int key1[] = &#123;3, 5, 8, 13&#125;;</span><br><span class="line">    unsigned int key2[] = &#123;0x15, 0x22, 0x37, 0x59&#125;;</span><br><span class="line">    unsigned int key3[] = &#123;0x90, 0xE9, 0x179, 0x262&#125;;</span><br><span class="line">    //xor 0x33</span><br><span class="line">    for (int i = 0; i &lt; 24; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        enc[i] ^= 0x33;</span><br><span class="line">    &#125;</span><br><span class="line">    //reverse</span><br><span class="line">    for (int j = 0; j &lt; 12; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        rev = enc[j];</span><br><span class="line">        enc[j] = enc[23 - j];</span><br><span class="line">        enc[23 - j] = rev;</span><br><span class="line">    &#125;</span><br><span class="line">    //tea decrypt</span><br><span class="line">    uint32_t *flag1 = (uint32_t *)&amp;enc[0];</span><br><span class="line">    uint32_t *flag2 = (uint32_t *)&amp;enc[8];</span><br><span class="line">    uint32_t *flag3 = (uint32_t *)&amp;enc[16];</span><br><span class="line">    tea_decrypt(flag1, key1);</span><br><span class="line">    tea_decrypt(flag2, key2);</span><br><span class="line">    tea_decrypt(flag3, key3);</span><br><span class="line">    for (int k = 0; k &lt; 24; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;, enc[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//flag&#123;y0u_reallyl1ke_te@&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
]]></content>
  </entry>
  <entry>
    <title>2025 suctf RE wp</title>
    <url>/2025/01/14/2025-suctf-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：比赛期间只做出两道RE 其他的题目还没有复现 等复现完在写一下其他RE的wp</strong></p>
<h1 id="SU-BBRE"><a href="#SU-BBRE" class="headerlink" title="SU_BBRE"></a>SU_BBRE</h1><p>打开附件 发现密文和密钥 问一下gpt循环了256次 猜测rc4加密 注意小端序</p>
<span id="more"></span>

<p><img src="/../images/SU_BBRE.png" alt="SU_BBRE"></p>
<p>写个脚本解出第一部分flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def ksa(key):</span><br><span class="line">    S = list(range(256))</span><br><span class="line">    j = 0</span><br><span class="line">    key_length = len(key)</span><br><span class="line">    for i in range(256):</span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % 256</span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">    return S</span><br><span class="line">def prga(S, length):</span><br><span class="line">    i = j = 0</span><br><span class="line">    keystream = []</span><br><span class="line">    for _ in range(length):</span><br><span class="line">        i = (i + 1) % 256</span><br><span class="line">        j = (j + S[i]) % 256</span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">        keystream.append(S[(S[i] + S[j]) % 256])</span><br><span class="line">    return keystream</span><br><span class="line"></span><br><span class="line">def rc4(key, plaintext):</span><br><span class="line">    S = ksa(key)</span><br><span class="line">    keystream = prga(S, len(plaintext))</span><br><span class="line">    return bytes([p ^ k for p, k in zip(plaintext, keystream)])</span><br><span class="line"></span><br><span class="line">key = b&quot;suctf&quot;</span><br><span class="line">ciphertext = [0x2f, 0x5a, 0x57, 0x65, 0x14, 0x8f, 0x69, 0xcd, 0x93, 0x29, 0x1a, 0x55, 0x18, 0x40, 0xe4, 0x5e]</span><br><span class="line">flag1 = rc4(key, ciphertext)</span><br><span class="line">print(flag1)</span><br><span class="line">#b&#x27;We1com3ToReWorld&#x27;</span><br></pre></td></tr></table></figure>

<p>继续往下看 还有一段密文</p>
<p><img src="/../images/SU_BBRE-1.png" alt="SU_BBRE-1"></p>
<p>跟下标进行相加 中间还有一段栈溢出到fun1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag=[0x3d,0x22,0x40]  </span><br><span class="line">print(&#x27;&#x27;.join(chr(x)for x in flag))  </span><br><span class="line">flag2 = []  </span><br><span class="line">enc = [0x41, 0x6D, 0x62, 0x4D, 0x53, 0x49, 0x4e, 0x29, 0x28]  </span><br><span class="line">for i, j in enumerate(enc):  </span><br><span class="line">    flag2.append(chr(i+j))  </span><br><span class="line">    print(flag2[i], end=&#x27;&#x27;)  </span><br><span class="line">#=&quot;@AndPWNT00</span><br></pre></td></tr></table></figure>

<p>拼接起来得到flag<br>SUCTF{We1com3ToReWorld&#x3D;”@AndPWNT00}</p>
<h1 id="SU-minesweeper"><a href="#SU-minesweeper" class="headerlink" title="SU_minesweeper"></a>SU_minesweeper</h1><p>ida打开附件 逻辑很清晰 </p>
<p><img src="/../images/SU_minesweeper-2.png" alt="SU_minesweeper-2"></p>
<p>首先跟进sub_1277 发现进行了一些字符串的转换<br>随后看sub_1432函数 主要的逻辑也在这里</p>
<p><img src="/../images/SU_minesweeper-3.png" alt="SU_minesweeper-3"></p>
<p>有一个400大的数组 20*20 写个脚本提取出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import idc</span><br><span class="line">import idaapi</span><br><span class="line">import idautils</span><br><span class="line">start_addr = 0x0000000000004020</span><br><span class="line">end_addr = 0x00000000000041AF</span><br><span class="line">data = idc.get_bytes(start_addr, end_addr - start_addr + 1)</span><br><span class="line">if data:</span><br><span class="line">	for byte in data:</span><br><span class="line">		print(f&quot;0x&#123;byte:02X&#125;&quot;, end=&quot;,&quot;)</span><br></pre></td></tr></table></figure>

<p>跟进sub_13C9函数 发现是累加 3*3区域内的值 结果返回总和</p>
<p><img src="/../images/SU_minesweeper-4.png" alt="SU_minesweeper-4"></p>
<p>sub_1352函数从指定的 (a2, a3) 坐标位置获取位值 通过计算该位置的字节索引和位偏移提取相应的位</p>
<p><img src="/../images/SU_minesweeper-5.png" alt="SU_minesweeper-5"></p>
<p>flag格式如下</p>
<p><img src="/../images/SU_minesweeper-6.png" alt="SU_minesweeper-6"></p>
<p>已知这些条件 可以先用z3求出解 随后变换求一下md5即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools  </span><br><span class="line">from z3 import *  </span><br><span class="line">enc = [0x03, 0x04, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0x02, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x04, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x04, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x05, 0x06, 0x04, 0xFF, 0x05,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x04, 0x07, 0xFF, 0x08, 0xFF, 0x06, 0xFF, 0xFF, 0x06, 0x06, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0xFF,  </span><br><span class="line">       0x03,  </span><br><span class="line">       0xFF, 0x05, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x05, 0x04, 0x05, 0x07, 0x06, 0xFF, 0xFF, 0x04, 0xFF, 0x02,  </span><br><span class="line">       0x01,  </span><br><span class="line">       0xFF, 0xFF, 0xFF, 0x03, 0x04, 0xFF, 0xFF, 0x05, 0x04, 0x03, 0xFF, 0xFF, 0x07, 0x04, 0x03, 0xFF, 0xFF, 0x01, 0x01,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x04, 0x03, 0xFF, 0x02, 0xFF, 0x04, 0x03, 0xFF, 0xFF, 0x02, 0xFF, 0x05, 0x04, 0xFF, 0xFF, 0x02, 0x02, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x04, 0xFF, 0x04, 0xFF, 0x03, 0x05, 0x06, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0xFF, 0x01, 0x04,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x07, 0x05, 0xFF, 0xFF, 0x03, 0x03, 0x02, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x05, 0x07, 0xFF, 0x03, 0x02, 0x04,  </span><br><span class="line">       0x04,  </span><br><span class="line">       0xFF, 0x07, 0x05, 0x04, 0x03, 0xFF, 0xFF, 0x04, 0xFF, 0x02, 0x04, 0x05, 0xFF, 0xFF, 0x06, 0x05, 0x04, 0xFF, 0x02,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x07, 0x04, 0xFF, 0xFF, 0x03, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x03, 0x02,  </span><br><span class="line">       0x02,  </span><br><span class="line">       0xFF, 0xFF, 0x02, 0x04, 0x03, 0x05, 0xFF, 0xFF, 0x05, 0xFF, 0x04, 0xFF, 0x06, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x03, 0x03, 0xFF, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0x06, 0x06, 0xFF, 0x07, 0x06, 0x04, 0xFF, 0x04,  </span><br><span class="line">       0x03,  </span><br><span class="line">       0xFF, 0x04, 0x03, 0x05, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x06, 0x07, 0xFF, 0xFF, 0x04, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x07, 0xFF, 0x05, 0xFF, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x07, 0xFF, 0x05, 0x06, 0x06, 0xFF, 0xFF, 0x02, 0x04,  </span><br><span class="line">       0x04,  </span><br><span class="line">       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0x07, 0x07, 0x06, 0xFF, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF,  </span><br><span class="line">       0x03,  </span><br><span class="line">       0x05, 0xFF, 0x07, 0xFF, 0x05, 0xFF, 0x06, 0xFF, 0x05, 0xFF, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x03, 0xFF, 0x03, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x05, 0x03, 0xFF, 0x04, 0x05, 0x05, 0x03,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x06, 0x05, 0x05, 0x06, 0xFF, 0x06, 0x05, 0x02, 0x04, 0x03, 0x04, 0xFF, 0xFF, 0x03, 0x04, 0x04, 0x06, 0x05,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x03, 0xFF, 0x05, 0x05, 0x05, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x04, 0xFF, 0x07, 0x07, 0x08, 0x06,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0x04, 0xFF, 0x03, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,  </span><br><span class="line">       0x03]  </span><br><span class="line">  </span><br><span class="line">def get_sum(a1, row, col):  </span><br><span class="line">    if 0 &lt;= row &lt;= 19 and 0 &lt;= col &lt;= 19:  </span><br><span class="line">        return a1[(20 * row + col) // 8] &gt;&gt; ((20 * row + col) &amp; 7) &amp; 1  </span><br><span class="line">  </span><br><span class="line">def check_num(a1, row, col):  </span><br><span class="line">    v5 = 0  </span><br><span class="line">    for i, j in itertools.product([-1, 0, 1], repeat=2):  </span><br><span class="line">        if 0 &lt;= row + i &lt;= 19 and 0 &lt;= col + j &lt;= 19:  </span><br><span class="line">            v5 += get_sum(a1, row + i, col + j)  </span><br><span class="line">    return v5  </span><br><span class="line">  </span><br><span class="line">S = Solver()  </span><br><span class="line">flag = [BitVec(f&#x27;flag_&#123;i&#125;&#x27;, 8) for i in range(50)]  </span><br><span class="line">for i in range(20):  </span><br><span class="line">    for j in range(20):  </span><br><span class="line">        if enc[20 * i + j] != 0xff:  </span><br><span class="line">            S.add(enc[20 * i + j] == check_num(flag, i, j))  </span><br><span class="line">if S.check() == sat:  </span><br><span class="line">    m = S.model()  </span><br><span class="line">    flag_value = &#x27;,&#x27;.join(hex(m[flag[i]].as_long()) for i in range(50))  </span><br><span class="line">    print(flag_value)  </span><br><span class="line">  </span><br><span class="line">c = &#x27;5bdb69bfc51e65fbb50b2039218e8007e02c8f8807fe740d1b916d096d6f1b6e597dcc677ba8b63b6f1d1446587d61efec7d&#x27;  </span><br><span class="line">a = &#x27;0123456789abcdef&#x27;  </span><br><span class="line">b = &#x27;abcdef0123456789&#x27;  </span><br><span class="line">for i in c:  </span><br><span class="line">    print(b[a.index(i)], end=&#x27;&#x27;)  </span><br><span class="line">print()  </span><br><span class="line">import hashlib  </span><br><span class="line">flag = &quot;f57503596fb80f955fa5cad3cb282aa18ac62922a1981ea7b53b07a30709b508f3176601154250d509b7bee0f2170b898617&quot;  </span><br><span class="line">flag_md5 = hashlib.md5(flag.encode()).hexdigest()  </span><br><span class="line">print(flag_md5)</span><br><span class="line">#d661b98e4241de7423ef2d953098329d</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>2024 春秋杯冬季赛 DAY1 RE wp</title>
    <url>/2025/01/17/2024-%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B-DAY1-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：打比赛的时候还是考虑的不够细致 vm的逆向一如既往的拉跨 还是要细心一点 多加强vm的学习吧 也是找到不足之处了 vm的wp官方发了 还没太看 等复现完在写一下wp 没复现的越欠越多了</strong></p>
<h1 id="ezre"><a href="#ezre" class="headerlink" title="ezre"></a>ezre</h1><p>ida打开附件 进入主函数 发现有一个md5的反调试 打个硬件断点过掉</p>
<span id="more"></span>

<p><img src="/../images/Patr1ck-wp-12.png" alt="Patr1ck wp-12"></p>
<p>起调试dump下来随机数</p>
<p><img src="/../images/Patr1ck-wp-13.png" alt="Patr1ck wp-13"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   0x3a, 0x1a, 0x2b, 0x1f, 0x6e, 0x0, 0x32, 0x45, 0x52, 0x44, 0x22, 0x55, 0x3a, 0x37, 0x7d, 0x43, 0x7b, 0x23, 0x52, 0x1c, 0x60, 0x46, 0xa, 0x7, 0x56, 0x38, 0x72, 0x79, 0x10, 0x1d, 0x52, 0x4a, 0x2f, 0x75, 0x61, 0x16, 0x75, 0x14, 0x5c, 0x41, 0x58, 0x76</span><br></pre></td></tr></table></figure>

<p>程序主要逻辑</p>
<p><img src="/../images/Patr1ck-wp-14.png" alt="Patr1ck wp-14"></p>
<p><img src="/../images/Patr1ck-wp-15.png" alt="Patr1ck wp-15"></p>
<p>密文</p>
<p><img src="/../images/Patr1ck-wp-16.png" alt="Patr1ck wp-16"></p>
<p>写脚本解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc=[  0x5C, 0x76, 0x4A, 0x78, 0x15, 0x62, 0x05, 0x7C, 0x6B, 0x21,  </span><br><span class="line">  0x40, 0x66, 0x5B, 0x1A, 0x48, 0x7A, 0x1E, 0x46, 0x7F, 0x28,  </span><br><span class="line">  0x02, 0x75, 0x68, 0x2A, 0x34, 0x0C, 0x4B, 0x1D, 0x3D, 0x2E,  </span><br><span class="line">  0x6B, 0x7A, 0x17, 0x45, 0x07, 0x75, 0x47, 0x27, 0x39, 0x78,  </span><br><span class="line">  0x61, 0x0B]  </span><br><span class="line">key=[0x3a, 0x1a, 0x2b, 0x1f, 0x6e, 0x0, 0x32, 0x45, 0x52, 0x44, 0x22, 0x55, 0x3a, 0x37, 0x7d, 0x43, 0x7b, 0x23, 0x52, 0x1c, 0x60, 0x46, 0xa, 0x7, 0x56, 0x38, 0x72, 0x79, 0x10, 0x1d, 0x52, 0x4a, 0x2f, 0x75, 0x61, 0x16, 0x75, 0x14, 0x5c, 0x41, 0x58, 0x76]  </span><br><span class="line">flag=[]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">  flag.append(enc[i]^key[i])  </span><br><span class="line">  print(chr(flag[i]),end=&#x27;&#x27;)</span><br><span class="line">#flag&#123;b799eb3a-59ee-4b3b-b49d-39080fc23e99&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ko0h"><a href="#ko0h" class="headerlink" title="ko0h"></a>ko0h</h1><p>ida打开附件 发现逻辑是base64换码表 解出来是fakeflag 查看左边函数发现TLS0_0 跟进 有很多常规花指令 从上到下去除 这里我不全部贴出来了 好多花</p>
<p><img src="/../images/Patr1ck-wp-17.png" alt="Patr1ck wp-17"></p>
<p>随后开始分析TLS0_0</p>
<p><img src="/../images/Patr1ck-wp-24.png" alt="Patr1ck wp-24"></p>
<p>第一个函数是检测调试器的函数 如果有ida64 od x32dbg等字样则有调试 跟进下面的函数</p>
<p><img src="/../images/Patr1ck-wp-25.png" alt="Patr1ck wp-25"></p>
<p>发现进行了魔改的RC4加密<br>密文</p>
<p><img src="/../images/Patr1ck-wp-27.png" alt="Patr1ck wp-27"></p>
<p>写了个脚本还是没出 猜测key有问题 交叉引用发现key被替换了</p>
<p><img src="/../images/Patr1ck-wp-26.png" alt="Patr1ck wp-26"></p>
<p>写解密脚本求出flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def ksa(key):  </span><br><span class="line">    S = list(range(256))  </span><br><span class="line">    j = 0  </span><br><span class="line">    key_length = len(key)  </span><br><span class="line">    for i in range(256):  </span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">    return S  </span><br><span class="line">def prga(S, length):  </span><br><span class="line">    i = j = 0  </span><br><span class="line">    keystream = []  </span><br><span class="line">    for _ in range(length):  </span><br><span class="line">        i = (i + 1) % 256  </span><br><span class="line">        j = (j + S[i]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">        keystream.append(S[(S[i] + S[j]) % 256])  </span><br><span class="line">    return keystream  </span><br><span class="line">def rc4(key, plaintext):  </span><br><span class="line">    S = ksa(key)  </span><br><span class="line">    keystream = prga(S, len(plaintext))  </span><br><span class="line">    return bytes([(p + k) % 256 for p, k in zip(plaintext, keystream)])  </span><br><span class="line">key = b&quot;DDDDAAAASSSS&quot;  </span><br><span class="line">ciphertext = [0x18, 0x9C, 0x47, 0x3D, 0x3B, 0xE1, 0x29, 0x27, 0x9F, 0x34, 0x83, 0xD5, 0xED, 0xB5,0x6E, 0x59, 0x7F, 0xDE, 0x47, 0xD7, 0x65, 0x3F, 0x7A, 0x33, 0x5B, 0x64, 0xB6, 0xFA, 0x94, 0x55, 0x87, 0x42, 0x20, 0x6, 0xC, 0x69, 0xFE, 0x72, 0xA9, 0xE4, 0xD1, 0x7C]  </span><br><span class="line">decrypted = rc4(key, ciphertext)  </span><br><span class="line">print(decrypted)</span><br><span class="line">#b&#x27;flag&#123;c58868f2-a62a-584b-b1f4-91b9348a9a22&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="ezgo"><a href="#ezgo" class="headerlink" title="ezgo"></a>ezgo</h1><p>ida打开附件 跟进main_main<br>输入为4位</p>
<p><img src="/../images/Patr1ck-wp-33.png" alt="Patr1ck wp-33"></p>
<p>首先进行了一个base64</p>
<p><img src="/../images/Patr1ck-wp-28.png" alt="Patr1ck wp-28"></p>
<p><img src="/../images/Patr1ck-wp-29.png" alt="Patr1ck wp-29"></p>
<p>跟进可以发现最后对密文^0xC</p>
<p><img src="/../images/Patr1ck-wp-30.png" alt="Patr1ck wp-30"></p>
<p>码表也进行了变换 在main_init_0中</p>
<p><img src="/../images/Patr1ck-wp-35.png" alt="Patr1ck wp-35"></p>
<p>这里我用赛博厨子测试了一下 输入四位的情况下 输出都是8位 最后两位是&#x3D;&#x3D; 所以想解开密文 只需要求出前六位即可<br>随后对密码的几位进行异或</p>
<p><img src="/../images/Patr1ck-wp-31.png" alt="Patr1ck wp-31"></p>
<p>最后通过输入的密码解压压缩包</p>
<p><img src="/../images/Patr1ck-wp-32.png" alt="Patr1ck wp-32"></p>
<p>直接写z3 这里当时比赛的时候我约束条件没有考虑周全 导致z3的解出现了错误 我只考虑了用zip的头去跟给定的zip文件头加约束 没考虑到别的条件 还是在赛后学习别的师傅的wp时候发现了错误 至少需要五个约束才可求出正确的password 解出来的值 对应的下标异或回去 在异或0xC 最后base64换表即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from z3 import *  </span><br><span class="line">  </span><br><span class="line">zip_flag = [0x0E, 0xE1, 0xE5, 0xF9, 0x14]  </span><br><span class="line">zip_head = [0x50, 0x4b, 0x03, 0x04, 0x0C]  </span><br><span class="line">enc = [0x01, 0x57, 0x2C, 0x7C, 0xC7, 0x72, 0x20, 0x70, 0xA5, 0x96, 0x21,  </span><br><span class="line">       0xDC, 0xA8, 0x76, 0x69, 0x14, 0xC5, 0x24, 0x25, 0x02, 0xB7, 0x7A,  </span><br><span class="line">       0xFC, 0xF0, 0xC4, 0x49, 0x56, 0xC2, 0xC1, 0x95, 0xEC, 0x26, 0xCC,  </span><br><span class="line">       0xF7, 0xFF, 0x73, 0xE1, 0x3F, 0x84, 0x46, 0xA9, 0xF9, 0x3D, 0x0E,  </span><br><span class="line">       0x45, 0xF1, 0xDA, 0x92, 0xCE, 0x3B, 0x3C, 0xA0, 0x16, 0xBC, 0x2D,  </span><br><span class="line">       0xBD, 0xA4, 0x32, 0x90, 0x62, 0x9D, 0x0C, 0xDE, 0xAD, 0x40, 0xCF,  </span><br><span class="line">       0x4B, 0x4D, 0x6E, 0x79, 0xC8, 0x85, 0xD2, 0xAC, 0x99, 0xE8, 0x1E,  </span><br><span class="line">       0xC9, 0xD4, 0x06, 0x34, 0x66, 0xB8, 0xD3, 0x13, 0xF4, 0x42, 0x1B,  </span><br><span class="line">       0x63, 0x5F, 0x82, 0x5B, 0x91, 0x2A, 0x33, 0x5D, 0xB9, 0x7D, 0xD5,  </span><br><span class="line">       0x6C, 0x0D, 0x28, 0x08, 0x9B, 0x18, 0x2E, 0xA2, 0x67, 0x5A, 0xE6,  </span><br><span class="line">       0x8A, 0x19, 0x50, 0x9C, 0xB1, 0xEF, 0x1F, 0x12, 0xBA, 0x86, 0x83,  </span><br><span class="line">       0x77, 0x60, 0x94, 0xFD, 0xF6, 0x54, 0xBF, 0xA1, 0x93, 0x03, 0xE7,  </span><br><span class="line">       0x58, 0xE5, 0x9A, 0x7F, 0x22, 0xBE, 0xD9, 0x38, 0x27, 0x65, 0xD7,  </span><br><span class="line">       0x23, 0xFB, 0x71, 0xFA, 0x8F, 0xF5, 0x6D, 0x51, 0x9E, 0xD6, 0x8B,  </span><br><span class="line">       0x89, 0x11, 0xCA, 0x0F, 0x8E, 0xCB, 0xB3, 0xBB, 0xF2, 0x87, 0x75,  </span><br><span class="line">       0x5C, 0x2F, 0x98, 0x2B, 0x1C, 0xB4, 0xC6, 0x0A, 0x4C, 0x36, 0x1A,  </span><br><span class="line">       0x15, 0x88, 0x1D, 0xE4, 0xC3, 0x97, 0x53, 0x30, 0x4A, 0x3A, 0xB5,  </span><br><span class="line">       0x61, 0x55, 0xC0, 0xA7, 0xDB, 0x29, 0x68, 0xE2, 0xE0, 0x10, 0x09,  </span><br><span class="line">       0x41, 0x31, 0xF3, 0xAF, 0xB6, 0x6A, 0x6F, 0x00, 0x05, 0x0B, 0xE3,  </span><br><span class="line">       0xD1, 0x8D, 0x47, 0x74, 0x78, 0x7B, 0x64, 0xDD, 0xAB, 0xB0, 0x39,  </span><br><span class="line">       0x37, 0xFE, 0xED, 0x52, 0xCD, 0x81, 0xF8, 0xAA, 0x48, 0x6B, 0xD0,  </span><br><span class="line">       0xEB, 0x8C, 0x44, 0x59, 0x17, 0x9F, 0x4F, 0xB2, 0x35, 0xA3, 0x7E,  </span><br><span class="line">       0xEE, 0x4E, 0xDF, 0xE9, 0x07, 0x43, 0xA6, 0xAE, 0xD8, 0xEA, 0x80,  </span><br><span class="line">       0x3E, 0x04, 0x5E]  </span><br><span class="line">s = Solver()  </span><br><span class="line">pass1, pass2, pass3, pass4, pass5, pass6 = BitVecs(&quot;pass1 pass2 pass3 pass4 pass5 pass6&quot;, 8)  </span><br><span class="line">enc_byte = Array(&#x27;Bytes&#x27;, BitVecSort(8), BitVecSort(8))  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    s.add(enc_byte[BitVecVal(i, 8)] == enc[i])  </span><br><span class="line">  </span><br><span class="line">s.add(zip_flag[0] == zip_head[0] ^ pass1 ^ pass5 ^ enc_byte[pass1])  </span><br><span class="line">s.add(zip_flag[1] == zip_head[1] ^ pass2 ^ pass6 ^ enc_byte[pass2])  </span><br><span class="line">s.add(zip_flag[2] == zip_head[2] ^ pass3 ^ pass5 ^ enc_byte[pass3])  </span><br><span class="line">s.add(zip_flag[3] == zip_head[3] ^ pass4 ^ pass6 ^ enc_byte[pass4])  </span><br><span class="line">s.add(zip_flag[4] == zip_head[4] ^ pass5 ^ pass5 ^ enc_byte[pass5])  </span><br><span class="line">  </span><br><span class="line">s.add(0xB6 == 0x50 ^ pass3 ^ pass5 ^ enc_byte[pass3])  </span><br><span class="line">s.add(0xB6 == 0x4B ^ pass4 ^ pass6 ^ enc_byte[pass4])  </span><br><span class="line">s.add(0x1D == 0x05 ^ pass5 ^ pass5 ^ enc_byte[pass5])  </span><br><span class="line">s.add(0x9F == 0x06 ^ pass6 ^ pass6 ^ enc_byte[pass6])  </span><br><span class="line">  </span><br><span class="line">s.add((pass1 ^ 2) &gt;= 32)  </span><br><span class="line">s.add((pass1 ^ 2) &lt;= 126)  </span><br><span class="line">s.add(pass2 &gt;= 32)  </span><br><span class="line">s.add((pass2) &lt;= 126)  </span><br><span class="line">s.add((pass3 ^ 2) &gt;= 32)  </span><br><span class="line">s.add((pass3 ^ 2) &lt;= 126)  </span><br><span class="line">s.add((pass4 ^ 5) &gt;= 32)  </span><br><span class="line">s.add((pass4 ^ 5) &lt;= 126)  </span><br><span class="line">s.add((pass5 ^ 5) &gt;= 32)  </span><br><span class="line">s.add((pass5 ^ 5) &lt;= 126)  </span><br><span class="line">s.add((pass6 ^ 2) &gt;= 32)  </span><br><span class="line">s.add((pass6 ^ 2) &lt;= 126)  </span><br><span class="line">  </span><br><span class="line">for password in [pass1, pass2, pass3, pass4, pass5, pass6]:  </span><br><span class="line">    s.add(password &gt;= 32)  </span><br><span class="line">    s.add(password &lt;= 126)  </span><br><span class="line">  </span><br><span class="line">if s.check() == sat:  </span><br><span class="line">    m = s.model()  </span><br><span class="line">    # 提取并输出结果  </span><br><span class="line">    keys = [m[pass1].as_long(), m[pass2].as_long(), m[pass3].as_long(),  </span><br><span class="line">            m[pass4].as_long(), m[pass5].as_long(), m[pass6].as_long()]  </span><br><span class="line">    print(&#x27;, &#x27;.join(map(str, keys)))  </span><br><span class="line">  </span><br><span class="line">password = [108, 62, 65, 98, 104, 74]  </span><br><span class="line">password[0]^=2  </span><br><span class="line">password[2]^=2  </span><br><span class="line">password[3]^=5  </span><br><span class="line">password[4]^=5  </span><br><span class="line">password[5]^=2  </span><br><span class="line">for i in range(6):  </span><br><span class="line">    print(chr(password[i] ^ 0xC), end=&#x27;&#x27;)  </span><br><span class="line">print()  </span><br><span class="line">import base64  </span><br><span class="line">import string  </span><br><span class="line">string = &#x27;b2OkaD==&#x27;  </span><br><span class="line">tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">tableNew =    &quot;TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">password = base64.b64decode(string.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">print (password)</span><br><span class="line">#b&#x27;oadi&#x27;</span><br></pre></td></tr></table></figure>

<p>得到密码 输入进去就能打开zip压缩包 打开txt文件就有flag</p>
<p><img src="/../images/Patr1ck-wp-34.png" alt="Patr1ck wp-34"></p>
]]></content>
  </entry>
  <entry>
    <title>2024 春秋杯冬季赛 DAY3 RE wp</title>
    <url>/2025/01/23/2024-%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B-DAY3-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：先把day3的题复现了一下 由于vm是弱项 所以day3剩的vm打算后续跟day2的re还有day1的vm一起做复现 后续会加到wp里</strong></p>
<h1 id="easyasm"><a href="#easyasm" class="headerlink" title="easyasm"></a>easyasm</h1><p>ida打开附件 根据题目也可以知道是要看汇编的题 </p>
<span id="more"></span>

<p>汇编开头给了两个数据</p>
<p><img src="/../images/Patr1ck-day3-wp-6.png" alt="Patr1ck-day3-wp-6"></p>
<p><img src="/../images/Patr1ck-day3-wp-7.png" alt="Patr1ck-day3-wp-7"></p>
<p>猜测一个密文一个密钥<br>首先对key进行了一个冒泡排序 两个字节一排 提取出来key<br><code>0x2030, 0x3040, 0x4050, 0x1022, 0x2011, 0x1666, 0x1522, 0x8899,   0x4155, 0x4044, 0x4288, 0x3321, 0x6033, 0xFFFF, 0x2221, 0x3366,  0x222C, 0x2CCC, 0x22CC, 0xCC22, 0xC2C2</code><br>随后继续往下看 发现一个 xor</p>
<p><img src="/../images/Patr1ck-day3-wp-8.png" alt="Patr1ck-day3-wp-8"></p>
<p>以大概的逻辑就是密文跟排序后的密钥异或 这里我写了一个脚本验证了一下 用密文的前五位异或一下flag{ 发现结果跟排序后的密钥一致</p>
<p><img src="/../images/Patr1ck-day3-wp-9.png" alt="Patr1ck-day3-wp-9"></p>
<p>直接写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag = &#x27;flag&#123;&#x27;  </span><br><span class="line">enc = [0x44, 0x7C, 0x43, 0x72, 0x1D, 0x72, 0x74, 0x41, 0x05, 0x14,  </span><br><span class="line">       0x19, 0x1A, 0x19, 0x0F, 0xF5, 0x10, 0xAE, 0x18, 0x6D, 0x01,  </span><br><span class="line">       0x10, 0x56, 0x00, 0x1E, 0x26, 0x71, 0x65, 0x73, 0x78, 0x72,  </span><br><span class="line">       0xEB, 0x72, 0x52, 0x06, 0xAA, 0xBB, 0xA3, 0xA4, 0x1B, 0xFC]  </span><br><span class="line">#for i in range(5):  </span><br><span class="line">    #print(hex(enc[i] ^ ord(flag[i])),end=&#x27;,&#x27;)</span><br><span class="line">#print()  </span><br><span class="line">word_10200 = [0x2030, 0x3040, 0x4050, 0x1022, 0x2011, 0x1666, 0x1522,  0x8899, 0x4155, 0x4044, 0x4288, 0x3321, 0x6033, 0xFFFF, 0x2221, 0x3366, 0x222C, 0x2CCC, 0x22CC, 0xCC22, 0xC2C2]  </span><br><span class="line">for i in range(len(word_10200)):  </span><br><span class="line">    for j in range(len(word_10200) - 1 - i):  </span><br><span class="line">        if word_10200[j] &gt; word_10200[j + 1]:  </span><br><span class="line">            word_10200[j], word_10200[j + 1] = word_10200[j + 1], word_10200[j]  </span><br><span class="line">key = []  </span><br><span class="line">for num in word_10200:  </span><br><span class="line">    low = num &amp; 0xFF  </span><br><span class="line">    high = (num &gt;&gt; 8) &amp; 0xFF  </span><br><span class="line">    key.append(low)  </span><br><span class="line">    key.append(high)  </span><br><span class="line">#print(&#x27;,&#x27;.join(hex(x) for x in key))  </span><br><span class="line">enc = [0x44, 0x7C, 0x43, 0x72, 0x1D, 0x72, 0x74, 0x41, 0x05, 0x14,  </span><br><span class="line">       0x19, 0x1A, 0x19, 0x0F, 0xF5, 0x10, 0xAE, 0x18, 0x6D, 0x01,  </span><br><span class="line">       0x10, 0x56, 0x00, 0x1E, 0x26, 0x71, 0x65, 0x73, 0x78, 0x72,  </span><br><span class="line">       0xEB, 0x72, 0x52, 0x06, 0xAA, 0xBB, 0xA3, 0xA4, 0x1B, 0xFC,  </span><br><span class="line">       0xC7, 0x82]  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    flag.append(enc[i] ^ key[i])  </span><br><span class="line">    print(chr(flag[i]), end=&#x27;&#x27;)</span><br><span class="line">#flag&#123;dea54885-92b4-11ef-b153-3c0af33af908&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ooooore"><a href="#ooooore" class="headerlink" title="ooooore"></a>ooooore</h1><p>ida打开附件 全是花指令 一点一点去掉 后来看大佬的wp 发现用010批量去除能更快一点 </p>
<p><img src="/../images/Patr1ck-day3-wp-10.png" alt="Patr1ck-day3-wp-10"></p>
<p>直接在010里全部替换为90 打开就能正确的反编译<br>密文和输入</p>
<p><img src="/../images/Patr1ck-day3-wp-11.png" alt="Patr1ck-day3-wp-11"></p>
<p>交叉引用密文就可以找到最后比较的部分</p>
<p><img src="/../images/Patr1ck-day3-wp-12.png" alt="Patr1ck-day3-wp-12"></p>
<p>随后看字符串时候发现一个RC4的字符</p>
<p><img src="/../images/Patr1ck-day3-wp-13.png" alt="Patr1ck-day3-wp-13"></p>
<p>所以直接在比较的地方打个断点 找加密后的密文 写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;1&quot;*42)  </span><br><span class="line">get=[  0xD6, 0xB0, 0x2E, 0x79, 0xD9, 0xE6, 0x67, 0x8B, 0x13, 0xB7,  </span><br><span class="line">  0x9A, 0x43, 0xFE, 0xE8, 0x29, 0xDD, 0xF8, 0x9E, 0x59, 0x63,  </span><br><span class="line">  0xFC, 0x88, 0xAD, 0x7D, 0x78, 0x61, 0x32, 0x87, 0x9C, 0xD1,  </span><br><span class="line">  0x11, 0xF8, 0x26, 0x6A, 0x91, 0x51, 0x85, 0x52, 0xB5, 0x15,  </span><br><span class="line">  0x82, 0xD1]  </span><br><span class="line">enc=[0x81, 0xED, 0x7E, 0x2F, 0x93, 0xB6, 0x6F, 0x8D, 0x43, 0xE5, 0xC9, 0x11, 0xA9, 0xF4, 0x2B, 0xDB, 0xAD, 0xCB, 0x45, 0x66, 0xFA, 0xDF, 0xA9, 0x61, 0x28, 0x65, 0x31, 0xD7, 0x80, 0xD5, 0x18, 0xFE, 0x25, 0x6E, 0x94, 0x05, 0x83, 0x51, 0xB5, 0x42, 0xD2, 0x9D]  </span><br><span class="line">keystream=[(ord(&quot;1&quot;)^i)&amp;0xff for i in get]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    enc[i]^=keystream[i]  </span><br><span class="line">    enc[i]&amp;=0xff  </span><br><span class="line">print(&quot;&quot;.join(map(chr,enc)))</span><br><span class="line">#flag&#123;a97acbcf-37dd-47f5-a52a-587254e721fa&#125;</span><br></pre></td></tr></table></figure>

<p>赛后看wp的时候 发现是rc4加chacha20 当时没考虑那么多 直接就异或回去了 算是个非预期吧</p>
<h1 id="和谐（复现）"><a href="#和谐（复现）" class="headerlink" title="和谐（复现）"></a>和谐（复现）</h1><p>第一次做鸿蒙的逆向 比赛的时候没找到合适的工具 导致一直没什么思路<br>看完官方wp后 发现使用的工具是<a href="https://github.com/ohos-decompiler/abc-decompiler/releases">https://github.com/ohos-decompiler/abc-decompiler/releases</a></p>
<p>打开附件<br>sm4算法 对着源码看 可以看出 修改了密钥拓展的部分</p>
<p><img src="/../images/Patr1ck-day3-wp-15.png" alt="Patr1ck-day3-wp-15"></p>
<p>写脚本解密即可 脚本我直接参考的官方的wp了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">  </span><br><span class="line">typedef unsigned long ull;  </span><br><span class="line">typedef unsigned int uint;  </span><br><span class="line">typedef unsigned char uchar;  </span><br><span class="line">  </span><br><span class="line">static const uchar Sbox[16][16] = &#123;  </span><br><span class="line">    &#123;0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05&#125;,  </span><br><span class="line">    &#123;0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99&#125;,  </span><br><span class="line">    &#123;0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62&#125;,  </span><br><span class="line">    &#123;0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6&#125;,  </span><br><span class="line">    &#123;0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8&#125;,  </span><br><span class="line">    &#123;0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35&#125;,  </span><br><span class="line">    &#123;0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87&#125;,  </span><br><span class="line">    &#123;0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e&#125;,  </span><br><span class="line">    &#123;0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1&#125;,  </span><br><span class="line">    &#123;0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3&#125;,  </span><br><span class="line">    &#123;0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f&#125;,  </span><br><span class="line">    &#123;0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51&#125;,  </span><br><span class="line">    &#123;0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8&#125;,  </span><br><span class="line">    &#123;0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0&#125;,  </span><br><span class="line">    &#123;0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84&#125;,  </span><br><span class="line">    &#123;0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">ull leftShift(ull x, int n) &#123;  </span><br><span class="line">    return (x &lt;&lt; n) | (x &gt;&gt; (32 - n));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ull chr2int(uchar *chr) &#123;  </span><br><span class="line">    return (chr[0] &lt;&lt; 24) | (chr[1] &lt;&lt; 16) | (chr[2] &lt;&lt; 8) | chr[3];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void int2chr(uchar *chr, ull x) &#123;  </span><br><span class="line">    chr[0] = (x &gt;&gt; 24) &amp; 0xff;  </span><br><span class="line">    chr[1] = (x &gt;&gt; 16) &amp; 0xff;  </span><br><span class="line">    chr[2] = (x &gt;&gt; 8) &amp; 0xff;  </span><br><span class="line">    chr[3] = x &amp; 0xff;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">uint transSboxInt(uint temp)  </span><br><span class="line">&#123;  </span><br><span class="line"> return Sbox[temp&gt;&gt;4][temp&amp;0xf];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">uint transSbox(uint temp) &#123;  </span><br><span class="line">    uint output = 0;  </span><br><span class="line">    for (int i = 3; i &gt; -1; i--) &#123;  </span><br><span class="line">        output = output &lt;&lt; 8;  </span><br><span class="line">        output = output | transSboxInt((temp &gt;&gt; (i * 8)) &amp; 0xff);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return output;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">uint keyTrans(uint temp) &#123;  </span><br><span class="line">    return temp ^ leftShift(temp, 13) ^ leftShift(temp, 23);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">uint trans(uint temp) &#123;  </span><br><span class="line">    temp = transSbox(temp);  </span><br><span class="line">    return temp ^ leftShift(temp, 2) ^ leftShift(temp, 10) ^ leftShift(temp, 18) ^ leftShift(temp, 24);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void keyExtention_new(uchar K[32], uint RK[32]) &#123;  </span><br><span class="line">    uint tk[36];  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        tk[i] = chr2int(K + 4 * i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; 32; i++) &#123;  </span><br><span class="line">        tk[i + 4] = tk[i + 1] ^ tk[i + 2] ^ tk[i + 3];  </span><br><span class="line">        tk[i + 4] = transSbox(tk[i + 4]);  </span><br><span class="line">        tk[i + 4] = keyTrans(tk[i + 4]);  </span><br><span class="line">        tk[i + 4] = tk[i] ^ tk[i + 4];  </span><br><span class="line">        RK[i] = tk[i + 4];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void sm4_encrypt_new(uchar *input, uchar *output, uchar *K) &#123;  </span><br><span class="line">    uint RK[32];  </span><br><span class="line">    keyExtention_new(K, RK);  </span><br><span class="line">    uint X[36];  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        X[i] = chr2int(input + 4 * i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; 32; i++) &#123;  </span><br><span class="line">        X[i + 4] = X[i + 1] ^ X[i + 2] ^ X[i + 3] ^ RK[i];  </span><br><span class="line">        X[i + 4] = trans(X[i + 4]);  </span><br><span class="line">        X[i + 4] = X[i] ^ X[i + 4];  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        output[4 * i] = (X[35 - i] &gt;&gt; 24) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 1] = (X[35 - i] &gt;&gt; 16) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 2] = (X[35 - i] &gt;&gt; 8) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 3] = X[35 - i] &amp; 0xff;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void sm4_decrypt_new(uchar *input, uchar *output, uchar *K) &#123;  </span><br><span class="line">    uint RK[32];  </span><br><span class="line">    keyExtention_new(K, RK);  </span><br><span class="line">    uint X[36];  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        X[35 - i] = chr2int(input + 4 * i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 31; i &gt;= 0; i--) &#123;  </span><br><span class="line">        X[i] = X[i + 1] ^ X[i + 2] ^ X[i + 3] ^ RK[i];  </span><br><span class="line">        X[i] = trans(X[i]);  </span><br><span class="line">        X[i] = X[i + 4] ^ X[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        output[4 * i] = (X[i] &gt;&gt; 24) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 1] = (X[i] &gt;&gt; 16) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 2] = (X[i] &gt;&gt; 8) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 3] = X[i] &amp; 0xff;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    uchar key[16] = &#123;0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05&#125;;  </span><br><span class="line">    uchar output[48] = &#123;  </span><br><span class="line">        24, 138, 76, 64, 151, 159, 65, 33, 3, 90, 97, 15, 62, 105, 82, 235,  </span><br><span class="line">        77, 240, 241, 90, 84, 179, 185, 34, 158, 119, 185, 189, 120, 106, 13, 138,  </span><br><span class="line">        17, 68, 255, 127, 234, 11, 218, 151, 82, 97, 25, 170, 100, 201, 253, 150,  </span><br><span class="line">    &#125;;  </span><br><span class="line">    uchar input[48] = &#123;0&#125;;  </span><br><span class="line">    for (int i = 0; i &lt; 48; i++) &#123;  </span><br><span class="line">        output[i] = Sbox[output[i] / 16][output[i] % 16];  </span><br><span class="line">    &#125;  </span><br><span class="line">    uchar output2[48] = &#123;0&#125;;  </span><br><span class="line">    for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        sm4_decrypt_new(output + j * 16, output2 + j * 16, key);  </span><br><span class="line">        for (int i = 0; i &lt; 16; i++) &#123;  </span><br><span class="line">            printf(&quot;%c&quot;, output2[j * 16 + i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;n&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
