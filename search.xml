<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024 ciscn&amp;ccb RE wp</title>
    <url>/2024/12/20/2024-ciscn-ccb-Re-wp/</url>
    <content><![CDATA[<h1 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h1><p>运行程序 输入几个字符 观察回显</p>
<p><img src="/../images/image1-1734689935552-1.png" alt="image1"></p>
<p>随后看了一下flag头的映射</p>
<span id="more"></span>

<p><img src="/../images/image2-1734689953905-3.png" alt="image2"></p>
<p>跟flag的前几位一样</p>
<p><img src="/../images/image3-1734689962295-5.png" alt="image3"></p>
<p>发现是单字节加密 所以将所有的可打印字符输入进去dump一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import string  </span><br><span class="line">all_char = string.printable  </span><br><span class="line">print(all_char)</span><br><span class="line">#0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~ 	</span><br></pre></td></tr></table></figure>
<p>得到映射表<br><img src="/../images/image4-1734689969850-7.png" alt="image4"></p>
<p>001c1d000000000000001e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b00000000000000000000000000000000000100000000000000000038003900</p>
<p>随后将flag一一映射过去即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import string  </span><br><span class="line">all_char = string.printable  </span><br><span class="line">#print(all_char)  </span><br><span class="line">table = list(bytes.fromhex(&quot;001c1d000000000000001e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b000000000000000000000000000000000100000000000000000038003900&quot;))  </span><br><span class="line">flag = list(bytes.fromhex(&quot;23 29 1E 24 38 0E 15 20 37 0E 05 20 00 0E 37 12 1D 0F 24 01 01 39&quot;))  </span><br><span class="line">for x in flag:  </span><br><span class="line">    if x in table:  </span><br><span class="line">        print(all_char[table.index(x)], end=&quot;&quot;)</span><br><span class="line">#flag_MTczMDc0MzQ2Ng;;&#123;</span><br></pre></td></tr></table></figure>
<p>手动修改一下flag 结合提示第十四位是4 直接改一下即可<br> flag{MTczMDc4MzQ2Ng=&#x3D;}</p>
<h1 id="ezCsky"><a href="#ezCsky" class="headerlink" title="ezCsky"></a>ezCsky</h1><p>ida打开附件 得选择arm去分析 这里走了好多弯 </p>
<p>发现有RC4 猜测rc4加密 找key和密文</p>
<p><img src="/../images/image5-1734689976784-9.png" alt="image5"></p>
<p>找到key 跟进unk_8AA0</p>
<p><img src="/../images/image6-1734689981410-11.png" alt="image6"></p>
<p>找到密文</p>
<p><img src="/../images/image7-1734689987048-13.png" alt="image7"></p>
<p>直接解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import ARC4  </span><br><span class="line">encrypt_data= [0x96, 0x8F, 0xB8, 0x08, 0x5D, 0xA7, 0x68, 0x44, 0xF2, 0x64,  </span><br><span class="line">  0x92, 0x64, 0x42, 0x7A, 0x78, 0xE6, 0xEA, 0xC2, 0x78, 0xB8,  </span><br><span class="line">  0x63, 0x9E, 0x5B, 0x3D, 0xD9, 0x28, 0x3F, 0xC8, 0x73, 0x06,  </span><br><span class="line">  0xEE, 0x6B, 0x8D, 0x0C, 0x4B, 0xA3, 0x23, 0xAE, 0xCA, 0x40,  </span><br><span class="line">  0xED, 0xD1] # 加密key  </span><br><span class="line">key = b&#x27;testkey&#x27;     # 加密方法  </span><br><span class="line">key1=ARC4.new(key)  </span><br><span class="line">print(key1.encrypt(bytes(encrypt_data)))         # 解密方法</span><br><span class="line">#b&#x27;\n\r\x06\x1c\x1fTVSWQ\x00\x03\x1d\x14XV\x03\x19\x1c\x00T\x03K\x14X\x07\x02IL\x02\x07\x01Q\x0c\x08\x00\x01\x00\x03\x00O&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>最后一位是} 前面的都不对 结合左边的符号表有xor函数</p>
<p><img src="/../images/image8-1734689992869-15.png" alt="image8"></p>
<p>猜测进行了异或 但是最后一位没有异或 所以猜测加密的异或可能是<br>flag[i]^&#x3D;flag[i+1]<br>直接写逆向脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import ARC4  </span><br><span class="line">encrypt_data= [0x96, 0x8F, 0xB8, 0x08, 0x5D, 0xA7, 0x68, 0x44, 0xF2, 0x64,  </span><br><span class="line">  0x92, 0x64, 0x42, 0x7A, 0x78, 0xE6, 0xEA, 0xC2, 0x78, 0xB8,  </span><br><span class="line">  0x63, 0x9E, 0x5B, 0x3D, 0xD9, 0x28, 0x3F, 0xC8, 0x73, 0x06,  </span><br><span class="line">  0xEE, 0x6B, 0x8D, 0x0C, 0x4B, 0xA3, 0x23, 0xAE, 0xCA, 0x40,  </span><br><span class="line">  0xED, 0xD1] # 加密key  </span><br><span class="line">key = b&#x27;testkey&#x27;     # 加密方法  </span><br><span class="line">key1=ARC4.new(key)  </span><br><span class="line">print(key1.encrypt(bytes(encrypt_data)))         # 解密方法  </span><br><span class="line">flag = b&#x27;\n\r\x06\x1c\x1fTVSWQ\x00\x03\x1d\x14XV\x03\x19\x1c\x00T\x03K\x14X\x07\x02IL\x02\x07\x01Q\x0c\x08\x00\x01\x00\x03\x00O&#125;&#x27;  </span><br><span class="line"># 将 flag 转换为 list，便于修改  </span><br><span class="line">flag = list(flag)  </span><br><span class="line">for i in range(len(flag)-1,0,-1):  </span><br><span class="line">    flag[i-1] ^= flag[i]  </span><br><span class="line">    print(chr(flag[i]),end=&#x27;&#x27;)  </span><br><span class="line">chr_flag=&#x27;&#125;22110084edca-dfa9-fe11-47a9-033b5f0d&#123;gal&#x27;  </span><br><span class="line">print(chr_flag[::-1])</span><br><span class="line">#lag&#123;d0f5b330-9a74-11ef-9afd-acde48001122&#125;</span><br></pre></td></tr></table></figure>
<p>少了个f 在前面加上就是正确的flag</p>
]]></content>
  </entry>
  <entry>
    <title>2024领航杯本科组 RE wp</title>
    <url>/2025/01/02/2024%E9%A2%86%E8%88%AA%E6%9D%AF-%E6%9C%AC%E7%A7%91%E7%BB%84Re-wp/</url>
    <content><![CDATA[<h1 id="ezsystd"><a href="#ezsystd" class="headerlink" title="ezsystd"></a>ezsystd</h1><p>jadx打开文件 找到主函数</p>
<span id="more"></span>

<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd.png" alt="本科组 easystd-1"></p>
<p>分析 主要的判断在check</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-1.png" alt="本科组 easystd-1"></p>
<p>调用本地native 所以分析native层 ida打开libcma.so 进入sub_904函数 发现一个类似sbox的数组</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-6.png" alt="本科组 easystd-6"></p>
<p>跟7异或 跑一下异或之后的sbox</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [ 0xD1, 0x97, 0xEE, 0xF9, 0xCB, 0xE6, 0x3A, 0xB0, 0x11, 0xB1]  </span><br><span class="line">for i in range(len(a)):  </span><br><span class="line">    a[i]^=7  </span><br><span class="line">    print(hex(a[i]),end=&#x27; &#x27;)</span><br><span class="line">#0xd6 0x90 0xe9 0xfe 0xcc 0xe1 0x3d 0xb7 0x16 0xb6</span><br></pre></td></tr></table></figure>

<p>发现是sm4的sbox 而且轮数也是32轮 所以猜测是sm4加密 找密文和密钥<br>跟进sub_75C函数 在最下面找到密文byte_C14</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-5.png" alt="本科组 easystd-5"></p>
<p>密钥在这个地方</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-7.png" alt="本科组 easystd-7"></p>
<p>跟进之后可以发现是将后八位替换为0x5A30303939383634</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-8.png" alt="本科组 easystd-8"></p>
<p>注意是小端序存储 所以密钥应该是A11223574689900Z 扔赛博厨子里跑一下</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-9.png" alt="本科组 easystd-9"></p>
<p>得到flag</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-10.png" alt="本科组 easystd-10"></p>
]]></content>
  </entry>
  <entry>
    <title>DASCTF 2024最后一战 RE wp</title>
    <url>/2024/12/24/DASCTF-2024%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98-RE/</url>
    <content><![CDATA[<p>期末周 要做课设 还要复习考试  所以今天才复现整理完wp</p>
<h2 id="tryre"><a href="#tryre" class="headerlink" title="tryre"></a>tryre</h2><p>真正的签到题！ida打开附件 发现密文和更换的base64码表</p>
<span id="more"></span>

<p><img src="/../images/img_dasctf1.png" alt="img_dasctf1"></p>
<p>随后继续看发现异或2</p>
<p><img src="/../images/img_das2.png" alt="img_das2"></p>
<p>所以解密就是异或2然后换码表解码 直接写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc=&#x27;M@ASL3MF`uL3ICT2IhUgKSD2IeDsICH7Hd26HhQgKSQhNCX7TVL3UFMeHi2?&#x27;  </span><br><span class="line">flag=[]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    flag.append(ord(enc[i])^2)  </span><br><span class="line">    print(chr(flag[i]),end=&#x27;&#x27;)  </span><br><span class="line">print()  </span><br><span class="line">import base64  </span><br><span class="line">import string  </span><br><span class="line">string = &quot;OBCQN1ODbwN1KAV0KjWeIQF0KgFqKAJ5Jf04JjSeIQSjLAZ5VTN1WDOgJk0=&quot;  </span><br><span class="line">tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">tableNew =    &quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;  </span><br><span class="line">flag = base64.b64decode(string.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">print (flag)</span><br><span class="line">b&#x27;DASCTF&#123;454646fa-2462-4392-82ea-5f809ad5ddc2&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="黑客不许哭"><a href="#黑客不许哭" class="headerlink" title="黑客不许哭"></a>黑客不许哭</h2><p>ida打开附件 交叉引用一下输入的值 </p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp.png" alt="黑客不许哭wp"></p>
<p>发现是对输入进行了*1.020123456789<br>往下翻找到比较的地方</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-1.png" alt="黑客不许哭wp-1"></p>
<p>最终比较的数据很大 猜测是对输入进行了乘法操作</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-2.png" alt="黑客不许哭wp-2"></p>
<p>写个脚本解一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qword_7FF64E34A170 = [  </span><br><span class="line">    4358.58716, 6122.2983, 2158.74574, 5973.017537, 9173.840881,  </span><br><span class="line">    6164.67827, 12293.528276, 4091.327439, 3360.696562, 2403.667017,  </span><br><span class="line">    3199.455077, 4962.117508, 8266.407604, 2863.062918, 1044.626306,  </span><br><span class="line">    1067.5308730000002, 3217.476319, 6260.942959, 3278.952568, 160.724197,  </span><br><span class="line">    596.797742, 3277.973032, 6368.757598, 842.858109, 5925.142209,  </span><br><span class="line">    3046.937162, 12752.384458, 2442.54747, 1827.164764, 4903.961921,  </span><br><span class="line">    5619.869598, 3851.247916, 4472.987644, 13135.636855, 1640.630636,  </span><br><span class="line">    975.429551, 2174.379531, 2289.845471, 2605.707441, 1488.586824,  </span><br><span class="line">    12216.019619, 4588.270425, 4803.36317, 13035.30263  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A010 = [  </span><br><span class="line">    60.51846366284686, 89.4737043286176, 24.031047113523933, 84.68873702464015,  </span><br><span class="line">    104.66953644646323, 83.75627693648984, 96.41044018110416, 75.27071882034213,  </span><br><span class="line">    60.33140727998576, 46.10475987767577, 56.28563000222285, 86.68936481373537,  </span><br><span class="line">    80.87786332435297, 55.29894355978243, 9.261748448423328, 20.6272127322797,  </span><br><span class="line">    31.189741971747896, 116.18656005122571, 30.859918262868042, 1.0633446004217317,  </span><br><span class="line">    10.591447767777225, 55.64965261721374, 122.95044769452201, 7.140637105592679,  </span><br><span class="line">    55.44977106531295, 62.827038867512506, 125.30574894504994, 45.94487116254584,  </span><br><span class="line">    32.57185367060958, 92.37291765689986, 117.68050783530462, 63.422414786033976,  </span><br><span class="line">    84.08593452538155, 125.30354189600813, 26.504600725852114, 15.6085145259943,  </span><br><span class="line">    35.687075116213585, 37.67352051379848, 24.32434117146088, 25.692484908155073,  </span><br><span class="line">    116.46382825728031, 86.30264794289376, 79.51984419851664, 100.65174601005425  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A000 = 1.020123456789  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(44):  </span><br><span class="line">    value = (((qword_7FF64E34A170[i]) / qword_7FF64E34A000)-1) / qword_7FF64E34A010[i]  </span><br><span class="line">    flag.append(chr(int(value)))  </span><br><span class="line">print(&quot;&quot;.join(flag))</span><br><span class="line">#FCXEUH|56378d2n2e4h792sh/c464.;4f&lt;=;;h8f4;~</span><br></pre></td></tr></table></figure>

<p>解不开 但是已知flag头是DASCTF 直接测试一下 发现和最终的结果差了100左右</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-3.png" alt="黑客不许哭wp-3"></p>
<p>修改一下脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">test1 = (((ord(&quot;D&quot;)) * 1.020123456789) + 1) * 60.51846366284686  </span><br><span class="line">print(test1)  </span><br><span class="line">test2 = (((ord(&quot;A&quot;)) * 1.020123456789)+ 1) * 89.4737043286176  </span><br><span class="line">print(test2)  </span><br><span class="line">test3 = (((ord(&quot;S&quot;)) * 1.020123456789)+ 1) * 24.031047113523933  </span><br><span class="line">print(test3)  </span><br><span class="line">  </span><br><span class="line">qword_7FF64E34A170 = [  </span><br><span class="line">    4358.58716, 6122.2983, 2158.74574, 5973.017537, 9173.840881,  </span><br><span class="line">    6164.67827, 12293.528276, 4091.327439, 3360.696562, 2403.667017,  </span><br><span class="line">    3199.455077, 4962.117508, 8266.407604, 2863.062918, 1044.626306,  </span><br><span class="line">    1067.5308730000002, 3217.476319, 6260.942959, 3278.952568, 160.724197,  </span><br><span class="line">    596.797742, 3277.973032, 6368.757598, 842.858109, 5925.142209,  </span><br><span class="line">    3046.937162, 12752.384458, 2442.54747, 1827.164764, 4903.961921,  </span><br><span class="line">    5619.869598, 3851.247916, 4472.987644, 13135.636855, 1640.630636,  </span><br><span class="line">    975.429551, 2174.379531, 2289.845471, 2605.707441, 1488.586824,  </span><br><span class="line">    12216.019619, 4588.270425, 4803.36317, 13035.30263  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A010 = [  </span><br><span class="line">    60.51846366284686, 89.4737043286176, 24.031047113523933, 84.68873702464015,  </span><br><span class="line">    104.66953644646323, 83.75627693648984, 96.41044018110416, 75.27071882034213,  </span><br><span class="line">    60.33140727998576, 46.10475987767577, 56.28563000222285, 86.68936481373537,  </span><br><span class="line">    80.87786332435297, 55.29894355978243, 9.261748448423328, 20.6272127322797,  </span><br><span class="line">    31.189741971747896, 116.18656005122571, 30.859918262868042, 1.0633446004217317,  </span><br><span class="line">    10.591447767777225, 55.64965261721374, 122.95044769452201, 7.140637105592679,  </span><br><span class="line">    55.44977106531295, 62.827038867512506, 125.30574894504994, 45.94487116254584,  </span><br><span class="line">    32.57185367060958, 92.37291765689986, 117.68050783530462, 63.422414786033976,  </span><br><span class="line">    84.08593452538155, 125.30354189600813, 26.504600725852114, 15.6085145259943,  </span><br><span class="line">    35.687075116213585, 37.67352051379848, 24.32434117146088, 25.692484908155073,  </span><br><span class="line">    116.46382825728031, 86.30264794289376, 79.51984419851664, 100.65174601005425  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A000 = 1.020123456789  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(44):  </span><br><span class="line">    value = (((qword_7FF64E34A170[i]) / qword_7FF64E34A000)-1) / qword_7FF64E34A010[i]  </span><br><span class="line">    flag.append(chr(int(value)))  </span><br><span class="line">print(&quot;&quot;.join(flag))</span><br><span class="line">#DASCTF&#123;34056b0c-a3d7-71ef-b132-92e8688d4e29&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h2 id="刻板印象"><a href="#刻板印象" class="headerlink" title="刻板印象"></a>刻板印象</h2><p>ida打开附件 乍一看逻辑很简单 只有一个异或</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1.png" alt="刻板印象"></p>
<p>写脚本解一下 发现是fake的flag </p>
<p>This_is_clearly_a_fake_flag_so_try_to_find_more.</p>
<p>随后看一下汇编 发现有花 nop掉重新f5即可恢复原本的函数</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-1.png" alt="刻板印象-1"></p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-2.png" alt="刻板印象-2"></p>
<p>发现是一个xtea＋异或 写个脚本解一下 还是fakeflag</p>
<p>fakeflag_plz_Try_more_hard_to_find_the_true_flag</p>
<p>于是打算看看函数 发现了一个tls没有用到 起调试跑一下 发现从xtea出来进入了一个新的函数 那个新函数刚好是tls函数中的</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-3.png" alt="刻板印象-3"></p>
<p>单步运行到最后 发现跳转到一个新的地址 有很多一段一段的汇编</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-4.png" alt="刻板印象-4"></p>
<p>运行一会 问了一下gpt 大概是xxtea<br>发现密钥{What_is_this_?} delta是0x11451419</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-6.png" alt="刻板印象-6"></p>
<p>跑到最后还有一个xor 提取一下 所以总体逻辑就是 xor xtea xor xxtea xor<br>写逆向脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define MX (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z)))</span><br><span class="line">typedef unsigned char BYTE;</span><br><span class="line">unsigned char aLaughterIsPois[] = &quot;Laughter_is_poison_to_fear&quot;;</span><br><span class="line">unsigned char xor_xtea_num[48] = &#123;0xDA, 0x30, 0x23, 0xE3, 0xDC, 0x39, 0x82, 0x60, 0xA5, 0x44,</span><br><span class="line">                                  0x68, 0xC2, 0x43, 0x7A, 0xBB, 0xE4, 0x50, 0xE1, 0x02, 0xC2,</span><br><span class="line">                                  0x81, 0x59, 0xEA, 0x1E, 0xC6, 0x8B, 0x71, 0x38, 0x27, 0x83,</span><br><span class="line">                                  0x94, 0xD8, 0xF4, 0x8D, 0x1A, 0x2A, 0x56, 0x8A, 0x4A, 0xD4,</span><br><span class="line">                                  0x54, 0xDC, 0x24, 0x3F, 0xB9, 0xED, 0x7B, 0x9A&#125;;</span><br><span class="line">unsigned char xor_xxtea_num[48] = &#123;0x8f, 0x6c, 0xa6, 0x3f, 0x94, 0x3d, 0xf5, 0xd9, 0x36, 0x66, 0x51, 0xd7, 0x66,</span><br><span class="line">                                   0x2f, 0xb3, 0x8f, 0xc0, 0x61, 0x9e, 0xce, 0xe9, 0xd7, 0xe1, 0xbf, 0x13, 0x14,</span><br><span class="line">                                   0x16, 0x14, 0xc2, 0xe7, 0xc3, 0x3a, 0x7f, 0x94, 0xa1, 0xe7, 0x24, 0x0e, 0xa7,</span><br><span class="line">                                   0x5c, 0xd3, 0x77, 0xfe, 0x4f, 0x11, 0xdc, 0x69, 0x23&#125;;</span><br><span class="line">void xtea_decrypt(unsigned char *data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= xor_xtea_num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned int *v = (unsigned int *)data;</span><br><span class="line">    unsigned char key_xtea[] = &quot;&#123;you_find_it_!?&#125;&quot;;</span><br><span class="line">    unsigned int *v8 = (unsigned int *)key_xtea;</span><br><span class="line">    for (int l = 0; l &lt; 12; l += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned int v6 = v[l], v5 = v[l + 1], v4 = 0;</span><br><span class="line">        unsigned int delta = 0x61C88647;</span><br><span class="line">        v4 = -1 * 32 * delta;</span><br><span class="line">        for (int i = 0; i &lt; 32; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v5 -= (v8[(v4 &gt;&gt; 11) &amp; 3] + v4) ^ (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6);</span><br><span class="line">            v4 += delta;</span><br><span class="line">            v6 -= (v8[v4 &amp; 3] + v4) ^ (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5);</span><br><span class="line">        &#125;</span><br><span class="line">        v[l] = v6;</span><br><span class="line">        v[l + 1] = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= aLaughterIsPois[i % 26];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void xxtea_decrypt(uint8_t *data)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= xor_xxtea_num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int n = -12;</span><br><span class="line">    uint32_t *v = (uint32_t *)data;</span><br><span class="line">    unsigned char *key_xxtea = &quot;&#123;What_is_this_?&#125;&quot;;</span><br><span class="line">    uint32_t *key = (unsigned int *)key_xxtea;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    unsigned int delta = 0x11451419;</span><br><span class="line">    if (n &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52 / n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n - 1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += delta;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p = 0; p &lt; n - 1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p + 1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n - 1] += MX;</span><br><span class="line">        &#125; while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52 / n;</span><br><span class="line">        sum = rounds * delta;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p = n - 1; p &gt; 0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p - 1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n - 1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= delta;</span><br><span class="line">        &#125; while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char data[48] = &#123;0x18, 0x09, 0x1C, 0x14, 0x37, 0x1D, 0x16, 0x2D, 0x3C, 0x05,</span><br><span class="line">                              0x16, 0x3E, 0x02, 0x03, 0x10, 0x2C, 0x0E, 0x31, 0x39, 0x15,</span><br><span class="line">                              0x04, 0x3A, 0x39, 0x03, 0x0D, 0x13, 0x2B, 0x3E, 0x06, 0x08,</span><br><span class="line">                              0x37, 0x00, 0x17, 0x0B, 0x00, 0x1D, 0x1C, 0x00, 0x16, 0x06,</span><br><span class="line">                              0x07, 0x17, 0x30, 0x03, 0x30, 0x06, 0x0A, 0x71&#125;;</span><br><span class="line">    xxtea_decrypt(data);</span><br><span class="line">    xtea_decrypt(data, 48);</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#DASCTF&#123;You_come_to_me_better_than_all_the_good.&#125;</span><br></pre></td></tr></table></figure>



<h2 id="secret-of-inkey"><a href="#secret-of-inkey" class="headerlink" title="secret_of_inkey"></a>secret_of_inkey</h2><p>ida打开附件 打开字符串发现key</p>
<p><img src="/../images/img_das3.png" alt="img_das3"></p>
<p>先放程序里跑一下 得到了别的格子的key 所以应该是每个格子有对应的key 某一个格子会给flag<br>在查找Please input the key 跟进到主要逻辑的函数</p>
<p><img src="/../images/secret_of_inkey.png" alt="secret_of_inkey"></p>
<p>向下翻找到加密函数</p>
<p><img src="/../images/secret_of_inkey-1.png" alt="secret_of_inkey-1"></p>
<p>跟进此函数</p>
<p><img src="/../images/secret_of_inkey-2.png" alt="secret_of_inkey-2"></p>
<p>这里是对密文进行处理 跟密钥与下标的异或值异或 随后进行aes加密 findcrypt也可看出<br>找密文 发现sub_402350里有大量的数据 计算一下刚好是960个 跟程序里的格子数一样 猜测是密文 写个脚本提取出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import idc</span><br><span class="line">import idaapi</span><br><span class="line">import idautils</span><br><span class="line">start_address = 0x0000000000420140</span><br><span class="line">end_address = 0x000000000043E1BF</span><br><span class="line">output_file = &quot;1.txt&quot;</span><br><span class="line">def data(start, end, file_path):</span><br><span class="line">    with open(file_path, &quot;w&quot;) as f:</span><br><span class="line">        current_address = start</span><br><span class="line">        while current_address &lt;= end:</span><br><span class="line">            byte = idc.get_wide_byte(current_address)</span><br><span class="line">            f.write(f&quot;&#123;byte:02x&#125;&quot;)</span><br><span class="line">            current_address += 1</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    data(start_address, end_address, output_file)</span><br></pre></td></tr></table></figure>

<p>所以可以循环解密 发现密钥则更改密钥再次解密 直到爆破出flag 当时比赛做的时候这个脚本搓了好久没出 赛后看师傅们的wp才搓出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import AES  </span><br><span class="line">import re  </span><br><span class="line">  </span><br><span class="line">def aes_decrypt(ciphertext, key):  </span><br><span class="line">    cipher = AES.new(key.encode(), AES.MODE_ECB)  </span><br><span class="line">    return cipher.decrypt(ciphertext)  </span><br><span class="line">  </span><br><span class="line">def xor_with_key(data, key):  </span><br><span class="line">    result = bytearray(data)  </span><br><span class="line">    for i in range(len(data)):  </span><br><span class="line">        result[i] ^= i ^ ord(key[i % len(key)])  </span><br><span class="line">    return result  </span><br><span class="line">  </span><br><span class="line">def process_encryption(enc, key):  </span><br><span class="line">    enc_aes = [enc[i * 32:(i + 1) * 32] for i in range(len(enc) // 32)]  </span><br><span class="line">    keys = key.copy()  </span><br><span class="line">  </span><br><span class="line">    blast = True  </span><br><span class="line">    while blast:  </span><br><span class="line">        blast = False  </span><br><span class="line">        for key_id, key_value in list(keys.items()):  </span><br><span class="line">            #print(f&quot;&#123;key_id&#125;,&#123;key_value&#125;&quot;)  </span><br><span class="line">            de_aes = AES.new(key_value.encode(), AES.MODE_ECB)  </span><br><span class="line">            for i in enc_aes[:]:  </span><br><span class="line">                enc1 = xor_with_key(i, key_value)  </span><br><span class="line">                dec = aes_decrypt(bytes(enc1), key_value)  </span><br><span class="line">  </span><br><span class="line">                if dec[:6] == b&#x27;key_of&#x27;:  </span><br><span class="line">                    x = re.findall(&#x27;key_of_(\d+)_is_&quot;([0-9a-f]+)&quot;&#x27;, dec.decode())  </span><br><span class="line">                    if x and x[0][0] not in keys:  </span><br><span class="line">                        keys[x[0][0]] = x[0][1]  </span><br><span class="line">                    enc_aes.remove(i)  </span><br><span class="line">                    blast = True  </span><br><span class="line">  </span><br><span class="line">    return keys, enc_aes  </span><br><span class="line">  </span><br><span class="line">def final_decrypt(enc_aes, keys):  </span><br><span class="line">    for key_id, key_value in keys.items():  </span><br><span class="line">        print(f&quot;&#123;key_id&#125;,&#123;key_value&#125;&quot;)  </span><br><span class="line">        for i in enc_aes:  </span><br><span class="line">            enc1 = xor_with_key(i, key_value)  </span><br><span class="line">            dec = aes_decrypt(bytes(enc1), key_value)  </span><br><span class="line">            if all(32 &lt;= b &lt;= 126 for b in dec):  </span><br><span class="line">                print(f&quot;Key &#123;key_id&#125;: &#123;dec.decode()&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">enc = bytes.fromhex(&#x27;c9ef...1797&#x27;)  # 这里应该填入密文  </span><br><span class="line">key = &#123;&#x27;565&#x27;: &#x27;9fc82e15d9de6ef2&#x27;&#125;  </span><br><span class="line">keys, enc_aes = process_encryption(enc, key)  </span><br><span class="line">final_decrypt(enc_aes, keys)</span><br></pre></td></tr></table></figure>

<p>爆破完就能看见各个选项里的值 找到key和flag</p>
<p><img src="/../images/secret_of_inkey-3.png" alt="secret_of_inkey-3"></p>
<blockquote>
<p>参考博客：<a href="https://blog.csdn.net/sln_1550/article/details/144635181">DASCTF 2024最后一战RE题wp-CSDN博客</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Preface</title>
    <url>/2024/12/20/Preface/</url>
    <content><![CDATA[<p>各位师傅好 我是一名ctfer Re选手 隶属于某不知名小战队 活跃在各大比赛之中 最近想进阶一下自己的逆向技术 <span id="more"></span><br>整理了各大比赛的Re题目 并在近期准备学习一下 不会的题目稍后复现 在此期间也想学习pwn的一些知识 所以这个博客记录一下这些Re题目的wp 也作为一个pwn知识笔记 后续参加各大比赛和公开赛的wp也会放在这里 以便自己学习和参考 也希望有地方可以帮助到各位师傅</p>
]]></content>
  </entry>
  <entry>
    <title>2025 ccsssc RE wp</title>
    <url>/2025/01/05/2025-ccsssc-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：还是太菜了 三个RE就出了一个┭┮﹏┭┮ 算是个二血？</strong></p>
<h1 id="donntyousee"><a href="#donntyousee" class="headerlink" title="donntyousee"></a>donntyousee</h1><p>ida打开附件 发现有很多retn花 从start的汇编开始一点一点往下去花 </p>
<span id="more"></span>

<p><img src="/../images/donntyousee-1.png" alt="donntyousee-1"></p>
<p><img src="/../images/donntyousee-2.png" alt="donntyousee-2"></p>
<p><img src="/../images/donntyousee-3.png" alt="donntyousee-3"></p>
<p><img src="/../images/donntyousee-4.png" alt="donntyousee-4"></p>
<p><img src="/../images/donntyousee-5.png" alt="donntyousee-5"></p>
<p><img src="/../images/donntyousee-6.png" alt="donntyousee-6"></p>
<p><img src="/../images/donntyousee-7.png" alt="donntyousee-7"></p>
<p>花都去差不多之后 开始看代码</p>
<p><img src="/../images/donntyousee-8.png" alt="donntyousee-8"></p>
<p>RC4密钥流生成 继续往下看</p>
<p><img src="/../images/donntyousee-9.png" alt="donntyousee-9"></p>
<p>RC4加密</p>
<p><img src="/../images/donntyousee-10.png" alt="donntyousee-10"></p>
<p>找到密文数据 dump下来 注意小端序<br>25CD54AF511C58D3A84B4F56EC835DD4F6474A6FE073B0A5A8C317815E2BF4F671EA2FFFA8639957</p>
<p><img src="/../images/donntyousee-11.png" alt="donntyousee-11"></p>
<p>异或0x23</p>
<p><img src="/../images/donntyousee-12.png" alt="donntyousee-12"></p>
<p>前十三位是密钥 异或0x45 起个调试dump下来<br>D7596E5AFFBEE7BA422C38325DC9<br>赛博厨子跑一下 发现解不开</p>
<p><img src="/../images/donntyousee-13.png" alt="donntyousee-13"></p>
<p>所以密钥应该是有问题 猜测可能有个反调试会修改密钥 使其进行异或 那么直接取出来密钥就好<br>921C2B1FBAFBA2FF07697D77188C</p>
<p><img src="/../images/donntyousee-14.png" alt="donntyousee-14"></p>
<p>拿到flag</p>
]]></content>
  </entry>
</search>
