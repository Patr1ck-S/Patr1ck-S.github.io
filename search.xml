<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024 ciscn&amp;ccb RE wp</title>
    <url>/2024/12/20/2024-ciscn-ccb-Re-wp/</url>
    <content><![CDATA[<h1 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h1><p>运行程序 输入几个字符 观察回显</p>
<span id="more"></span>

<p><img src="/../images/image1-1734689935552-1.png" alt="image1"></p>
<p>随后看了一下flag头的映射</p>
<p><img src="/../images/image2-1734689953905-3.png" alt="image2"></p>
<p>跟flag的前几位一样</p>
<p><img src="/../images/image3-1734689962295-5.png" alt="image3"></p>
<p>发现是单字节加密 所以将所有的可打印字符输入进去dump一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import string  </span><br><span class="line">all_char = string.printable  </span><br><span class="line">print(all_char)</span><br><span class="line">#0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~ 	</span><br></pre></td></tr></table></figure>
<p>得到映射表<br><img src="/../images/image4-1734689969850-7.png" alt="image4"></p>
<p>001c1d000000000000001e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b00000000000000000000000000000000000100000000000000000038003900</p>
<p>随后将flag一一映射过去即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import string  </span><br><span class="line">all_char = string.printable  </span><br><span class="line">#print(all_char)  </span><br><span class="line">table = list(bytes.fromhex(&quot;001c1d000000000000001e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b000000000000000000000000000000000100000000000000000038003900&quot;))  </span><br><span class="line">flag = list(bytes.fromhex(&quot;23 29 1E 24 38 0E 15 20 37 0E 05 20 00 0E 37 12 1D 0F 24 01 01 39&quot;))  </span><br><span class="line">for x in flag:  </span><br><span class="line">    if x in table:  </span><br><span class="line">        print(all_char[table.index(x)], end=&quot;&quot;)</span><br><span class="line">#flag_MTczMDc0MzQ2Ng;;&#123;</span><br></pre></td></tr></table></figure>
<p>手动修改一下flag 结合提示第十四位是4 直接改一下即可<br> flag{MTczMDc4MzQ2Ng=&#x3D;}</p>
<h1 id="ezCsky"><a href="#ezCsky" class="headerlink" title="ezCsky"></a>ezCsky</h1><p>ida打开附件 得选择arm去分析 这里走了好多弯 </p>
<p>发现有RC4 猜测rc4加密 找key和密文</p>
<p><img src="/../images/image5-1734689976784-9.png" alt="image5"></p>
<p>找到key 跟进unk_8AA0</p>
<p><img src="/../images/image6-1734689981410-11.png" alt="image6"></p>
<p>找到密文</p>
<p><img src="/../images/image7-1734689987048-13.png" alt="image7"></p>
<p>直接解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import ARC4  </span><br><span class="line">encrypt_data= [0x96, 0x8F, 0xB8, 0x08, 0x5D, 0xA7, 0x68, 0x44, 0xF2, 0x64,  </span><br><span class="line">  0x92, 0x64, 0x42, 0x7A, 0x78, 0xE6, 0xEA, 0xC2, 0x78, 0xB8,  </span><br><span class="line">  0x63, 0x9E, 0x5B, 0x3D, 0xD9, 0x28, 0x3F, 0xC8, 0x73, 0x06,  </span><br><span class="line">  0xEE, 0x6B, 0x8D, 0x0C, 0x4B, 0xA3, 0x23, 0xAE, 0xCA, 0x40,  </span><br><span class="line">  0xED, 0xD1] # 加密key  </span><br><span class="line">key = b&#x27;testkey&#x27;     # 加密方法  </span><br><span class="line">key1=ARC4.new(key)  </span><br><span class="line">print(key1.encrypt(bytes(encrypt_data)))         # 解密方法</span><br><span class="line">#b&#x27;\n\r\x06\x1c\x1fTVSWQ\x00\x03\x1d\x14XV\x03\x19\x1c\x00T\x03K\x14X\x07\x02IL\x02\x07\x01Q\x0c\x08\x00\x01\x00\x03\x00O&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>最后一位是} 前面的都不对 结合左边的符号表有xor函数</p>
<p><img src="/../images/image8-1734689992869-15.png" alt="image8"></p>
<p>猜测进行了异或 但是最后一位没有异或 所以猜测加密的异或可能是<br>flag[i]^&#x3D;flag[i+1]<br>直接写逆向脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import ARC4  </span><br><span class="line">encrypt_data= [0x96, 0x8F, 0xB8, 0x08, 0x5D, 0xA7, 0x68, 0x44, 0xF2, 0x64,  </span><br><span class="line">  0x92, 0x64, 0x42, 0x7A, 0x78, 0xE6, 0xEA, 0xC2, 0x78, 0xB8,  </span><br><span class="line">  0x63, 0x9E, 0x5B, 0x3D, 0xD9, 0x28, 0x3F, 0xC8, 0x73, 0x06,  </span><br><span class="line">  0xEE, 0x6B, 0x8D, 0x0C, 0x4B, 0xA3, 0x23, 0xAE, 0xCA, 0x40,  </span><br><span class="line">  0xED, 0xD1] # 加密key  </span><br><span class="line">key = b&#x27;testkey&#x27;     # 加密方法  </span><br><span class="line">key1=ARC4.new(key)  </span><br><span class="line">print(key1.encrypt(bytes(encrypt_data)))         # 解密方法  </span><br><span class="line">flag = b&#x27;\n\r\x06\x1c\x1fTVSWQ\x00\x03\x1d\x14XV\x03\x19\x1c\x00T\x03K\x14X\x07\x02IL\x02\x07\x01Q\x0c\x08\x00\x01\x00\x03\x00O&#125;&#x27;  </span><br><span class="line"># 将 flag 转换为 list，便于修改  </span><br><span class="line">flag = list(flag)  </span><br><span class="line">for i in range(len(flag)-1,0,-1):  </span><br><span class="line">    flag[i-1] ^= flag[i]  </span><br><span class="line">    print(chr(flag[i]),end=&#x27;&#x27;)  </span><br><span class="line">chr_flag=&#x27;&#125;22110084edca-dfa9-fe11-47a9-033b5f0d&#123;gal&#x27;  </span><br><span class="line">print(chr_flag[::-1])</span><br><span class="line">#lag&#123;d0f5b330-9a74-11ef-9afd-acde48001122&#125;</span><br></pre></td></tr></table></figure>
<p>少了个f 在前面加上就是正确的flag</p>
<h1 id="kiwi"><a href="#kiwi" class="headerlink" title="kiwi"></a>kiwi</h1><p>打开附件 给了一个流量包和一个exe程序 分析一下exe<br><img src="/../images/kiwi.png" alt="kiwi"></p>
<p>跟进一下sub_140082974<br>首先根据word_140111152生成了一个伪随机数 起调试取出来 是0x69<br><img src="/../images/kiwi-1.png" alt="kiwi-1"><br>交叉引用这个伪随机数发现下面进行了异或 并且和随机数进行相加<br><img src="/../images/kiwi-2.png" alt="kiwi-2"></p>
<p>起调试取出随机数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7d, 0x2e, 0x10, 0x3d, 0x2d, 0x27, 0x44, 0x79, 0x27, 0x69, 0x33, 0x55, 0x5c, 0x2d, 0x7a, 0x4, 0x2, 0x65, 0x16,  0x22, 0x14, 0x2d, 0x4, 0x47, 0x1a, 0x7f, 0x26, 0x5b, 0x2a, 0x26, 0x69, 0x2c, 0x2f, 0x75, 0x25, 0x3d, 0x69, 0x38,  0x45, 0x62, 0x35, 0x6b, 0x27, 0x9, 0xf, 0x2a, 0x46, 0x5b, 0x55, 0x69, 0x16, 0x4, 0x4d, 0x65, 0x2f, 0x4e, 0x6a, 0x5a, 0x2e, 0x75, 0x4b, 0x77, 0x58, 0x37, 0x5, 0xf, 0x1, 0x2a, 0x22, 0x11, 0x2d, 0x52, 0x6a, 0x3a, 0x74, 0x73,  0x61, 0x9, 0x2b, 0x24, 0x10, 0x74, 0x40, 0x25, 0x8, 0x59, 0x66, 0x72, 0x25, 0x37, 0x72, 0x18, 0x10, 0x1e, 0x5, 0x48, 0x7, 0x64, 0x6c, 0x2a, 0x61, 0x1a, 0x44, 0x73, 0x4c, 0x3e, 0x62, 0x3a, 0x5a, 0x32, 0x72, 0x8, 0x3c, 0x6d,  0x5d, 0x2e, 0x4d, 0x71, 0x71, 0x5b, 0x52, 0x7d, 0x3c, 0x6d, 0x7f, 0x3, 0x38, 0x8, 0x3e, 0x5c, 0x2e, 0x65, 0x2d,  0x3b, 0x54, 0x6d, 0x65, 0x60, 0x38, 0x7, 0x2, 0xe, 0x62, 0x2e, 0x60, 0x3e, 0x35, 0x46, 0x22, 0x15, 0x17, 0x30, 0x79, 0x14, 0x52, 0x1c, 0x23, 0xf, 0x39, 0x1e, 0x31, 0x60, 0xe, 0x5, 0xe, 0x5c, 0x23, 0x68, 0x3d, 0x6, 0x40, 0x1, 0x62, 0x3, 0x45, 0x3e, 0x4, 0x4e, 0x10, 0x16</span><br></pre></td></tr></table></figure>
<p>最后是一个变表的base64<br><img src="/../images/kiwi-3.png" alt="kiwi-3"><br>写个脚本提取一下码表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import idaapi</span><br><span class="line">import idautils</span><br><span class="line">import idc</span><br><span class="line">start = 0x140111070</span><br><span class="line">end = 0x1401110EE</span><br><span class="line">for addr in range(start, end + 1):</span><br><span class="line">    byte = idaapi.get_byte(addr)</span><br><span class="line">    if 32 &lt;= byte &lt;= 126:</span><br><span class="line">        print(chr(byte), end=&quot;&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/../images/kiwi-4.png" alt="kiwi-4"></p>
<p>得到码表为d+F3DwWj8tUckVGZb57S1XsLqfm0vnpeMEzQ2Bg&#x2F;PTrohxluiJCRIYAyH6N4aKO9<br>所以总的逻辑就是密文异或0x69加上随机数然后base64换表编码<br>随后看sub_140082774函数 发现密文是流量包的upload流<br><img src="/../images/kiwi-5.png" alt="kiwi-5"></p>
<p>去流量包里找一下<br><img src="/../images/kiwi-6.png" alt="kiwi-6"></p>
<p>发现密文<br>先解码一下<br><img src="/../images/kiwi-7.png" alt="kiwi-7"></p>
<p>然后写个脚本解密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc = [0xb9, 0x48, 0x1c, 0x58, 0x81, 0x4f, 0x51, 0x7d, 0x27, 0x70, 0x33, 0x6f, 0x79, 0x48, 0x82, 0x21,  </span><br><span class="line">       0x08, 0x80, 0x79, 0x49, 0x51, 0x52, 0x28, 0x9b, 0x7d, 0xbb, 0x40, 0x67, 0x45, 0x7a, 0x96, 0x38,  </span><br><span class="line">       0x3e, 0x7d, 0x41, 0x42, 0x86, 0x60, 0x4f, 0x6c, 0x3b, 0x87, 0x2e, 0x26, 0x72, 0x51, 0x83, 0x80,  </span><br><span class="line">       0x79, 0xbd, 0x79, 0x40, 0x67, 0x71, 0x4a, 0xa2, 0x98, 0x76, 0x3a, 0x8f, 0x68, 0xda, 0x7f, 0x74,  </span><br><span class="line">       0x2a, 0x33, 0x55, 0x8d, 0x5e, 0x2b, 0x39, 0x6d, 0xbe, 0x5f, 0x74, 0x74, 0x7d, 0x11, 0x8e, 0x4b,  </span><br><span class="line">       0x4d, 0x99, 0x64, 0x79, 0x63, 0xb3, 0x73, 0xca, 0x31, 0x90, 0xc3, 0x77, 0x1b, 0x6f, 0x61, 0x52,  </span><br><span class="line">       0x11, 0xbc, 0xbd, 0x86, 0xb2, 0x78, 0x4f, 0x7e, 0x56, 0x8f, 0x6c, 0x94, 0xb4, 0x3a, 0x7f, 0x14,  </span><br><span class="line">       0x4b, 0x79, 0xb6, 0x8c, 0xb0, 0xad, 0x8b, 0x67, 0x6d, 0xd1, 0x7a, 0x9a, 0xa7, 0x31, 0x74, 0x25,  </span><br><span class="line">       0x3e, 0x61, 0x2e, 0x82, 0x3d, 0x63, 0x5e, 0x77, 0x6b, 0x7c, 0x3f, 0x24, 0x65, 0x35, 0x9f, 0x53,  </span><br><span class="line">       0x84, 0x92, 0x42, 0xa0, 0x7d, 0x66, 0x70, 0x3b, 0xd3, 0x65, 0xa2, 0x6d, 0x7f, 0x19, 0x92, 0x7a,  </span><br><span class="line">       0x8c, 0xb8, 0x6b, 0x12, 0x18, 0x66, 0x74, 0xc0, 0x48, 0x64, 0x9d, 0x0e, 0x6f, 0x53, 0x96, 0x49,  </span><br><span class="line">       0x61, 0x5d]  </span><br><span class="line">sub = [0x7d, 0x2e, 0x10, 0x3d, 0x2d, 0x27, 0x44, 0x79, 0x27, 0x69, 0x33, 0x55, 0x5c, 0x2d, 0x7a, 0x4, 0x2, 0x65, 0x16,  </span><br><span class="line">       0x22, 0x14, 0x2d, 0x4, 0x47, 0x1a, 0x7f, 0x26, 0x5b, 0x2a, 0x26, 0x69, 0x2c, 0x2f, 0x75, 0x25, 0x3d, 0x69, 0x38,  </span><br><span class="line">       0x45, 0x62, 0x35, 0x6b, 0x27, 0x9, 0xf, 0x2a, 0x46, 0x5b, 0x55, 0x69, 0x16, 0x4, 0x4d, 0x65, 0x2f, 0x4e, 0x6a,  </span><br><span class="line">       0x5a, 0x2e, 0x75, 0x4b, 0x77, 0x58, 0x37, 0x5, 0xf, 0x1, 0x2a, 0x22, 0x11, 0x2d, 0x52, 0x6a, 0x3a, 0x74, 0x73,  </span><br><span class="line">       0x61, 0x9, 0x2b, 0x24, 0x10, 0x74, 0x40, 0x25, 0x8, 0x59, 0x66, 0x72, 0x25, 0x37, 0x72, 0x18, 0x10, 0x1e, 0x5,  </span><br><span class="line">       0x48, 0x7, 0x64, 0x6c, 0x2a, 0x61, 0x1a, 0x44, 0x73, 0x4c, 0x3e, 0x62, 0x3a, 0x5a, 0x32, 0x72, 0x8, 0x3c, 0x6d,  </span><br><span class="line">       0x5d, 0x2e, 0x4d, 0x71, 0x71, 0x5b, 0x52, 0x7d, 0x3c, 0x6d, 0x7f, 0x3, 0x38, 0x8, 0x3e, 0x5c, 0x2e, 0x65, 0x2d,  </span><br><span class="line">       0x3b, 0x54, 0x6d, 0x65, 0x60, 0x38, 0x7, 0x2, 0xe, 0x62, 0x2e, 0x60, 0x3e, 0x35, 0x46, 0x22, 0x15, 0x17, 0x30,  </span><br><span class="line">       0x79, 0x14, 0x52, 0x1c, 0x23, 0xf, 0x39, 0x1e, 0x31, 0x60, 0xe, 0x5, 0xe, 0x5c, 0x23, 0x68, 0x3d, 0x6, 0x40, 0x1,  </span><br><span class="line">       0x62, 0x3, 0x45, 0x3e, 0x4, 0x4e, 0x10, 0x16]  </span><br><span class="line">sand = 0x69  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    flag.append(((enc[i] - sub[i]) ^ sand))  </span><br><span class="line">    print(chr(flag[i]), end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="/../images/kiwi-8.png" alt="kiwi-8"><br>找个在线网站解一下Lihua的NTML即可<br><img src="/../images/kiwi-9.png" alt="kiwi-9"><br>flag{memeallme!}</p>
]]></content>
  </entry>
  <entry>
    <title>DASCTF 2024最后一战 RE wp</title>
    <url>/2024/12/24/DASCTF-2024%E6%9C%80%E5%90%8E%E4%B8%80%E6%88%98-RE/</url>
    <content><![CDATA[<p><strong>前言：期末周 要做课设 还要复习考试 所以今天才复现整理完wp</strong></p>
<h2 id="tryre"><a href="#tryre" class="headerlink" title="tryre"></a>tryre</h2><p>真正的签到题！ida打开附件 发现密文和更换的base64码表</p>
<span id="more"></span>

<p><img src="/../images/img_dasctf1.png" alt="img_dasctf1"></p>
<p>随后继续看发现异或2</p>
<p><img src="/../images/img_das2.png" alt="img_das2"></p>
<p>所以解密就是异或2然后换码表解码 直接写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc=&#x27;M@ASL3MF`uL3ICT2IhUgKSD2IeDsICH7Hd26HhQgKSQhNCX7TVL3UFMeHi2?&#x27;  </span><br><span class="line">flag=[]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    flag.append(ord(enc[i])^2)  </span><br><span class="line">    print(chr(flag[i]),end=&#x27;&#x27;)  </span><br><span class="line">print()  </span><br><span class="line">import base64  </span><br><span class="line">import string  </span><br><span class="line">string = &quot;OBCQN1ODbwN1KAV0KjWeIQF0KgFqKAJ5Jf04JjSeIQSjLAZ5VTN1WDOgJk0=&quot;  </span><br><span class="line">tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">tableNew =    &quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;  </span><br><span class="line">flag = base64.b64decode(string.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">print (flag)</span><br><span class="line">b&#x27;DASCTF&#123;454646fa-2462-4392-82ea-5f809ad5ddc2&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="黑客不许哭"><a href="#黑客不许哭" class="headerlink" title="黑客不许哭"></a>黑客不许哭</h2><p>ida打开附件 交叉引用一下输入的值 </p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp.png" alt="黑客不许哭wp"></p>
<p>发现是对输入进行了*1.020123456789<br>往下翻找到比较的地方</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-1.png" alt="黑客不许哭wp-1"></p>
<p>最终比较的数据很大 猜测是对输入进行了乘法操作</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-2.png" alt="黑客不许哭wp-2"></p>
<p>写个脚本解一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qword_7FF64E34A170 = [  </span><br><span class="line">    4358.58716, 6122.2983, 2158.74574, 5973.017537, 9173.840881,  </span><br><span class="line">    6164.67827, 12293.528276, 4091.327439, 3360.696562, 2403.667017,  </span><br><span class="line">    3199.455077, 4962.117508, 8266.407604, 2863.062918, 1044.626306,  </span><br><span class="line">    1067.5308730000002, 3217.476319, 6260.942959, 3278.952568, 160.724197,  </span><br><span class="line">    596.797742, 3277.973032, 6368.757598, 842.858109, 5925.142209,  </span><br><span class="line">    3046.937162, 12752.384458, 2442.54747, 1827.164764, 4903.961921,  </span><br><span class="line">    5619.869598, 3851.247916, 4472.987644, 13135.636855, 1640.630636,  </span><br><span class="line">    975.429551, 2174.379531, 2289.845471, 2605.707441, 1488.586824,  </span><br><span class="line">    12216.019619, 4588.270425, 4803.36317, 13035.30263  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A010 = [  </span><br><span class="line">    60.51846366284686, 89.4737043286176, 24.031047113523933, 84.68873702464015,  </span><br><span class="line">    104.66953644646323, 83.75627693648984, 96.41044018110416, 75.27071882034213,  </span><br><span class="line">    60.33140727998576, 46.10475987767577, 56.28563000222285, 86.68936481373537,  </span><br><span class="line">    80.87786332435297, 55.29894355978243, 9.261748448423328, 20.6272127322797,  </span><br><span class="line">    31.189741971747896, 116.18656005122571, 30.859918262868042, 1.0633446004217317,  </span><br><span class="line">    10.591447767777225, 55.64965261721374, 122.95044769452201, 7.140637105592679,  </span><br><span class="line">    55.44977106531295, 62.827038867512506, 125.30574894504994, 45.94487116254584,  </span><br><span class="line">    32.57185367060958, 92.37291765689986, 117.68050783530462, 63.422414786033976,  </span><br><span class="line">    84.08593452538155, 125.30354189600813, 26.504600725852114, 15.6085145259943,  </span><br><span class="line">    35.687075116213585, 37.67352051379848, 24.32434117146088, 25.692484908155073,  </span><br><span class="line">    116.46382825728031, 86.30264794289376, 79.51984419851664, 100.65174601005425  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A000 = 1.020123456789  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(44):  </span><br><span class="line">    value = (((qword_7FF64E34A170[i]) / qword_7FF64E34A000)-1) / qword_7FF64E34A010[i]  </span><br><span class="line">    flag.append(chr(int(value)))  </span><br><span class="line">print(&quot;&quot;.join(flag))</span><br><span class="line">#FCXEUH|56378d2n2e4h792sh/c464.;4f&lt;=;;h8f4;~</span><br></pre></td></tr></table></figure>

<p>解不开 但是已知flag头是DASCTF 直接测试一下 发现和最终的结果差了100左右</p>
<p><img src="/../images/%E9%BB%91%E5%AE%A2%E4%B8%8D%E8%AE%B8%E5%93%ADwp-3.png" alt="黑客不许哭wp-3"></p>
<p>修改一下脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">test1 = (((ord(&quot;D&quot;)) * 1.020123456789) + 1) * 60.51846366284686  </span><br><span class="line">print(test1)  </span><br><span class="line">test2 = (((ord(&quot;A&quot;)) * 1.020123456789)+ 1) * 89.4737043286176  </span><br><span class="line">print(test2)  </span><br><span class="line">test3 = (((ord(&quot;S&quot;)) * 1.020123456789)+ 1) * 24.031047113523933  </span><br><span class="line">print(test3)  </span><br><span class="line">  </span><br><span class="line">qword_7FF64E34A170 = [  </span><br><span class="line">    4358.58716, 6122.2983, 2158.74574, 5973.017537, 9173.840881,  </span><br><span class="line">    6164.67827, 12293.528276, 4091.327439, 3360.696562, 2403.667017,  </span><br><span class="line">    3199.455077, 4962.117508, 8266.407604, 2863.062918, 1044.626306,  </span><br><span class="line">    1067.5308730000002, 3217.476319, 6260.942959, 3278.952568, 160.724197,  </span><br><span class="line">    596.797742, 3277.973032, 6368.757598, 842.858109, 5925.142209,  </span><br><span class="line">    3046.937162, 12752.384458, 2442.54747, 1827.164764, 4903.961921,  </span><br><span class="line">    5619.869598, 3851.247916, 4472.987644, 13135.636855, 1640.630636,  </span><br><span class="line">    975.429551, 2174.379531, 2289.845471, 2605.707441, 1488.586824,  </span><br><span class="line">    12216.019619, 4588.270425, 4803.36317, 13035.30263  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A010 = [  </span><br><span class="line">    60.51846366284686, 89.4737043286176, 24.031047113523933, 84.68873702464015,  </span><br><span class="line">    104.66953644646323, 83.75627693648984, 96.41044018110416, 75.27071882034213,  </span><br><span class="line">    60.33140727998576, 46.10475987767577, 56.28563000222285, 86.68936481373537,  </span><br><span class="line">    80.87786332435297, 55.29894355978243, 9.261748448423328, 20.6272127322797,  </span><br><span class="line">    31.189741971747896, 116.18656005122571, 30.859918262868042, 1.0633446004217317,  </span><br><span class="line">    10.591447767777225, 55.64965261721374, 122.95044769452201, 7.140637105592679,  </span><br><span class="line">    55.44977106531295, 62.827038867512506, 125.30574894504994, 45.94487116254584,  </span><br><span class="line">    32.57185367060958, 92.37291765689986, 117.68050783530462, 63.422414786033976,  </span><br><span class="line">    84.08593452538155, 125.30354189600813, 26.504600725852114, 15.6085145259943,  </span><br><span class="line">    35.687075116213585, 37.67352051379848, 24.32434117146088, 25.692484908155073,  </span><br><span class="line">    116.46382825728031, 86.30264794289376, 79.51984419851664, 100.65174601005425  </span><br><span class="line">]  </span><br><span class="line">qword_7FF64E34A000 = 1.020123456789  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(44):  </span><br><span class="line">    value = (((qword_7FF64E34A170[i]) / qword_7FF64E34A000)-1) / qword_7FF64E34A010[i]  </span><br><span class="line">    flag.append(chr(int(value)))  </span><br><span class="line">print(&quot;&quot;.join(flag))</span><br><span class="line">#DASCTF&#123;34056b0c-a3d7-71ef-b132-92e8688d4e29&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h2 id="刻板印象"><a href="#刻板印象" class="headerlink" title="刻板印象"></a>刻板印象</h2><p>ida打开附件 乍一看逻辑很简单 只有一个异或</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1.png" alt="刻板印象"></p>
<p>写脚本解一下 发现是fake的flag </p>
<p>This_is_clearly_a_fake_flag_so_try_to_find_more.</p>
<p>随后看一下汇编 发现有花 nop掉重新f5即可恢复原本的函数</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-1.png" alt="刻板印象-1"></p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-2.png" alt="刻板印象-2"></p>
<p>发现是一个xtea＋异或 写个脚本解一下 还是fakeflag</p>
<p>fakeflag_plz_Try_more_hard_to_find_the_true_flag</p>
<p>于是打算看看函数 发现了一个tls没有用到 起调试跑一下 发现从xtea出来进入了一个新的函数 那个新函数刚好是tls函数中的</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-3.png" alt="刻板印象-3"></p>
<p>单步运行到最后 发现跳转到一个新的地址 有很多一段一段的汇编</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-4.png" alt="刻板印象-4"></p>
<p>运行一会 问了一下gpt 大概是xxtea<br>发现密钥{What_is_this_?} delta是0x11451419</p>
<p><img src="/../images/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1-6.png" alt="刻板印象-6"></p>
<p>跑到最后还有一个xor 提取一下 所以总体逻辑就是 xor xtea xor xxtea xor<br>写逆向脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define MX (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z)))</span><br><span class="line">typedef unsigned char BYTE;</span><br><span class="line">unsigned char aLaughterIsPois[] = &quot;Laughter_is_poison_to_fear&quot;;</span><br><span class="line">unsigned char xor_xtea_num[48] = &#123;0xDA, 0x30, 0x23, 0xE3, 0xDC, 0x39, 0x82, 0x60, 0xA5, 0x44,</span><br><span class="line">                                  0x68, 0xC2, 0x43, 0x7A, 0xBB, 0xE4, 0x50, 0xE1, 0x02, 0xC2,</span><br><span class="line">                                  0x81, 0x59, 0xEA, 0x1E, 0xC6, 0x8B, 0x71, 0x38, 0x27, 0x83,</span><br><span class="line">                                  0x94, 0xD8, 0xF4, 0x8D, 0x1A, 0x2A, 0x56, 0x8A, 0x4A, 0xD4,</span><br><span class="line">                                  0x54, 0xDC, 0x24, 0x3F, 0xB9, 0xED, 0x7B, 0x9A&#125;;</span><br><span class="line">unsigned char xor_xxtea_num[48] = &#123;0x8f, 0x6c, 0xa6, 0x3f, 0x94, 0x3d, 0xf5, 0xd9, 0x36, 0x66, 0x51, 0xd7, 0x66,</span><br><span class="line">                                   0x2f, 0xb3, 0x8f, 0xc0, 0x61, 0x9e, 0xce, 0xe9, 0xd7, 0xe1, 0xbf, 0x13, 0x14,</span><br><span class="line">                                   0x16, 0x14, 0xc2, 0xe7, 0xc3, 0x3a, 0x7f, 0x94, 0xa1, 0xe7, 0x24, 0x0e, 0xa7,</span><br><span class="line">                                   0x5c, 0xd3, 0x77, 0xfe, 0x4f, 0x11, 0xdc, 0x69, 0x23&#125;;</span><br><span class="line">void xtea_decrypt(unsigned char *data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= xor_xtea_num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned int *v = (unsigned int *)data;</span><br><span class="line">    unsigned char key_xtea[] = &quot;&#123;you_find_it_!?&#125;&quot;;</span><br><span class="line">    unsigned int *v8 = (unsigned int *)key_xtea;</span><br><span class="line">    for (int l = 0; l &lt; 12; l += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned int v6 = v[l], v5 = v[l + 1], v4 = 0;</span><br><span class="line">        unsigned int delta = 0x61C88647;</span><br><span class="line">        v4 = -1 * 32 * delta;</span><br><span class="line">        for (int i = 0; i &lt; 32; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v5 -= (v8[(v4 &gt;&gt; 11) &amp; 3] + v4) ^ (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6);</span><br><span class="line">            v4 += delta;</span><br><span class="line">            v6 -= (v8[v4 &amp; 3] + v4) ^ (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5);</span><br><span class="line">        &#125;</span><br><span class="line">        v[l] = v6;</span><br><span class="line">        v[l + 1] = v5;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= aLaughterIsPois[i % 26];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void xxtea_decrypt(uint8_t *data)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] ^= xor_xxtea_num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int n = -12;</span><br><span class="line">    uint32_t *v = (uint32_t *)data;</span><br><span class="line">    unsigned char *key_xxtea = &quot;&#123;What_is_this_?&#125;&quot;;</span><br><span class="line">    uint32_t *key = (unsigned int *)key_xxtea;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    unsigned int delta = 0x11451419;</span><br><span class="line">    if (n &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52 / n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n - 1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += delta;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p = 0; p &lt; n - 1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p + 1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n - 1] += MX;</span><br><span class="line">        &#125; while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52 / n;</span><br><span class="line">        sum = rounds * delta;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p = n - 1; p &gt; 0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p - 1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n - 1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= delta;</span><br><span class="line">        &#125; while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char data[48] = &#123;0x18, 0x09, 0x1C, 0x14, 0x37, 0x1D, 0x16, 0x2D, 0x3C, 0x05,</span><br><span class="line">                              0x16, 0x3E, 0x02, 0x03, 0x10, 0x2C, 0x0E, 0x31, 0x39, 0x15,</span><br><span class="line">                              0x04, 0x3A, 0x39, 0x03, 0x0D, 0x13, 0x2B, 0x3E, 0x06, 0x08,</span><br><span class="line">                              0x37, 0x00, 0x17, 0x0B, 0x00, 0x1D, 0x1C, 0x00, 0x16, 0x06,</span><br><span class="line">                              0x07, 0x17, 0x30, 0x03, 0x30, 0x06, 0x0A, 0x71&#125;;</span><br><span class="line">    xxtea_decrypt(data);</span><br><span class="line">    xtea_decrypt(data, 48);</span><br><span class="line">    for (int i = 0; i &lt; 48; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#DASCTF&#123;You_come_to_me_better_than_all_the_good.&#125;</span><br></pre></td></tr></table></figure>



<h2 id="secret-of-inkey"><a href="#secret-of-inkey" class="headerlink" title="secret_of_inkey"></a>secret_of_inkey</h2><p>ida打开附件 打开字符串发现key</p>
<p><img src="/../images/img_das3.png" alt="img_das3"></p>
<p>先放程序里跑一下 得到了别的格子的key 所以应该是每个格子有对应的key 某一个格子会给flag<br>在查找Please input the key 跟进到主要逻辑的函数</p>
<p><img src="/../images/secret_of_inkey.png" alt="secret_of_inkey"></p>
<p>向下翻找到加密函数</p>
<p><img src="/../images/secret_of_inkey-1.png" alt="secret_of_inkey-1"></p>
<p>跟进此函数</p>
<p><img src="/../images/secret_of_inkey-2.png" alt="secret_of_inkey-2"></p>
<p>这里是对密文进行处理 跟密钥与下标的异或值异或 随后进行aes加密 findcrypt也可看出<br>找密文 发现sub_402350里有大量的数据 计算一下刚好是960个 跟程序里的格子数一样 猜测是密文 写个脚本提取出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import idc</span><br><span class="line">import idaapi</span><br><span class="line">import idautils</span><br><span class="line">start_address = 0x0000000000420140</span><br><span class="line">end_address = 0x000000000043E1BF</span><br><span class="line">output_file = &quot;1.txt&quot;</span><br><span class="line">def data(start, end, file_path):</span><br><span class="line">    with open(file_path, &quot;w&quot;) as f:</span><br><span class="line">        current_address = start</span><br><span class="line">        while current_address &lt;= end:</span><br><span class="line">            byte = idc.get_wide_byte(current_address)</span><br><span class="line">            f.write(f&quot;&#123;byte:02x&#125;&quot;)</span><br><span class="line">            current_address += 1</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    data(start_address, end_address, output_file)</span><br></pre></td></tr></table></figure>

<p>所以可以循环解密 发现密钥则更改密钥再次解密 直到爆破出flag 当时比赛做的时候这个脚本搓了好久没出 赛后看师傅们的wp才搓出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import AES  </span><br><span class="line">import re  </span><br><span class="line">  </span><br><span class="line">def aes_decrypt(ciphertext, key):  </span><br><span class="line">    cipher = AES.new(key.encode(), AES.MODE_ECB)  </span><br><span class="line">    return cipher.decrypt(ciphertext)  </span><br><span class="line">  </span><br><span class="line">def xor_with_key(data, key):  </span><br><span class="line">    result = bytearray(data)  </span><br><span class="line">    for i in range(len(data)):  </span><br><span class="line">        result[i] ^= i ^ ord(key[i % len(key)])  </span><br><span class="line">    return result  </span><br><span class="line">  </span><br><span class="line">def process_encryption(enc, key):  </span><br><span class="line">    enc_aes = [enc[i * 32:(i + 1) * 32] for i in range(len(enc) // 32)]  </span><br><span class="line">    keys = key.copy()  </span><br><span class="line">  </span><br><span class="line">    blast = True  </span><br><span class="line">    while blast:  </span><br><span class="line">        blast = False  </span><br><span class="line">        for key_id, key_value in list(keys.items()):  </span><br><span class="line">            #print(f&quot;&#123;key_id&#125;,&#123;key_value&#125;&quot;)  </span><br><span class="line">            de_aes = AES.new(key_value.encode(), AES.MODE_ECB)  </span><br><span class="line">            for i in enc_aes[:]:  </span><br><span class="line">                enc1 = xor_with_key(i, key_value)  </span><br><span class="line">                dec = aes_decrypt(bytes(enc1), key_value)  </span><br><span class="line">  </span><br><span class="line">                if dec[:6] == b&#x27;key_of&#x27;:  </span><br><span class="line">                    x = re.findall(&#x27;key_of_(\d+)_is_&quot;([0-9a-f]+)&quot;&#x27;, dec.decode())  </span><br><span class="line">                    if x and x[0][0] not in keys:  </span><br><span class="line">                        keys[x[0][0]] = x[0][1]  </span><br><span class="line">                    enc_aes.remove(i)  </span><br><span class="line">                    blast = True  </span><br><span class="line">  </span><br><span class="line">    return keys, enc_aes  </span><br><span class="line">  </span><br><span class="line">def final_decrypt(enc_aes, keys):  </span><br><span class="line">    for key_id, key_value in keys.items():  </span><br><span class="line">        print(f&quot;&#123;key_id&#125;,&#123;key_value&#125;&quot;)  </span><br><span class="line">        for i in enc_aes:  </span><br><span class="line">            enc1 = xor_with_key(i, key_value)  </span><br><span class="line">            dec = aes_decrypt(bytes(enc1), key_value)  </span><br><span class="line">            if all(32 &lt;= b &lt;= 126 for b in dec):  </span><br><span class="line">                print(f&quot;Key &#123;key_id&#125;: &#123;dec.decode()&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">enc = bytes.fromhex(&#x27;c9ef...1797&#x27;)  # 这里应该填入密文  </span><br><span class="line">key = &#123;&#x27;565&#x27;: &#x27;9fc82e15d9de6ef2&#x27;&#125;  </span><br><span class="line">keys, enc_aes = process_encryption(enc, key)  </span><br><span class="line">final_decrypt(enc_aes, keys)</span><br></pre></td></tr></table></figure>

<p>爆破完就能看见各个选项里的值 找到key和flag</p>
<p><img src="/../images/secret_of_inkey-3.png" alt="secret_of_inkey-3"></p>
<blockquote>
<p>参考博客：<a href="https://blog.csdn.net/sln_1550/article/details/144635181">DASCTF 2024最后一战RE题wp-CSDN博客</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Preface</title>
    <url>/2024/12/20/Preface/</url>
    <content><![CDATA[<p>各位师傅好 我是一名ctfer Re选手 活跃在各大比赛之中 最近想进阶一下自己的逆向技术 <span id="more"></span><br>整理了各大比赛的Re题目 并在近期准备学习一下 不会的题目稍后复现 在此期间也想学习pwn的一些知识 所以这个博客记录一下这些Re题目的wp 也作为一个pwn知识笔记 后续参加各大比赛和公开赛的wp也会放在这里 以便自己学习和参考 也希望有地方可以帮助到各位师傅</p>
]]></content>
  </entry>
  <entry>
    <title>2025 ccsssc RE wp</title>
    <url>/2025/01/05/2025-ccsssc-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：还是太菜了 三个RE就出了一个┭┮﹏┭┮ 算是个二血？</strong></p>
<h1 id="donntyousee"><a href="#donntyousee" class="headerlink" title="donntyousee"></a>donntyousee</h1><p>ida打开附件 发现有很多retn花 从start的汇编开始一点一点往下去花 </p>
<span id="more"></span>

<p><img src="/../images/donntyousee-1.png" alt="donntyousee-1"></p>
<p><img src="/../images/donntyousee-2.png" alt="donntyousee-2"></p>
<p><img src="/../images/donntyousee-3.png" alt="donntyousee-3"></p>
<p><img src="/../images/donntyousee-4.png" alt="donntyousee-4"></p>
<p><img src="/../images/donntyousee-5.png" alt="donntyousee-5"></p>
<p><img src="/../images/donntyousee-6.png" alt="donntyousee-6"></p>
<p><img src="/../images/donntyousee-7.png" alt="donntyousee-7"></p>
<p>花都去差不多之后 开始看代码</p>
<p><img src="/../images/donntyousee-8.png" alt="donntyousee-8"></p>
<p>RC4密钥流生成 继续往下看</p>
<p><img src="/../images/donntyousee-9.png" alt="donntyousee-9"></p>
<p>RC4加密</p>
<p><img src="/../images/donntyousee-10.png" alt="donntyousee-10"></p>
<p>找到密文数据 dump下来 注意小端序<br>25CD54AF511C58D3A84B4F56EC835DD4F6474A6FE073B0A5A8C317815E2BF4F671EA2FFFA8639957</p>
<p><img src="/../images/donntyousee-11.png" alt="donntyousee-11"></p>
<p>异或0x23</p>
<p><img src="/../images/donntyousee-12.png" alt="donntyousee-12"></p>
<p>前十三位是密钥 异或0x45 起个调试dump下来<br>D7596E5AFFBEE7BA422C38325DC9<br>赛博厨子跑一下 发现解不开</p>
<p><img src="/../images/donntyousee-13.png" alt="donntyousee-13"></p>
<p>所以密钥应该是有问题 猜测可能有个反调试会修改密钥 使其进行异或 那么直接取出来密钥就好<br>921C2B1FBAFBA2FF07697D77188C</p>
<p><img src="/../images/donntyousee-14.png" alt="donntyousee-14"></p>
<p>拿到flag</p>
]]></content>
  </entry>
  <entry>
    <title>2024 春秋杯夏季赛 RE wp</title>
    <url>/2025/01/13/2024-%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%A4%8F%E5%AD%A3%E8%B5%9B-Re-wp/</url>
    <content><![CDATA[<p><strong>前言：这两天做了一下去年春秋杯夏季赛的RE 难度不是很大 知识面涉及的很广 希望今年的冬季赛也可以多做出来几个题</strong></p>
<h1 id="snake"><a href="#snake" class="headerlink" title="snake"></a>snake</h1><p>python的exe程序 环境python3.8解包即可 把snake.pyc扔在线反编译里看一下 发现是一个RC4加密 最后异或的地方加了个跟循环次数的异或</p>
<span id="more"></span>

<p><img src="/../images/snake.png" alt="snake"></p>
<p>密文已知 在反编译一下key.pyc 找到密钥V3rY_v3Ry_Ez 直接写脚本解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def KSA(key):  </span><br><span class="line">    S = list(range(256))  </span><br><span class="line">    j = 0  </span><br><span class="line">    for i in range(256):  </span><br><span class="line">        j = (j + S[i] + key[i % len(key)]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">    return S  </span><br><span class="line">  </span><br><span class="line">def PRGA(S):  </span><br><span class="line">    i, j = 0, 0  </span><br><span class="line">    while True:  </span><br><span class="line">        i = (i + 1) % 256  </span><br><span class="line">        j = (j + S[i]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">        K = S[(S[i] + S[j]) % 256]  </span><br><span class="line">        yield K  </span><br><span class="line">  </span><br><span class="line">def RC4(key, text):  </span><br><span class="line">    S = KSA(key)  </span><br><span class="line">    keystram = PRGA(S)  </span><br><span class="line">    res = []  </span><br><span class="line">    for i, char in enumerate(text):  </span><br><span class="line">        res.append(i ^ char ^ next(keystram))  </span><br><span class="line">    return bytes(res)  </span><br><span class="line">  </span><br><span class="line">key = b&#x27;V3rY_v3Ry_Ez&#x27;  </span><br><span class="line">plaintext = [101, 97, 39, 125, 218, 172, 205, 3, 235, 195, 72, 125, 89, 130, </span><br><span class="line">             103, 213, 120, 227, 193, 67, 174, 71, 162, 248, 244, 12, 238,  </span><br><span class="line">             92, 160, 203, 185, 155]  </span><br><span class="line">ciphertext = RC4(key, plaintext)  </span><br><span class="line">print(ciphertext)</span><br><span class="line">#b&#x27;flag&#123;KMLTz3lT_MePUDa7A_P5LpzCBT&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h1 id="HardSignin"><a href="#HardSignin" class="headerlink" title="HardSignin"></a>HardSignin</h1><p>打开附件 发现修改了UPX的特征码 010打开修改回去然后脱壳</p>
<p><img src="/../images/HardSignin.png" alt="HardSignin"></p>
<p>ida打开附件 main的函数看不出来什么逻辑</p>
<p><img src="/../images/HardSignin-1.png" alt="HardSignin-1"></p>
<p>发现TLS函数 跟进交叉引用一下</p>
<p><img src="/../images/HardSignin-2.png" alt="HardSignin-2"></p>
<p>发现花指令 去除</p>
<p><img src="/../images/HardSignin-3.png" alt="HardSignin-3"></p>
<p><img src="/../images/HardSignin-8.png" alt="HardSignin-8"></p>
<p><img src="/../images/HardSignin-9.png" alt="HardSignin-9"></p>
<p>随后分析一下逻辑<br>TLS0是个smc 把main函数跟0x66异或 设置第一个随机数种子 用于TLS1生成变换的码表</p>
<p><img src="/../images/HardSignin-6.png" alt="HardSignin-6"></p>
<p>写个脚本解密一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpAddress = 0x00401890</span><br><span class="line">dwSize = 170</span><br><span class="line">for i in range(170):</span><br><span class="line">    main = (get_wide_byte(lpAddress + i)) ^ 0x66</span><br><span class="line">    patch_byte(lpAddress + i , main)</span><br></pre></td></tr></table></figure>

<p>成功恢复main函数</p>
<p><img src="/../images/HardSignin-7.png" alt="HardSignin-7"></p>
<p>随后看TLS1<br>进行了一个码表的变换 设置第二个随机数种子 用于TLS2生成rc4的key和xtea的key</p>
<p><img src="/../images/HardSignin-10.png" alt="HardSignin-10"></p>
<p>TLS2是进行了两个数的生成 交叉引用可以知道分别是rc4的key和xtea的key</p>
<p><img src="/../images/HardSignin-13.png" alt="HardSignin-13"></p>
<p>这几个函数都有反调试 直接patch即可<br>然后看主函数 逻辑很清晰 对密文进行base64换表编码 随后RC4加密 最后xtea加密</p>
<p><img src="/../images/HardSignin-12.png" alt="HardSignin-12"></p>
<p>xtea魔改了一下 轮数是100</p>
<p><img src="/../images/HardSignin-14.png" alt="HardSignin-14"></p>
<p>密文就是下面比对的unk_374000<br>我这里不知道为什么调试总是起不来 猜测可能是因为smc我手动解密之后 他TLS0重新跑了一次 把main函数异或回去了 所以索性静态写个脚本 跑一下key和变换后的base码表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void swap(char *a1, char *a2)</span><br><span class="line">&#123;</span><br><span class="line">    char v3;</span><br><span class="line">    v3 = *a1;</span><br><span class="line">    *a1 = *a2;</span><br><span class="line">    *a2 = v3;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char table[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line">    srand(0x114514u);</span><br><span class="line">    for (int i = 0; i &lt; 100; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int v3 = rand() % 64;</span><br><span class="line">        int v5 = rand() % 64;</span><br><span class="line">        swap(&amp;table[v3], &amp;table[v5]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%s\n&quot;, table);</span><br><span class="line">    srand(0x1919810u);</span><br><span class="line">    for (int j = 0; j &lt; 16; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        int rc4_key = rand() % 255;</span><br><span class="line">        int xtea_key = rand() % 255;</span><br><span class="line">        printf(&quot;%d,%d\n&quot;, rc4_key, xtea_key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">new_table=4yZRiNP8LoK/GSA5ElWkUjXtJCz7bMYcuFfpm6+hV0rxeHIdwv32QOTnqg1BDsa9</span><br><span class="line">rc4_key=[118, 137, 51, 73, 25, 19, 195, 199, 173, 216, 228, 104, 252, 72, 4, 188]</span><br><span class="line">xtea_key=[221, 91, 170, 12, 36, 105, 132, 214, 184, 30, 4, 81, 6, 171, 42, 139]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>得到rc4_key和xtea_key的key后 已知密文 直接写脚本解密即可<br>先解xtea</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void xtea_decrypt(unsigned int round, uint32_t enc[2], uint32_t key[4])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    unsigned int j;  // [esp+4Ch] [ebp-18h]</span><br><span class="line">    unsigned int v5; // [esp+54h] [ebp-10h]</span><br><span class="line">    unsigned int v6; // [esp+58h] [ebp-Ch]</span><br><span class="line">    unsigned int v7; // [esp+5Ch] [ebp-8h]</span><br><span class="line">    v7 = enc[0];</span><br><span class="line">    v6 = enc[1];</span><br><span class="line">    v5 = 0 - round * 0x61C88647;</span><br><span class="line">    for (j = 0; j &lt; round; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        v6 -= (key[((v5 &gt;&gt; 11) &amp; 3)] + v5) ^ (v7 + ((v7 &gt;&gt; 5) ^ (16 * v7)));</span><br><span class="line">        v5 += 0x61C88647;</span><br><span class="line">        v7 -= (key[((v5 &amp; 3))]) + v5 ^ (v6 + ((v6 &gt;&gt; 5) ^ (16 * v6)));</span><br><span class="line">    &#125;</span><br><span class="line">    enc[0] = v7;</span><br><span class="line">    enc[1] = v6;</span><br><span class="line">&#125;</span><br><span class="line">unsigned char enc[] = &#123;0x59, 0x1B, 0xFD, 0xB4, 0x6B, 0xB8, 0xBE, 0xD9, 0xB3, 0xD3, 0x77, 0xD6, 0xF0, 0x65, 0x5F, 0x18,0xA0, 0x9D, 0x3A, 0x53, 0x6D, 0x4A, 0x7B, 0x26, 0x74, 0x3A, 0x9C, 0x4E, 0x20, 0x43, 0x19, 0xD8, 0x72, 0xED, 0x95, 0xB5, 0x9C, 0x05, 0x22, 0x56, 0xCB, 0x7A, 0x11, 0x91, 0x9F, 0x7A, 0xBC, 0x0C,0x4A, 0x69, 0x6D, 0xCE, 0x3D, 0xB4, 0xAB, 0x29, 0x61, 0xFA, 0x62, 0x32, 0xB4, 0xEC, 0x4C, 0xB6, 0x00&#125;;</span><br><span class="line">    uint32_t xtea_key[] = &#123;0x0CAA5BDD, 0xD6846924, 0x51041EB8, 0x8B2AAB06&#125;;</span><br><span class="line">    for (int k = 0; k &lt; sizeof(enc) / 8; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        xtea_decrypt(100, (uint32_t*)enc + k * 2, xtea_key);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int m = 0; m &lt; 64; m++)</span><br><span class="line">        printf(&quot;0x%x,&quot;, enc[m]);</span><br></pre></td></tr></table></figure>

<p>得到RC4的密文<br>0xbc 0xed 0x0 0x7b 0x86 0xf4 0x16 0x93 0x95 0xf9 0x87 0xdc 0x67 0xa8 0xa2 0x7f 0x4d 0xe2 0x62 0x9f 0x7b 0x34 0xae 0xe9 0x45 0x3 0x7e 0x35 0x42 0xd0 0x8b 0x70 0xf0 0xfb 0x2e 0xc7 0xdd 0xe9 0xb9 0x73 0xe3 0xcc 0x1a 0x75 0xad 0xdc 0xfd 0x14 0xa8 0xc8 0x45 0x16 0x31 0x6e 0x2a 0x8 0x2c 0xf 0x1d 0x9f 0x7 0xba 0xd5 0xef</p>
<p>随后解密RC4 + 换表base64</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64  </span><br><span class="line">import string  </span><br><span class="line">#RC4解密  </span><br><span class="line">def ksa(key):  </span><br><span class="line">    S = list(range(256))  </span><br><span class="line">    j = 0  </span><br><span class="line">    key_length = len(key)  </span><br><span class="line">  </span><br><span class="line">    for i in range(256):  </span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">  </span><br><span class="line">    return S  </span><br><span class="line">  </span><br><span class="line">def prga(S, length):  </span><br><span class="line">    i = j = 0  </span><br><span class="line">    keystream = []  </span><br><span class="line">    for _ in range(length):  </span><br><span class="line">        i = (i + 1) % 256  </span><br><span class="line">        j = (j + S[i]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">        keystream.append(S[(S[i] + S[j]) % 256])  </span><br><span class="line">    return keystream  </span><br><span class="line">def rc4(key, plaintext):  </span><br><span class="line">    S = ksa(key)  </span><br><span class="line">    keystream = prga(S, len(plaintext))  </span><br><span class="line">    return bytes([p ^ k for p, k in zip(plaintext, keystream)])  </span><br><span class="line">key = [118, 137, 51, 73, 25, 19, 195, 199, 173, 216, 228, 104, 252, 72, 4, 188]  </span><br><span class="line">ciphertext = [0xbc,0xed,0x0,0x7b,0x86,0xf4,0x16,0x93,0x95,0xf9,0x87,0xdc,0x67,0xa8,0xa2,0x7f,0x4d,0xe2,0x62,0x9f,0x7b,0x34,0xae,0xe9,0x45,0x3,0x7e,0x35,0x42,0xd0,0x8b,0x70,0xf0,0xfb,0x2e,0xc7,0xdd,0xe9,0xb9,0x73,0xe3,0xcc,0x1a,0x75,0xad,0xdc,0xfd,0x14,0xa8,0xc8,0x45,0x16,0x31,0x6e,0x2a,0x8,0x2c,0xf,0x1d,0x9f,0x7,0xba,0xd5,0xef]  </span><br><span class="line">decrypted = rc4(key, ciphertext)  </span><br><span class="line">print(decrypted)  </span><br><span class="line">#base64换表  </span><br><span class="line">string = &quot;C+vFCnHRGPghbmyQMXvFMRNd7fNCG8jcU+jcbnjRJTj2GTCOGUvgtOS0CTge7fNs&quot;  </span><br><span class="line">tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">tableNew =    &quot;4yZRiNP8LoK/GSA5ElWkUjXtJCz7bMYcuFfpm6+hV0rxeHIdwv32QOTnqg1BDsa9&quot;  </span><br><span class="line">flag = base64.b64decode(string.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">print (flag)</span><br><span class="line">#b&#x27;flag&#123;C0ngr@tulat1on!Y0u_Re_suCces3fu1Ly_Signln!&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h1 id="bedtea"><a href="#bedtea" class="headerlink" title="bedtea"></a>bedtea</h1><p>ida打开附件 进入main函数<br>前面是两个反调试 还有输入的部分</p>
<p><img src="/../images/bedtea.png" alt="bedtea"></p>
<p>看下面的那个反调试 如果检测到调试是1 没检测到调试是3<br>随后往下看 发现有三个魔改的tea 修改了轮数 delta还有移位等常量值</p>
<p><img src="/../images/bedtea-1.png" alt="bedtea-1"></p>
<p><img src="/../images/bedtea-2.png" alt="bedtea-2"></p>
<p>上面有个斐波那契数列计算tea的key </p>
<p><img src="/../images/bedtea-3.png" alt="bedtea-3"></p>
<p>起个调试取出三个key 注意把第一个调试的值改为3才会生成正确的key</p>
<p><img src="/../images/bedtea-4.png" alt="bedtea-4"></p>
<p>第一组key：3,5,8,13</p>
<p><img src="/../images/bedtea-6.png" alt="bedtea-6"></p>
<p>第二组key：0x15,0x22,0x37,0x59</p>
<p><img src="/../images/bedtea-7.png" alt="bedtea-7"></p>
<p>第三组key：0x90,0xE9,0x179,0x262</p>
<p><img src="/../images/bedtea-8.png" alt="bedtea-8"></p>
<p>随后通过二叉树对数据进行处理 这个地方的逻辑静态看有点费劲 直接动态对比数据即可</p>
<p><img src="/../images/bedtea-9.png" alt="bedtea-9"></p>
<p><img src="/../images/bedtea-10.png" alt="bedtea-10"></p>
<p>发现对数据进行倒叙处理<br>中间一堆看不懂的代码 经过动态调试 发现是跟0x33异或</p>
<p><img src="/../images/bedtea-12.png" alt="bedtea-12"></p>
<p>这里过一个时间的反调试 通过汇编可以看出函数在这个地方会进行跳转</p>
<p><img src="/../images/bedtea-13.png" alt="bedtea-13"></p>
<p>所以把zf值置为1即可过掉反调试<br>最后的地方存放三段密文</p>
<p><img src="/../images/bedtea-11.png" alt="bedtea-11"></p>
<p>总的逻辑就是 先tea 然后倒置 最后异或0x33<br>直接写逆向脚本解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void tea_decrypt(uint32_t *v, uint32_t *key)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    uint32_t v0 = v[0], v1 = v[1], delta = 0x61CBB648, i, k0 = key[0], k1 = key[1], k2 = key[2], k3 = key[3];</span><br><span class="line">    unsigned int sum = 0x987E55D0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        v1 -= (sum + v0) ^ (k3 + (v0 &gt;&gt; 4)) ^ (k2 + 32 * v0);</span><br><span class="line">        v0 -= (sum + v1) ^ (k1 + (v1 &gt;&gt; 4)) ^ (k0 + 32 * v1);</span><br><span class="line">        sum += 0x61CBB648;</span><br><span class="line">    &#125; while (sum != 0);</span><br><span class="line">    v[0] = v0, v[1] = v1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char rev;</span><br><span class="line">    unsigned char enc[] = &#123;0x76, 0x71, 0x9D, 0xE7, 0x70,</span><br><span class="line">                           0x77, 0x3F, 0xA3, 0x02, 0xF1,</span><br><span class="line">                           0x8D, 0xC9, 0x02, 0xC6, 0xA2,</span><br><span class="line">                           0x4B, 0xBA, 0x19, 0x56, 0x05,</span><br><span class="line">                           0xF2, 0x89, 0x5E, 0xE0&#125;;</span><br><span class="line">    unsigned int key1[] = &#123;3, 5, 8, 13&#125;;</span><br><span class="line">    unsigned int key2[] = &#123;0x15, 0x22, 0x37, 0x59&#125;;</span><br><span class="line">    unsigned int key3[] = &#123;0x90, 0xE9, 0x179, 0x262&#125;;</span><br><span class="line">    //xor 0x33</span><br><span class="line">    for (int i = 0; i &lt; 24; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        enc[i] ^= 0x33;</span><br><span class="line">    &#125;</span><br><span class="line">    //reverse</span><br><span class="line">    for (int j = 0; j &lt; 12; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        rev = enc[j];</span><br><span class="line">        enc[j] = enc[23 - j];</span><br><span class="line">        enc[23 - j] = rev;</span><br><span class="line">    &#125;</span><br><span class="line">    //tea decrypt</span><br><span class="line">    uint32_t *flag1 = (uint32_t *)&amp;enc[0];</span><br><span class="line">    uint32_t *flag2 = (uint32_t *)&amp;enc[8];</span><br><span class="line">    uint32_t *flag3 = (uint32_t *)&amp;enc[16];</span><br><span class="line">    tea_decrypt(flag1, key1);</span><br><span class="line">    tea_decrypt(flag2, key2);</span><br><span class="line">    tea_decrypt(flag3, key3);</span><br><span class="line">    for (int k = 0; k &lt; 24; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;, enc[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//flag&#123;y0u_reallyl1ke_te@&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
]]></content>
  </entry>
  <entry>
    <title>2025 suctf RE wp</title>
    <url>/2025/01/14/2025-suctf-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：比赛期间只做出两道RE 其他的题目还没有复现 等复现完在写一下其他的wp</strong></p>
<h1 id="SU-BBRE"><a href="#SU-BBRE" class="headerlink" title="SU_BBRE"></a>SU_BBRE</h1><p>打开附件 发现密文和密钥 问一下gpt循环了256次 猜测rc4加密 注意小端序</p>
<span id="more"></span>

<p><img src="/../images/SU_BBRE.png" alt="SU_BBRE"></p>
<p>写个脚本解出第一部分flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def ksa(key):</span><br><span class="line">    S = list(range(256))</span><br><span class="line">    j = 0</span><br><span class="line">    key_length = len(key)</span><br><span class="line">    for i in range(256):</span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % 256</span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">    return S</span><br><span class="line">def prga(S, length):</span><br><span class="line">    i = j = 0</span><br><span class="line">    keystream = []</span><br><span class="line">    for _ in range(length):</span><br><span class="line">        i = (i + 1) % 256</span><br><span class="line">        j = (j + S[i]) % 256</span><br><span class="line">        S[i], S[j] = S[j], S[i]</span><br><span class="line">        keystream.append(S[(S[i] + S[j]) % 256])</span><br><span class="line">    return keystream</span><br><span class="line"></span><br><span class="line">def rc4(key, plaintext):</span><br><span class="line">    S = ksa(key)</span><br><span class="line">    keystream = prga(S, len(plaintext))</span><br><span class="line">    return bytes([p ^ k for p, k in zip(plaintext, keystream)])</span><br><span class="line"></span><br><span class="line">key = b&quot;suctf&quot;</span><br><span class="line">ciphertext = [0x2f, 0x5a, 0x57, 0x65, 0x14, 0x8f, 0x69, 0xcd, 0x93, 0x29, 0x1a, 0x55, 0x18, 0x40, 0xe4, 0x5e]</span><br><span class="line">flag1 = rc4(key, ciphertext)</span><br><span class="line">print(flag1)</span><br><span class="line">#b&#x27;We1com3ToReWorld&#x27;</span><br></pre></td></tr></table></figure>

<p>继续往下看 还有一段密文</p>
<p><img src="/../images/SU_BBRE-1.png" alt="SU_BBRE-1"></p>
<p>跟下标进行相加 中间还有一段栈溢出到fun1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag=[0x3d,0x22,0x40]  </span><br><span class="line">print(&#x27;&#x27;.join(chr(x)for x in flag))  </span><br><span class="line">flag2 = []  </span><br><span class="line">enc = [0x41, 0x6D, 0x62, 0x4D, 0x53, 0x49, 0x4e, 0x29, 0x28]  </span><br><span class="line">for i, j in enumerate(enc):  </span><br><span class="line">    flag2.append(chr(i+j))  </span><br><span class="line">    print(flag2[i], end=&#x27;&#x27;)  </span><br><span class="line">#=&quot;@AndPWNT00</span><br></pre></td></tr></table></figure>

<p>拼接起来得到flag<br>SUCTF{We1com3ToReWorld&#x3D;”@AndPWNT00}</p>
<h1 id="SU-minesweeper"><a href="#SU-minesweeper" class="headerlink" title="SU_minesweeper"></a>SU_minesweeper</h1><p>ida打开附件 逻辑很清晰 </p>
<p><img src="/../images/SU_minesweeper-2.png" alt="SU_minesweeper-2"></p>
<p>首先跟进sub_1277 发现进行了一些字符串的转换<br>随后看sub_1432函数 主要的逻辑也在这里</p>
<p><img src="/../images/SU_minesweeper-3.png" alt="SU_minesweeper-3"></p>
<p>有一个400大的数组 20*20 写个脚本提取出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import idc</span><br><span class="line">import idaapi</span><br><span class="line">import idautils</span><br><span class="line">start_addr = 0x0000000000004020</span><br><span class="line">end_addr = 0x00000000000041AF</span><br><span class="line">data = idc.get_bytes(start_addr, end_addr - start_addr + 1)</span><br><span class="line">if data:</span><br><span class="line">	for byte in data:</span><br><span class="line">		print(f&quot;0x&#123;byte:02X&#125;&quot;, end=&quot;,&quot;)</span><br></pre></td></tr></table></figure>

<p>跟进sub_13C9函数 发现是累加 3*3区域内的值 结果返回总和</p>
<p><img src="/../images/SU_minesweeper-4.png" alt="SU_minesweeper-4"></p>
<p>sub_1352函数从指定的 (a2, a3) 坐标位置获取位值 通过计算该位置的字节索引和位偏移提取相应的位</p>
<p><img src="/../images/SU_minesweeper-5.png" alt="SU_minesweeper-5"></p>
<p>flag格式如下</p>
<p><img src="/../images/SU_minesweeper-6.png" alt="SU_minesweeper-6"></p>
<p>已知这些条件 可以先用z3求出解 随后变换求一下md5即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools  </span><br><span class="line">from z3 import *  </span><br><span class="line">enc = [0x03, 0x04, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0x02, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x04, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x04, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x05, 0x06, 0x04, 0xFF, 0x05,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x04, 0x07, 0xFF, 0x08, 0xFF, 0x06, 0xFF, 0xFF, 0x06, 0x06, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0xFF,  </span><br><span class="line">       0x03,  </span><br><span class="line">       0xFF, 0x05, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x05, 0x04, 0x05, 0x07, 0x06, 0xFF, 0xFF, 0x04, 0xFF, 0x02,  </span><br><span class="line">       0x01,  </span><br><span class="line">       0xFF, 0xFF, 0xFF, 0x03, 0x04, 0xFF, 0xFF, 0x05, 0x04, 0x03, 0xFF, 0xFF, 0x07, 0x04, 0x03, 0xFF, 0xFF, 0x01, 0x01,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x04, 0x03, 0xFF, 0x02, 0xFF, 0x04, 0x03, 0xFF, 0xFF, 0x02, 0xFF, 0x05, 0x04, 0xFF, 0xFF, 0x02, 0x02, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x04, 0xFF, 0x04, 0xFF, 0x03, 0x05, 0x06, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0xFF, 0x01, 0x04,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x07, 0x05, 0xFF, 0xFF, 0x03, 0x03, 0x02, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x05, 0x07, 0xFF, 0x03, 0x02, 0x04,  </span><br><span class="line">       0x04,  </span><br><span class="line">       0xFF, 0x07, 0x05, 0x04, 0x03, 0xFF, 0xFF, 0x04, 0xFF, 0x02, 0x04, 0x05, 0xFF, 0xFF, 0x06, 0x05, 0x04, 0xFF, 0x02,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x07, 0x04, 0xFF, 0xFF, 0x03, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x03, 0x02,  </span><br><span class="line">       0x02,  </span><br><span class="line">       0xFF, 0xFF, 0x02, 0x04, 0x03, 0x05, 0xFF, 0xFF, 0x05, 0xFF, 0x04, 0xFF, 0x06, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x03, 0x03, 0xFF, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0x06, 0x06, 0xFF, 0x07, 0x06, 0x04, 0xFF, 0x04,  </span><br><span class="line">       0x03,  </span><br><span class="line">       0xFF, 0x04, 0x03, 0x05, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x06, 0x07, 0xFF, 0xFF, 0x04, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x07, 0xFF, 0x05, 0xFF, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x07, 0xFF, 0x05, 0x06, 0x06, 0xFF, 0xFF, 0x02, 0x04,  </span><br><span class="line">       0x04,  </span><br><span class="line">       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0x07, 0x07, 0x06, 0xFF, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF,  </span><br><span class="line">       0x03,  </span><br><span class="line">       0x05, 0xFF, 0x07, 0xFF, 0x05, 0xFF, 0x06, 0xFF, 0x05, 0xFF, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x03, 0xFF, 0x03, 0xFF,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x05, 0x03, 0xFF, 0x04, 0x05, 0x05, 0x03,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0x06, 0x05, 0x05, 0x06, 0xFF, 0x06, 0x05, 0x02, 0x04, 0x03, 0x04, 0xFF, 0xFF, 0x03, 0x04, 0x04, 0x06, 0x05,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0x03, 0xFF, 0x05, 0x05, 0x05, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x04, 0xFF, 0x07, 0x07, 0x08, 0x06,  </span><br><span class="line">       0xFF,  </span><br><span class="line">       0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0x04, 0xFF, 0x03, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,  </span><br><span class="line">       0x03]  </span><br><span class="line">  </span><br><span class="line">def get_sum(a1, row, col):  </span><br><span class="line">    if 0 &lt;= row &lt;= 19 and 0 &lt;= col &lt;= 19:  </span><br><span class="line">        return a1[(20 * row + col) // 8] &gt;&gt; ((20 * row + col) &amp; 7) &amp; 1  </span><br><span class="line">  </span><br><span class="line">def check_num(a1, row, col):  </span><br><span class="line">    v5 = 0  </span><br><span class="line">    for i, j in itertools.product([-1, 0, 1], repeat=2):  </span><br><span class="line">        if 0 &lt;= row + i &lt;= 19 and 0 &lt;= col + j &lt;= 19:  </span><br><span class="line">            v5 += get_sum(a1, row + i, col + j)  </span><br><span class="line">    return v5  </span><br><span class="line">  </span><br><span class="line">S = Solver()  </span><br><span class="line">flag = [BitVec(f&#x27;flag_&#123;i&#125;&#x27;, 8) for i in range(50)]  </span><br><span class="line">for i in range(20):  </span><br><span class="line">    for j in range(20):  </span><br><span class="line">        if enc[20 * i + j] != 0xff:  </span><br><span class="line">            S.add(enc[20 * i + j] == check_num(flag, i, j))  </span><br><span class="line">if S.check() == sat:  </span><br><span class="line">    m = S.model()  </span><br><span class="line">    flag_value = &#x27;,&#x27;.join(hex(m[flag[i]].as_long()) for i in range(50))  </span><br><span class="line">    print(flag_value)  </span><br><span class="line">  </span><br><span class="line">c = &#x27;5bdb69bfc51e65fbb50b2039218e8007e02c8f8807fe740d1b916d096d6f1b6e597dcc677ba8b63b6f1d1446587d61efec7d&#x27;  </span><br><span class="line">a = &#x27;0123456789abcdef&#x27;  </span><br><span class="line">b = &#x27;abcdef0123456789&#x27;  </span><br><span class="line">for i in c:  </span><br><span class="line">    print(b[a.index(i)], end=&#x27;&#x27;)  </span><br><span class="line">print()  </span><br><span class="line">import hashlib  </span><br><span class="line">flag = &quot;f57503596fb80f955fa5cad3cb282aa18ac62922a1981ea7b53b07a30709b508f3176601154250d509b7bee0f2170b898617&quot;  </span><br><span class="line">flag_md5 = hashlib.md5(flag.encode()).hexdigest()  </span><br><span class="line">print(flag_md5)</span><br><span class="line">#d661b98e4241de7423ef2d953098329d</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>2024 春秋杯冬季赛 DAY1 RE wp</title>
    <url>/2025/01/17/2024-%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B-DAY1-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：打比赛的时候还是考虑的不够细致 vm的wp官方发了</strong></p>
<h1 id="ezre"><a href="#ezre" class="headerlink" title="ezre"></a>ezre</h1><p>ida打开附件 进入主函数 发现有一个md5的反调试 打个硬件断点过掉</p>
<span id="more"></span>

<p><img src="/../images/Patr1ck-wp-12.png" alt="Patr1ck wp-12"></p>
<p>起调试dump下来随机数</p>
<p><img src="/../images/Patr1ck-wp-13.png" alt="Patr1ck wp-13"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   0x3a, 0x1a, 0x2b, 0x1f, 0x6e, 0x0, 0x32, 0x45, 0x52, 0x44, 0x22, 0x55, 0x3a, 0x37, 0x7d, 0x43, 0x7b, 0x23, 0x52, 0x1c, 0x60, 0x46, 0xa, 0x7, 0x56, 0x38, 0x72, 0x79, 0x10, 0x1d, 0x52, 0x4a, 0x2f, 0x75, 0x61, 0x16, 0x75, 0x14, 0x5c, 0x41, 0x58, 0x76</span><br></pre></td></tr></table></figure>

<p>程序主要逻辑</p>
<p><img src="/../images/Patr1ck-wp-14.png" alt="Patr1ck wp-14"></p>
<p><img src="/../images/Patr1ck-wp-15.png" alt="Patr1ck wp-15"></p>
<p>密文</p>
<p><img src="/../images/Patr1ck-wp-16.png" alt="Patr1ck wp-16"></p>
<p>写脚本解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc=[  0x5C, 0x76, 0x4A, 0x78, 0x15, 0x62, 0x05, 0x7C, 0x6B, 0x21,  </span><br><span class="line">  0x40, 0x66, 0x5B, 0x1A, 0x48, 0x7A, 0x1E, 0x46, 0x7F, 0x28,  </span><br><span class="line">  0x02, 0x75, 0x68, 0x2A, 0x34, 0x0C, 0x4B, 0x1D, 0x3D, 0x2E,  </span><br><span class="line">  0x6B, 0x7A, 0x17, 0x45, 0x07, 0x75, 0x47, 0x27, 0x39, 0x78,  </span><br><span class="line">  0x61, 0x0B]  </span><br><span class="line">key=[0x3a, 0x1a, 0x2b, 0x1f, 0x6e, 0x0, 0x32, 0x45, 0x52, 0x44, 0x22, 0x55, 0x3a, 0x37, 0x7d, 0x43, 0x7b, 0x23, 0x52, 0x1c, 0x60, 0x46, 0xa, 0x7, 0x56, 0x38, 0x72, 0x79, 0x10, 0x1d, 0x52, 0x4a, 0x2f, 0x75, 0x61, 0x16, 0x75, 0x14, 0x5c, 0x41, 0x58, 0x76]  </span><br><span class="line">flag=[]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">  flag.append(enc[i]^key[i])  </span><br><span class="line">  print(chr(flag[i]),end=&#x27;&#x27;)</span><br><span class="line">#flag&#123;b799eb3a-59ee-4b3b-b49d-39080fc23e99&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ko0h"><a href="#ko0h" class="headerlink" title="ko0h"></a>ko0h</h1><p>ida打开附件 发现逻辑是base64换码表 解出来是fakeflag 查看左边函数发现TLS0_0 跟进 有很多常规花指令 从上到下去除 这里我不全部贴出来了 好多花</p>
<p><img src="/../images/Patr1ck-wp-17.png" alt="Patr1ck wp-17"></p>
<p>随后开始分析TLS0_0</p>
<p><img src="/../images/Patr1ck-wp-24.png" alt="Patr1ck wp-24"></p>
<p>第一个函数是检测调试器的函数 如果有ida64 od x32dbg等字样则有调试 跟进下面的函数</p>
<p><img src="/../images/Patr1ck-wp-25.png" alt="Patr1ck wp-25"></p>
<p>发现进行了魔改的RC4加密<br>密文</p>
<p><img src="/../images/Patr1ck-wp-27.png" alt="Patr1ck wp-27"></p>
<p>写了个脚本还是没出 猜测key有问题 交叉引用发现key被替换了</p>
<p><img src="/../images/Patr1ck-wp-26.png" alt="Patr1ck wp-26"></p>
<p>写解密脚本求出flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def ksa(key):  </span><br><span class="line">    S = list(range(256))  </span><br><span class="line">    j = 0  </span><br><span class="line">    key_length = len(key)  </span><br><span class="line">    for i in range(256):  </span><br><span class="line">        j = (j + S[i] + key[i % key_length]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">    return S  </span><br><span class="line">def prga(S, length):  </span><br><span class="line">    i = j = 0  </span><br><span class="line">    keystream = []  </span><br><span class="line">    for _ in range(length):  </span><br><span class="line">        i = (i + 1) % 256  </span><br><span class="line">        j = (j + S[i]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">        keystream.append(S[(S[i] + S[j]) % 256])  </span><br><span class="line">    return keystream  </span><br><span class="line">def rc4(key, plaintext):  </span><br><span class="line">    S = ksa(key)  </span><br><span class="line">    keystream = prga(S, len(plaintext))  </span><br><span class="line">    return bytes([(p + k) % 256 for p, k in zip(plaintext, keystream)])  </span><br><span class="line">key = b&quot;DDDDAAAASSSS&quot;  </span><br><span class="line">ciphertext = [0x18, 0x9C, 0x47, 0x3D, 0x3B, 0xE1, 0x29, 0x27, 0x9F, 0x34, 0x83, 0xD5, 0xED, 0xB5,0x6E, 0x59, 0x7F, 0xDE, 0x47, 0xD7, 0x65, 0x3F, 0x7A, 0x33, 0x5B, 0x64, 0xB6, 0xFA, 0x94, 0x55, 0x87, 0x42, 0x20, 0x6, 0xC, 0x69, 0xFE, 0x72, 0xA9, 0xE4, 0xD1, 0x7C]  </span><br><span class="line">decrypted = rc4(key, ciphertext)  </span><br><span class="line">print(decrypted)</span><br><span class="line">#b&#x27;flag&#123;c58868f2-a62a-584b-b1f4-91b9348a9a22&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="ezgo"><a href="#ezgo" class="headerlink" title="ezgo"></a>ezgo</h1><p>ida打开附件 跟进main_main<br>输入为4位</p>
<p><img src="/../images/Patr1ck-wp-33.png" alt="Patr1ck wp-33"></p>
<p>首先进行了一个base64</p>
<p><img src="/../images/Patr1ck-wp-28.png" alt="Patr1ck wp-28"></p>
<p><img src="/../images/Patr1ck-wp-29.png" alt="Patr1ck wp-29"></p>
<p>跟进可以发现最后对密文^0xC</p>
<p><img src="/../images/Patr1ck-wp-30.png" alt="Patr1ck wp-30"></p>
<p>码表也进行了变换 在main_init_0中</p>
<p><img src="/../images/Patr1ck-wp-35.png" alt="Patr1ck wp-35"></p>
<p>这里我用赛博厨子测试了一下 输入四位的情况下 输出都是8位 最后两位是&#x3D;&#x3D; 所以想解开密文 只需要求出前六位即可<br>随后对密码的几位进行异或</p>
<p><img src="/../images/Patr1ck-wp-31.png" alt="Patr1ck wp-31"></p>
<p>最后通过输入的密码解压压缩包</p>
<p><img src="/../images/Patr1ck-wp-32.png" alt="Patr1ck wp-32"></p>
<p>直接写z3 这里当时比赛的时候我约束条件没有考虑周全 导致z3的解出现了错误 我只考虑了用zip的头去跟给定的zip文件头加约束 没考虑到别的条件 还是在赛后学习别的师傅的wp时候发现了错误 至少需要五个约束才可求出正确的password 解出来的值 对应的下标异或回去 在异或0xC 最后base64换表即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from z3 import *  </span><br><span class="line">  </span><br><span class="line">zip_flag = [0x0E, 0xE1, 0xE5, 0xF9, 0x14]  </span><br><span class="line">zip_head = [0x50, 0x4b, 0x03, 0x04, 0x0C]  </span><br><span class="line">enc = [0x01, 0x57, 0x2C, 0x7C, 0xC7, 0x72, 0x20, 0x70, 0xA5, 0x96, 0x21,  </span><br><span class="line">       0xDC, 0xA8, 0x76, 0x69, 0x14, 0xC5, 0x24, 0x25, 0x02, 0xB7, 0x7A,  </span><br><span class="line">       0xFC, 0xF0, 0xC4, 0x49, 0x56, 0xC2, 0xC1, 0x95, 0xEC, 0x26, 0xCC,  </span><br><span class="line">       0xF7, 0xFF, 0x73, 0xE1, 0x3F, 0x84, 0x46, 0xA9, 0xF9, 0x3D, 0x0E,  </span><br><span class="line">       0x45, 0xF1, 0xDA, 0x92, 0xCE, 0x3B, 0x3C, 0xA0, 0x16, 0xBC, 0x2D,  </span><br><span class="line">       0xBD, 0xA4, 0x32, 0x90, 0x62, 0x9D, 0x0C, 0xDE, 0xAD, 0x40, 0xCF,  </span><br><span class="line">       0x4B, 0x4D, 0x6E, 0x79, 0xC8, 0x85, 0xD2, 0xAC, 0x99, 0xE8, 0x1E,  </span><br><span class="line">       0xC9, 0xD4, 0x06, 0x34, 0x66, 0xB8, 0xD3, 0x13, 0xF4, 0x42, 0x1B,  </span><br><span class="line">       0x63, 0x5F, 0x82, 0x5B, 0x91, 0x2A, 0x33, 0x5D, 0xB9, 0x7D, 0xD5,  </span><br><span class="line">       0x6C, 0x0D, 0x28, 0x08, 0x9B, 0x18, 0x2E, 0xA2, 0x67, 0x5A, 0xE6,  </span><br><span class="line">       0x8A, 0x19, 0x50, 0x9C, 0xB1, 0xEF, 0x1F, 0x12, 0xBA, 0x86, 0x83,  </span><br><span class="line">       0x77, 0x60, 0x94, 0xFD, 0xF6, 0x54, 0xBF, 0xA1, 0x93, 0x03, 0xE7,  </span><br><span class="line">       0x58, 0xE5, 0x9A, 0x7F, 0x22, 0xBE, 0xD9, 0x38, 0x27, 0x65, 0xD7,  </span><br><span class="line">       0x23, 0xFB, 0x71, 0xFA, 0x8F, 0xF5, 0x6D, 0x51, 0x9E, 0xD6, 0x8B,  </span><br><span class="line">       0x89, 0x11, 0xCA, 0x0F, 0x8E, 0xCB, 0xB3, 0xBB, 0xF2, 0x87, 0x75,  </span><br><span class="line">       0x5C, 0x2F, 0x98, 0x2B, 0x1C, 0xB4, 0xC6, 0x0A, 0x4C, 0x36, 0x1A,  </span><br><span class="line">       0x15, 0x88, 0x1D, 0xE4, 0xC3, 0x97, 0x53, 0x30, 0x4A, 0x3A, 0xB5,  </span><br><span class="line">       0x61, 0x55, 0xC0, 0xA7, 0xDB, 0x29, 0x68, 0xE2, 0xE0, 0x10, 0x09,  </span><br><span class="line">       0x41, 0x31, 0xF3, 0xAF, 0xB6, 0x6A, 0x6F, 0x00, 0x05, 0x0B, 0xE3,  </span><br><span class="line">       0xD1, 0x8D, 0x47, 0x74, 0x78, 0x7B, 0x64, 0xDD, 0xAB, 0xB0, 0x39,  </span><br><span class="line">       0x37, 0xFE, 0xED, 0x52, 0xCD, 0x81, 0xF8, 0xAA, 0x48, 0x6B, 0xD0,  </span><br><span class="line">       0xEB, 0x8C, 0x44, 0x59, 0x17, 0x9F, 0x4F, 0xB2, 0x35, 0xA3, 0x7E,  </span><br><span class="line">       0xEE, 0x4E, 0xDF, 0xE9, 0x07, 0x43, 0xA6, 0xAE, 0xD8, 0xEA, 0x80,  </span><br><span class="line">       0x3E, 0x04, 0x5E]  </span><br><span class="line">s = Solver()  </span><br><span class="line">pass1, pass2, pass3, pass4, pass5, pass6 = BitVecs(&quot;pass1 pass2 pass3 pass4 pass5 pass6&quot;, 8)  </span><br><span class="line">enc_byte = Array(&#x27;Bytes&#x27;, BitVecSort(8), BitVecSort(8))  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    s.add(enc_byte[BitVecVal(i, 8)] == enc[i])  </span><br><span class="line">  </span><br><span class="line">s.add(zip_flag[0] == zip_head[0] ^ pass1 ^ pass5 ^ enc_byte[pass1])  </span><br><span class="line">s.add(zip_flag[1] == zip_head[1] ^ pass2 ^ pass6 ^ enc_byte[pass2])  </span><br><span class="line">s.add(zip_flag[2] == zip_head[2] ^ pass3 ^ pass5 ^ enc_byte[pass3])  </span><br><span class="line">s.add(zip_flag[3] == zip_head[3] ^ pass4 ^ pass6 ^ enc_byte[pass4])  </span><br><span class="line">s.add(zip_flag[4] == zip_head[4] ^ pass5 ^ pass5 ^ enc_byte[pass5])  </span><br><span class="line">  </span><br><span class="line">s.add(0xB6 == 0x50 ^ pass3 ^ pass5 ^ enc_byte[pass3])  </span><br><span class="line">s.add(0xB6 == 0x4B ^ pass4 ^ pass6 ^ enc_byte[pass4])  </span><br><span class="line">s.add(0x1D == 0x05 ^ pass5 ^ pass5 ^ enc_byte[pass5])  </span><br><span class="line">s.add(0x9F == 0x06 ^ pass6 ^ pass6 ^ enc_byte[pass6])  </span><br><span class="line">  </span><br><span class="line">s.add((pass1 ^ 2) &gt;= 32)  </span><br><span class="line">s.add((pass1 ^ 2) &lt;= 126)  </span><br><span class="line">s.add(pass2 &gt;= 32)  </span><br><span class="line">s.add((pass2) &lt;= 126)  </span><br><span class="line">s.add((pass3 ^ 2) &gt;= 32)  </span><br><span class="line">s.add((pass3 ^ 2) &lt;= 126)  </span><br><span class="line">s.add((pass4 ^ 5) &gt;= 32)  </span><br><span class="line">s.add((pass4 ^ 5) &lt;= 126)  </span><br><span class="line">s.add((pass5 ^ 5) &gt;= 32)  </span><br><span class="line">s.add((pass5 ^ 5) &lt;= 126)  </span><br><span class="line">s.add((pass6 ^ 2) &gt;= 32)  </span><br><span class="line">s.add((pass6 ^ 2) &lt;= 126)  </span><br><span class="line">  </span><br><span class="line">for password in [pass1, pass2, pass3, pass4, pass5, pass6]:  </span><br><span class="line">    s.add(password &gt;= 32)  </span><br><span class="line">    s.add(password &lt;= 126)  </span><br><span class="line">  </span><br><span class="line">if s.check() == sat:  </span><br><span class="line">    m = s.model()  </span><br><span class="line">    # 提取并输出结果  </span><br><span class="line">    keys = [m[pass1].as_long(), m[pass2].as_long(), m[pass3].as_long(),  </span><br><span class="line">            m[pass4].as_long(), m[pass5].as_long(), m[pass6].as_long()]  </span><br><span class="line">    print(&#x27;, &#x27;.join(map(str, keys)))  </span><br><span class="line">  </span><br><span class="line">password = [108, 62, 65, 98, 104, 74]  </span><br><span class="line">password[0]^=2  </span><br><span class="line">password[2]^=2  </span><br><span class="line">password[3]^=5  </span><br><span class="line">password[4]^=5  </span><br><span class="line">password[5]^=2  </span><br><span class="line">for i in range(6):  </span><br><span class="line">    print(chr(password[i] ^ 0xC), end=&#x27;&#x27;)  </span><br><span class="line">print()  </span><br><span class="line">import base64  </span><br><span class="line">import string  </span><br><span class="line">string = &#x27;b2OkaD==&#x27;  </span><br><span class="line">tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">tableNew =    &quot;TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">password = base64.b64decode(string.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">print (password)</span><br><span class="line">#b&#x27;oadi&#x27;</span><br></pre></td></tr></table></figure>

<p>得到密码 输入进去就能打开zip压缩包 打开txt文件就有flag</p>
<p><img src="/../images/Patr1ck-wp-34.png" alt="Patr1ck wp-34"></p>
]]></content>
  </entry>
  <entry>
    <title>2024 春秋杯冬季赛 DAY3 RE wp</title>
    <url>/2025/01/23/2024-%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B-DAY3-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：先把day3的题复现了一下 其他的题目复现完在写一下吧</strong></p>
<h1 id="easyasm"><a href="#easyasm" class="headerlink" title="easyasm"></a>easyasm</h1><p>ida打开附件 根据题目也可以知道是要看汇编的题 </p>
<span id="more"></span>

<p>汇编开头给了两个数据</p>
<p><img src="/../images/Patr1ck-day3-wp-6.png" alt="Patr1ck-day3-wp-6"></p>
<p><img src="/../images/Patr1ck-day3-wp-7.png" alt="Patr1ck-day3-wp-7"></p>
<p>猜测一个密文一个密钥<br>首先对key进行了一个冒泡排序 两个字节一排 提取出来key<br><code>0x2030, 0x3040, 0x4050, 0x1022, 0x2011, 0x1666, 0x1522, 0x8899,   0x4155, 0x4044, 0x4288, 0x3321, 0x6033, 0xFFFF, 0x2221, 0x3366,  0x222C, 0x2CCC, 0x22CC, 0xCC22, 0xC2C2</code><br>随后继续往下看 发现一个 xor</p>
<p><img src="/../images/Patr1ck-day3-wp-8.png" alt="Patr1ck-day3-wp-8"></p>
<p>以大概的逻辑就是密文跟排序后的密钥异或 这里我写了一个脚本验证了一下 用密文的前五位异或一下flag{ 发现结果跟排序后的密钥一致</p>
<p><img src="/../images/Patr1ck-day3-wp-9.png" alt="Patr1ck-day3-wp-9"></p>
<p>直接写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag = &#x27;flag&#123;&#x27;  </span><br><span class="line">enc = [0x44, 0x7C, 0x43, 0x72, 0x1D, 0x72, 0x74, 0x41, 0x05, 0x14,  </span><br><span class="line">       0x19, 0x1A, 0x19, 0x0F, 0xF5, 0x10, 0xAE, 0x18, 0x6D, 0x01,  </span><br><span class="line">       0x10, 0x56, 0x00, 0x1E, 0x26, 0x71, 0x65, 0x73, 0x78, 0x72,  </span><br><span class="line">       0xEB, 0x72, 0x52, 0x06, 0xAA, 0xBB, 0xA3, 0xA4, 0x1B, 0xFC]  </span><br><span class="line">#for i in range(5):  </span><br><span class="line">    #print(hex(enc[i] ^ ord(flag[i])),end=&#x27;,&#x27;)</span><br><span class="line">#print()  </span><br><span class="line">word_10200 = [0x2030, 0x3040, 0x4050, 0x1022, 0x2011, 0x1666, 0x1522,  0x8899, 0x4155, 0x4044, 0x4288, 0x3321, 0x6033, 0xFFFF, 0x2221, 0x3366, 0x222C, 0x2CCC, 0x22CC, 0xCC22, 0xC2C2]  </span><br><span class="line">for i in range(len(word_10200)):  </span><br><span class="line">    for j in range(len(word_10200) - 1 - i):  </span><br><span class="line">        if word_10200[j] &gt; word_10200[j + 1]:  </span><br><span class="line">            word_10200[j], word_10200[j + 1] = word_10200[j + 1], word_10200[j]  </span><br><span class="line">key = []  </span><br><span class="line">for num in word_10200:  </span><br><span class="line">    low = num &amp; 0xFF  </span><br><span class="line">    high = (num &gt;&gt; 8) &amp; 0xFF  </span><br><span class="line">    key.append(low)  </span><br><span class="line">    key.append(high)  </span><br><span class="line">#print(&#x27;,&#x27;.join(hex(x) for x in key))  </span><br><span class="line">enc = [0x44, 0x7C, 0x43, 0x72, 0x1D, 0x72, 0x74, 0x41, 0x05, 0x14,  </span><br><span class="line">       0x19, 0x1A, 0x19, 0x0F, 0xF5, 0x10, 0xAE, 0x18, 0x6D, 0x01,  </span><br><span class="line">       0x10, 0x56, 0x00, 0x1E, 0x26, 0x71, 0x65, 0x73, 0x78, 0x72,  </span><br><span class="line">       0xEB, 0x72, 0x52, 0x06, 0xAA, 0xBB, 0xA3, 0xA4, 0x1B, 0xFC,  </span><br><span class="line">       0xC7, 0x82]  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    flag.append(enc[i] ^ key[i])  </span><br><span class="line">    print(chr(flag[i]), end=&#x27;&#x27;)</span><br><span class="line">#flag&#123;dea54885-92b4-11ef-b153-3c0af33af908&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ooooore"><a href="#ooooore" class="headerlink" title="ooooore"></a>ooooore</h1><p>ida打开附件 全是花指令 一点一点去掉 后来看大佬的wp 发现用010批量去除能更快一点 </p>
<p><img src="/../images/Patr1ck-day3-wp-10.png" alt="Patr1ck-day3-wp-10"></p>
<p>直接在010里全部替换为90 打开就能正确的反编译<br>密文和输入</p>
<p><img src="/../images/Patr1ck-day3-wp-11.png" alt="Patr1ck-day3-wp-11"></p>
<p>交叉引用密文就可以找到最后比较的部分</p>
<p><img src="/../images/Patr1ck-day3-wp-12.png" alt="Patr1ck-day3-wp-12"></p>
<p>随后看字符串时候发现一个RC4的字符</p>
<p><img src="/../images/Patr1ck-day3-wp-13.png" alt="Patr1ck-day3-wp-13"></p>
<p>所以直接在比较的地方打个断点 找加密后的密文 写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;1&quot;*42)  </span><br><span class="line">get=[  0xD6, 0xB0, 0x2E, 0x79, 0xD9, 0xE6, 0x67, 0x8B, 0x13, 0xB7,  </span><br><span class="line">  0x9A, 0x43, 0xFE, 0xE8, 0x29, 0xDD, 0xF8, 0x9E, 0x59, 0x63,  </span><br><span class="line">  0xFC, 0x88, 0xAD, 0x7D, 0x78, 0x61, 0x32, 0x87, 0x9C, 0xD1,  </span><br><span class="line">  0x11, 0xF8, 0x26, 0x6A, 0x91, 0x51, 0x85, 0x52, 0xB5, 0x15,  </span><br><span class="line">  0x82, 0xD1]  </span><br><span class="line">enc=[0x81, 0xED, 0x7E, 0x2F, 0x93, 0xB6, 0x6F, 0x8D, 0x43, 0xE5, 0xC9, 0x11, 0xA9, 0xF4, 0x2B, 0xDB, 0xAD, 0xCB, 0x45, 0x66, 0xFA, 0xDF, 0xA9, 0x61, 0x28, 0x65, 0x31, 0xD7, 0x80, 0xD5, 0x18, 0xFE, 0x25, 0x6E, 0x94, 0x05, 0x83, 0x51, 0xB5, 0x42, 0xD2, 0x9D]  </span><br><span class="line">keystream=[(ord(&quot;1&quot;)^i)&amp;0xff for i in get]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    enc[i]^=keystream[i]  </span><br><span class="line">    enc[i]&amp;=0xff  </span><br><span class="line">print(&quot;&quot;.join(map(chr,enc)))</span><br><span class="line">#flag&#123;a97acbcf-37dd-47f5-a52a-587254e721fa&#125;</span><br></pre></td></tr></table></figure>

<p>赛后看wp的时候 发现是rc4加chacha20 当时没考虑那么多 直接就异或回去了 算是个非预期吧</p>
<h1 id="和谐（复现）"><a href="#和谐（复现）" class="headerlink" title="和谐（复现）"></a>和谐（复现）</h1><p>第一次做鸿蒙的逆向 比赛的时候没找到合适的工具 导致一直没什么思路<br>看完官方wp后 发现使用的工具是<a href="https://github.com/ohos-decompiler/abc-decompiler/releases">https://github.com/ohos-decompiler/abc-decompiler/releases</a></p>
<p>打开附件<br>sm4算法 对着源码看 可以看出 修改了密钥拓展的部分</p>
<p><img src="/../images/Patr1ck-day3-wp-15.png" alt="Patr1ck-day3-wp-15"></p>
<p>写脚本解密即可 脚本我直接参考的官方的wp了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">  </span><br><span class="line">typedef unsigned long ull;  </span><br><span class="line">typedef unsigned int uint;  </span><br><span class="line">typedef unsigned char uchar;  </span><br><span class="line">  </span><br><span class="line">static const uchar Sbox[16][16] = &#123;  </span><br><span class="line">    &#123;0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05&#125;,  </span><br><span class="line">    &#123;0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99&#125;,  </span><br><span class="line">    &#123;0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62&#125;,  </span><br><span class="line">    &#123;0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6&#125;,  </span><br><span class="line">    &#123;0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8&#125;,  </span><br><span class="line">    &#123;0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35&#125;,  </span><br><span class="line">    &#123;0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87&#125;,  </span><br><span class="line">    &#123;0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e&#125;,  </span><br><span class="line">    &#123;0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1&#125;,  </span><br><span class="line">    &#123;0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3&#125;,  </span><br><span class="line">    &#123;0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f&#125;,  </span><br><span class="line">    &#123;0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51&#125;,  </span><br><span class="line">    &#123;0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8&#125;,  </span><br><span class="line">    &#123;0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0&#125;,  </span><br><span class="line">    &#123;0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84&#125;,  </span><br><span class="line">    &#123;0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">ull leftShift(ull x, int n) &#123;  </span><br><span class="line">    return (x &lt;&lt; n) | (x &gt;&gt; (32 - n));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ull chr2int(uchar *chr) &#123;  </span><br><span class="line">    return (chr[0] &lt;&lt; 24) | (chr[1] &lt;&lt; 16) | (chr[2] &lt;&lt; 8) | chr[3];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void int2chr(uchar *chr, ull x) &#123;  </span><br><span class="line">    chr[0] = (x &gt;&gt; 24) &amp; 0xff;  </span><br><span class="line">    chr[1] = (x &gt;&gt; 16) &amp; 0xff;  </span><br><span class="line">    chr[2] = (x &gt;&gt; 8) &amp; 0xff;  </span><br><span class="line">    chr[3] = x &amp; 0xff;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">uint transSboxInt(uint temp)  </span><br><span class="line">&#123;  </span><br><span class="line"> return Sbox[temp&gt;&gt;4][temp&amp;0xf];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">uint transSbox(uint temp) &#123;  </span><br><span class="line">    uint output = 0;  </span><br><span class="line">    for (int i = 3; i &gt; -1; i--) &#123;  </span><br><span class="line">        output = output &lt;&lt; 8;  </span><br><span class="line">        output = output | transSboxInt((temp &gt;&gt; (i * 8)) &amp; 0xff);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return output;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">uint keyTrans(uint temp) &#123;  </span><br><span class="line">    return temp ^ leftShift(temp, 13) ^ leftShift(temp, 23);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">uint trans(uint temp) &#123;  </span><br><span class="line">    temp = transSbox(temp);  </span><br><span class="line">    return temp ^ leftShift(temp, 2) ^ leftShift(temp, 10) ^ leftShift(temp, 18) ^ leftShift(temp, 24);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void keyExtention_new(uchar K[32], uint RK[32]) &#123;  </span><br><span class="line">    uint tk[36];  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        tk[i] = chr2int(K + 4 * i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; 32; i++) &#123;  </span><br><span class="line">        tk[i + 4] = tk[i + 1] ^ tk[i + 2] ^ tk[i + 3];  </span><br><span class="line">        tk[i + 4] = transSbox(tk[i + 4]);  </span><br><span class="line">        tk[i + 4] = keyTrans(tk[i + 4]);  </span><br><span class="line">        tk[i + 4] = tk[i] ^ tk[i + 4];  </span><br><span class="line">        RK[i] = tk[i + 4];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void sm4_encrypt_new(uchar *input, uchar *output, uchar *K) &#123;  </span><br><span class="line">    uint RK[32];  </span><br><span class="line">    keyExtention_new(K, RK);  </span><br><span class="line">    uint X[36];  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        X[i] = chr2int(input + 4 * i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; 32; i++) &#123;  </span><br><span class="line">        X[i + 4] = X[i + 1] ^ X[i + 2] ^ X[i + 3] ^ RK[i];  </span><br><span class="line">        X[i + 4] = trans(X[i + 4]);  </span><br><span class="line">        X[i + 4] = X[i] ^ X[i + 4];  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        output[4 * i] = (X[35 - i] &gt;&gt; 24) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 1] = (X[35 - i] &gt;&gt; 16) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 2] = (X[35 - i] &gt;&gt; 8) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 3] = X[35 - i] &amp; 0xff;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void sm4_decrypt_new(uchar *input, uchar *output, uchar *K) &#123;  </span><br><span class="line">    uint RK[32];  </span><br><span class="line">    keyExtention_new(K, RK);  </span><br><span class="line">    uint X[36];  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        X[35 - i] = chr2int(input + 4 * i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 31; i &gt;= 0; i--) &#123;  </span><br><span class="line">        X[i] = X[i + 1] ^ X[i + 2] ^ X[i + 3] ^ RK[i];  </span><br><span class="line">        X[i] = trans(X[i]);  </span><br><span class="line">        X[i] = X[i + 4] ^ X[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">        output[4 * i] = (X[i] &gt;&gt; 24) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 1] = (X[i] &gt;&gt; 16) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 2] = (X[i] &gt;&gt; 8) &amp; 0xff;  </span><br><span class="line">        output[4 * i + 3] = X[i] &amp; 0xff;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    uchar key[16] = &#123;0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05&#125;;  </span><br><span class="line">    uchar output[48] = &#123;  </span><br><span class="line">        24, 138, 76, 64, 151, 159, 65, 33, 3, 90, 97, 15, 62, 105, 82, 235,  </span><br><span class="line">        77, 240, 241, 90, 84, 179, 185, 34, 158, 119, 185, 189, 120, 106, 13, 138,  </span><br><span class="line">        17, 68, 255, 127, 234, 11, 218, 151, 82, 97, 25, 170, 100, 201, 253, 150,  </span><br><span class="line">    &#125;;  </span><br><span class="line">    uchar input[48] = &#123;0&#125;;  </span><br><span class="line">    for (int i = 0; i &lt; 48; i++) &#123;  </span><br><span class="line">        output[i] = Sbox[output[i] / 16][output[i] % 16];  </span><br><span class="line">    &#125;  </span><br><span class="line">    uchar output2[48] = &#123;0&#125;;  </span><br><span class="line">    for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        sm4_decrypt_new(output + j * 16, output2 + j * 16, key);  </span><br><span class="line">        for (int i = 0; i &lt; 16; i++) &#123;  </span><br><span class="line">            printf(&quot;%c&quot;, output2[j * 16 + i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;n&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>2025 第一届启航杯 RE wp</title>
    <url>/2025/01/27/2025-%E7%AC%AC%E4%B8%80%E5%B1%8A%E5%90%AF%E8%88%AA%E6%9D%AF-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：明天过年了 提前祝各位师傅新年快乐 新的一年所有比赛都能AK！</strong></p>
<h1 id="rainbow"><a href="#rainbow" class="headerlink" title="rainbow"></a>rainbow</h1><p>ida打开附件 发现关键函数</p>
<span id="more"></span>

<p><img src="/../images/rainbow.png" alt="rainbow"></p>
<p>跟进发现主要逻辑就是一个xor 90</p>
<p><img src="/../images/rainbow-1.png" alt="rainbow-1"></p>
<p>密文压缩包里给了 直接赛博厨子跑一下得到flag</p>
<p><img src="/../images/rainbow-2.png" alt="rainbow-2"></p>
<p>QHCTF{a8226103-5a9a-4fa7-abcf-dea438a7ce78}</p>
<h1 id="小明的note"><a href="#小明的note" class="headerlink" title="小明的note"></a>小明的note</h1><p>查壳发现有upx壳 upx -d脱掉</p>
<p><img src="/../images/note.png" alt="note"></p>
<p>ida打开附件 发现逻辑就是将输入的flag跟s2作比较</p>
<p><img src="/../images/note-1.png" alt="note-1"></p>
<p>而s2在上一个函数跟dest和v6做了xor的运算</p>
<p><img src="/../images/note-2.png" alt="note-2"></p>
<p>所以直接起调试 在比较的地方下个断点 直接看s2的值即可</p>
<p><img src="/../images/note-4.png" alt="note-4"></p>
<p><img src="/../images/note-5.png" alt="note-5"></p>
<p>或者也可以模拟一下decrypt的逻辑写一个脚本解密一下s2</p>
<p>密文</p>
<p><img src="/../images/note-3.png" alt="note-3"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc = [  </span><br><span class="line">    0x12, 0x7D, 0xE1, 0x2C, 0x01, 0x4A, 0xC4, 0x45, 0x78, 0x5E,  </span><br><span class="line">    0xC9, 0x46, 0x78, 0x5D, 0x83, 0x0F, 0x37, 0x12, 0xD0, 0x45,  </span><br><span class="line">    0x63, 0x42, 0xD5, 0x57, 0x76, 0x14, 0xDE, 0x06, 0x6E, 0x04,  </span><br><span class="line">    0x8F, 0x3E, 0x50, 0x21, 0xE1, 0x3B, 0x53, 0x72, 0xB7, 0x6C,  </span><br><span class="line">    0x5D, 0x79, 0xF7  </span><br><span class="line">]  </span><br><span class="line">key = 0x7CA13742  </span><br><span class="line">flag = []  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    flag.append((key &gt;&gt; ((i % 4) * 8)) &amp; 0xFF ^ enc[i])  </span><br><span class="line">    flag[i] ^= (i + 1)  </span><br><span class="line">    print(chr(flag[i]), end=&#x27;&#x27;)</span><br><span class="line">#QHCTF&#123;b13cc67d-cd7b-4cc3-9df1-1b34cc4c186d&#125;</span><br></pre></td></tr></table></figure>

<h1 id="checker"><a href="#checker" class="headerlink" title="checker"></a>checker</h1><p>ida打开附件 发现主要函数</p>
<p><img src="/../images/checker.png" alt="checker"></p>
<p>跟进可以发现逻辑就是对输入的flag进行异或0x23</p>
<p><img src="/../images/checker-1.png" alt="checker-1"></p>
<p>密文</p>
<p><img src="/../images/checker-2.png" alt="checker-2"></p>
<p>直接异或回去即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc = [0x72, 0x6B, 0x60, 0x77, 0x65, 0x58, 0x46, 0x46, 0x15, 0x40,  </span><br><span class="line">       0x14, 0x41, 0x1A, 0x40, 0x0E, 0x46, 0x14, 0x45, 0x16, 0x0E,  </span><br><span class="line">       0x17, 0x45, 0x42, 0x41, 0x0E, 0x1A, 0x41, 0x47, 0x45, 0x0E,  </span><br><span class="line">       0x46, 0x42, 0x13, 0x14, 0x46, 0x13, 0x10, 0x17, 0x45, 0x15,  </span><br><span class="line">       0x42, 0x16, 0x5E]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    enc[i] ^= 0x23  </span><br><span class="line">    print(chr(enc[i]), end=&#x27;&#x27;)</span><br><span class="line">#QHCTF&#123;ee6c7b9c-e7f5-4fab-9bdf-ea07e034f6a5&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>2024 春秋杯冬季赛 DAY2 RE wp</title>
    <url>/2025/02/08/2024-%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B-DAY2-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：当时应该是去打西湖了 就没怎么看day2的题 现在来复现一下</strong></p>
<h1 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h1><p>jadx打开附件 发现需要输入用户名和密码</p>
<span id="more"></span>

<p><img src="/../images/Patr1ck-day2-wp-12.png" alt="Patr1ck-day2-wp-12"></p>
<p>用户名校验的部分在native层 密码被加密算法skip32加密 直接看so先找一下用户名</p>
<p><img src="/../images/Patr1ck-day2-wp.png" alt="Patr1ck-day2-wp"></p>
<p>跟进encrypt可以看出是一个DES 修改了sbox</p>
<p><img src="/../images/Patr1ck-day2-wp-13.png" alt="Patr1ck-day2-wp-13"></p>
<p>密文密钥已知 直接本地找个DES的脚本解一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">typedef unsigned char ubyte;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">#define KEY_LEN 8</span><br><span class="line"></span><br><span class="line">typedef ubyte key_t[KEY_LEN];</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">const static ubyte PC1[] = &#123;</span><br><span class="line"></span><br><span class="line">    57, 49, 41, 33, 25, 17,  9,</span><br><span class="line"></span><br><span class="line">    1, 58, 50, 42, 34, 26, 18,</span><br><span class="line"></span><br><span class="line">    10,  2, 59, 51, 43, 35, 27,</span><br><span class="line"></span><br><span class="line">    19, 11,  3, 60, 52, 44, 36,</span><br><span class="line"></span><br><span class="line">    63, 55, 47, 39, 31, 23, 15,</span><br><span class="line"></span><br><span class="line">    7, 62, 54, 46, 38, 30, 22,</span><br><span class="line"></span><br><span class="line">    14,  6, 61, 53, 45, 37, 29,</span><br><span class="line"></span><br><span class="line">    21, 13,  5, 28, 20, 12,  4</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">const static ubyte PC2[] = &#123;</span><br><span class="line"></span><br><span class="line">    14, 17, 11, 24,  1,  5,</span><br><span class="line"></span><br><span class="line">    3, 28, 15,  6, 21, 10,</span><br><span class="line"></span><br><span class="line">    23, 19, 12,  4, 26,  8,</span><br><span class="line"></span><br><span class="line">    16,  7, 27, 20, 13,  2,</span><br><span class="line"></span><br><span class="line">    41, 52, 31, 37, 47, 55,</span><br><span class="line"></span><br><span class="line">    30, 40, 51, 45, 33, 48,</span><br><span class="line"></span><br><span class="line">    44, 49, 39, 56, 34, 53,</span><br><span class="line"></span><br><span class="line">    46, 42, 50, 36, 29, 32</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">const static ubyte IP[] = &#123;</span><br><span class="line"></span><br><span class="line">    58, 50, 42, 34, 26, 18, 10,  2,</span><br><span class="line"></span><br><span class="line">    60, 52, 44, 36, 28, 20, 12,  4,</span><br><span class="line"></span><br><span class="line">    62, 54, 46, 38, 30, 22, 14,  6,</span><br><span class="line"></span><br><span class="line">    64, 56, 48, 40, 32, 24, 16,  8,</span><br><span class="line"></span><br><span class="line">    57, 49, 41, 33, 25, 17,  9,  1,</span><br><span class="line"></span><br><span class="line">    59, 51, 43, 35, 27, 19, 11,  3,</span><br><span class="line"></span><br><span class="line">    61, 53, 45, 37, 29, 21, 13,  5,</span><br><span class="line"></span><br><span class="line">    63, 55, 47, 39, 31, 23, 15,  7</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">const static ubyte E[] = &#123;</span><br><span class="line"></span><br><span class="line">    32,  1,  2,  3,  4,  5,</span><br><span class="line"></span><br><span class="line">    4,  5,  6,  7,  8,  9,</span><br><span class="line"></span><br><span class="line">    8,  9, 10, 11, 12, 13,</span><br><span class="line"></span><br><span class="line">    12, 13, 14, 15, 16, 17,</span><br><span class="line"></span><br><span class="line">    16, 17, 18, 19, 20, 21,</span><br><span class="line"></span><br><span class="line">    20, 21, 22, 23, 24, 25,</span><br><span class="line"></span><br><span class="line">    24, 25, 26, 27, 28, 29,</span><br><span class="line"></span><br><span class="line">    28, 29, 30, 31, 32,  1</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">const static ubyte S[][64] = &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        6, 6, 4, 9, 6, 7, 4, 11, 0, 2, 8, 12, 10, 8, 0, 1, 12, 6, 9, 9, 3, 7, 11, 5, 4, 13, 1, 3, 15, 8, 10, 13, 5, 13, 10, 2, 12, 0, 14, 13, 11, 14, 5, 3, 2, 8, 14, 3, 14, 4, 11, 7, 15, 5, 1, 7, 1, 12, 9, 0, 10, 2, 15, 15</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        10, 2, 4, 8, 12, 15, 3, 10, 4, 8, 3, 4, 14, 5, 7, 15, 15, 8, 0, 7, 9, 4, 13, 0, 5, 8, 11, 14, 6, 2, 2, 6, 13, 9, 2, 3, 10, 7, 1, 9, 5, 15, 1, 11, 9, 14, 13, 11, 7, 12, 12, 5, 1, 10, 14, 6, 6, 0, 0, 12, 3, 1, 11, 13</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        10, 0, 0, 6, 5, 13, 9, 14, 3, 1, 1, 8, 13, 9, 8, 15, 12, 7, 1, 3, 15, 7, 11, 7, 5, 10, 3, 10, 2, 6, 8, 10, 9, 3, 2, 14, 14, 11, 11, 2, 13, 15, 7, 6, 8, 4, 4, 12, 0, 1, 14, 5, 12, 12, 4, 2, 6, 9, 4, 5, 11, 15, 0, 13</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        6, 12, 1, 11, 14, 0, 4, 4, 4, 2, 15, 3, 3, 1, 1, 2, 8, 0, 9, 6, 0, 8, 13, 2, 12, 3, 3, 10, 7, 15, 12, 8, 15, 14, 7, 4, 6, 14, 1, 7, 7, 9, 6, 9, 15, 5, 11, 0, 10, 13, 13, 9, 13, 5, 5, 11, 12, 11, 8, 2, 5, 10, 14, 10</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        5, 5, 7, 9, 9, 13, 0, 5, 6, 11, 12, 5, 4, 15, 0, 12, 11, 13, 13, 10, 8, 2, 13, 3, 3, 14, 14, 6, 9, 3, 0, 7, 10, 9, 7, 8, 10, 2, 1, 0, 6, 14, 15, 8, 14, 15, 2, 1, 7, 6, 15, 10, 3, 12, 12, 4, 1, 8, 4, 11, 2, 1, 11, 4</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        14, 6, 14, 6, 0, 13, 9, 5, 5, 11, 0, 7, 2, 3, 0, 0, 3, 13, 8, 2, 15, 9, 1, 7, 9, 1, 12, 4, 10, 9, 8, 11, 4, 1, 6, 15, 12, 14, 11, 2, 5, 14, 13, 4, 3, 7, 1, 15, 11, 10, 3, 7, 8, 8, 15, 5, 12, 12, 10, 10, 4, 6, 13, 2</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        15, 14, 10, 3, 3, 15, 12, 14, 0, 2, 14, 12, 8, 0, 5, 6, 14, 2, 0, 1, 8, 1, 13, 4, 11, 4, 7, 11, 9, 15, 1, 12, 5, 0, 7, 13, 6, 10, 6, 12, 11, 6, 13, 3, 8, 4, 9, 9, 13, 4, 2, 5, 1, 7, 9, 5, 7, 2, 8, 15, 3, 10, 10, 11</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        4, 7, 4, 15, 0, 5, 9, 14, 8, 11, 13, 0, 7, 3, 1, 2, 1, 6, 7, 5, 12, 4, 13, 13, 8, 1, 5, 12, 11, 9, 5, 11, 6, 10, 3, 1, 15, 14, 14, 15, 9, 9, 15, 2, 12, 12, 14, 0, 4, 8, 6, 3, 11, 7, 3, 6, 10, 2, 0, 2, 8, 10, 10, 13</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">const static ubyte P[] = &#123;</span><br><span class="line"></span><br><span class="line">    16,  7, 20, 21,</span><br><span class="line"></span><br><span class="line">    29, 12, 28, 17,</span><br><span class="line"></span><br><span class="line">    1, 15, 23, 26,</span><br><span class="line"></span><br><span class="line">    5, 18, 31, 10,</span><br><span class="line"></span><br><span class="line">    2,  8, 24, 14,</span><br><span class="line"></span><br><span class="line">    32, 27,  3,  9,</span><br><span class="line"></span><br><span class="line">    19, 13, 30,  6,</span><br><span class="line"></span><br><span class="line">    22, 11,  4, 25</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">const static ubyte IP2[] = &#123;</span><br><span class="line"></span><br><span class="line">    40,  8, 48, 16, 56, 24, 64, 32,</span><br><span class="line"></span><br><span class="line">    39,  7, 47, 15, 55, 23, 63, 31,</span><br><span class="line"></span><br><span class="line">    38,  6, 46, 14, 54, 22, 62, 30,</span><br><span class="line"></span><br><span class="line">    37,  5, 45, 13, 53, 21, 61, 29,</span><br><span class="line"></span><br><span class="line">    36,  4, 44, 12, 52, 20, 60, 28,</span><br><span class="line"></span><br><span class="line">    35,  3, 43, 11, 51, 19, 59, 27,</span><br><span class="line"></span><br><span class="line">    34,  2, 42, 10, 50, 18, 58, 26,</span><br><span class="line"></span><br><span class="line">    33,  1, 41,  9, 49, 17, 57, 25</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">const static ubyte SHIFTS[] = &#123;</span><br><span class="line"></span><br><span class="line">    1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    ubyte *data;</span><br><span class="line"></span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">&#125; String;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Transform a single nibble into a hex character</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* in: a value &lt; 0x10</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* returns: the character that represents the nibble</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static char toHex(ubyte in) &#123;</span><br><span class="line"></span><br><span class="line">    if (0x00 &lt;= in &amp;&amp; in &lt; 0x0A) &#123;</span><br><span class="line"></span><br><span class="line">        return &#x27;0&#x27; + in;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (0x0A &lt;= in &amp;&amp; in &lt;= 0x0F) &#123;</span><br><span class="line"></span><br><span class="line">        return &#x27;A&#x27; + in - 0x0A;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Convert an array of bytes into a string</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* ptr: the array of bytes</span><br><span class="line"></span><br><span class="line">* len: the number of bytes</span><br><span class="line"></span><br><span class="line">* out: a buffer allocated by the caller with enough space for 2*len+1 characters</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static void printBytes(const ubyte *ptr, int len, char *out) &#123;</span><br><span class="line"></span><br><span class="line">    while (len-- &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        *out++ = toHex(*ptr &gt;&gt; 4);</span><br><span class="line"></span><br><span class="line">        *out++ = toHex(*ptr &amp; 0x0F);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        ptr++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *out = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Gets the value of a bit in an array of bytes</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* src: the array of bytes to index</span><br><span class="line"></span><br><span class="line">* index: the desired bit to test the value of</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* returns: the bit at the specified position in the array</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static int peekBit(const ubyte *src, int index) &#123;</span><br><span class="line"></span><br><span class="line">    int cell = index / 8;</span><br><span class="line"></span><br><span class="line">    int bit = 7 - index % 8;</span><br><span class="line"></span><br><span class="line">    return (src[cell] &amp; (1 &lt;&lt; bit)) != 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Sets the value of a bit in an array of bytes</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* dst: the array of bits to set a bit in</span><br><span class="line"></span><br><span class="line">* index: the position of the bit to set</span><br><span class="line"></span><br><span class="line">* value: the value for the bit to set</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static void pokeBit(ubyte *dst, int index, int value) &#123;</span><br><span class="line"></span><br><span class="line">    int cell = index / 8;</span><br><span class="line"></span><br><span class="line">    int bit = 7 - index % 8;</span><br><span class="line"></span><br><span class="line">    if (value == 0) &#123;</span><br><span class="line"></span><br><span class="line">        dst[cell] &amp;= ~(1 &lt;&lt; bit);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line"></span><br><span class="line">        dst[cell] |= (1 &lt;&lt; bit);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Transforms one array of bytes by shifting the bits the specified number of positions</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* src: the array to shift bits from</span><br><span class="line"></span><br><span class="line">* len: the length of the src array</span><br><span class="line"></span><br><span class="line">* times: the number of positions that the bits should be shifted</span><br><span class="line"></span><br><span class="line">* dst: a bytes array allocated by the caller to store the shifted values</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static void shiftLeft(const ubyte *src, int len, int times, ubyte *dst) &#123;</span><br><span class="line"></span><br><span class="line">    int i, t;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt;= len; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(dst, i, peekBit(src, i));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (t = 1; t &lt;= times; ++t) &#123;</span><br><span class="line"></span><br><span class="line">        int temp = peekBit(dst, 0);</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt;= len; ++i) &#123;</span><br><span class="line"></span><br><span class="line">            pokeBit(dst, i - 1, peekBit(dst, i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pokeBit(dst, len - 1, temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Calculates the sub keys to be used in processing the messages</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* key: the array of bytes representing the key</span><br><span class="line"></span><br><span class="line">* ks: the subkeys that have been allocated by the caller</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">typedef ubyte subkey_t[17][6]; /* 17 sets of 48 bits */</span><br><span class="line"></span><br><span class="line">static void getSubKeys(const key_t key, subkey_t ks) &#123;</span><br><span class="line"></span><br><span class="line">    ubyte c[17][7];  /* 56 bits */</span><br><span class="line"></span><br><span class="line">    ubyte d[17][4];  /* 28 bits */</span><br><span class="line"></span><br><span class="line">    ubyte kp[7];</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* intialize */</span><br><span class="line"></span><br><span class="line">    memset(c, 0, sizeof(c));</span><br><span class="line"></span><br><span class="line">    memset(d, 0, sizeof(d));</span><br><span class="line"></span><br><span class="line">    memset(ks, 0, sizeof(subkey_t));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* permute &#x27;key&#x27; using table PC1 */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 56; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(kp, i, peekBit(key, PC1[i] - 1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* split &#x27;kp&#x27; in half and process the resulting series of &#x27;c&#x27; and &#x27;d&#x27; */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 28; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(c[0], i, peekBit(kp, i));</span><br><span class="line"></span><br><span class="line">        pokeBit(d[0], i, peekBit(kp, i + 28));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* shift the components of c and d */</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; 17; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        shiftLeft(c[i - 1], 28, SHIFTS[i - 1], c[i]);</span><br><span class="line"></span><br><span class="line">        shiftLeft(d[i - 1], 28, SHIFTS[i - 1], d[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* merge &#x27;d&#x27; into &#x27;c&#x27; */</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; 17; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        for (j = 28; j &lt; 56; ++j) &#123;</span><br><span class="line"></span><br><span class="line">            pokeBit(c[i], j, peekBit(d[i], j - 28));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* form the sub-keys and store them in &#x27;ks&#x27;</span><br><span class="line"></span><br><span class="line">    * permute &#x27;c&#x27; using table PC2 */</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; 17; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        for (j = 0; j &lt; 48; ++j) &#123;</span><br><span class="line"></span><br><span class="line">            pokeBit(ks[i], j, peekBit(c[i], PC2[j] - 1));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Function used in processing the messages</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* r: an array of bytes to be processed</span><br><span class="line"></span><br><span class="line">* ks: one of the subkeys to be used for processing</span><br><span class="line"></span><br><span class="line">* sp: output from the processing</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static void f(ubyte *r, ubyte *ks, ubyte *sp) &#123;</span><br><span class="line"></span><br><span class="line">    ubyte er[6]; /* 48 bits */</span><br><span class="line"></span><br><span class="line">    ubyte sr[4]; /* 32 bits */</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* initialize */</span><br><span class="line"></span><br><span class="line">    memset(er, 0, sizeof(er));</span><br><span class="line"></span><br><span class="line">    memset(sr, 0, sizeof(sr));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* permute &#x27;r&#x27; using table E */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 48; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(er, i, peekBit(r, E[i] - 1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* xor &#x27;er&#x27; with &#x27;ks&#x27; and store back into &#x27;er&#x27; */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 6; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        er[i] ^= ks[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* process &#x27;er&#x27; six bits at a time and store resulting four bits in &#x27;sr&#x27; */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 8; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        int j = i * 6;</span><br><span class="line"></span><br><span class="line">        int b[6];</span><br><span class="line"></span><br><span class="line">        int k, row, col, m, n;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        for (k = 0; k &lt; 6; ++k) &#123;</span><br><span class="line"></span><br><span class="line">            b[k] = peekBit(er, j + k) != 0 ? 1 : 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        row = 2 * b[0] + b[5];</span><br><span class="line"></span><br><span class="line">        col = 8 * b[1] + 4 * b[2] + 2 * b[3] + b[4];</span><br><span class="line"></span><br><span class="line">        m = S[i][row * 16 + col]; /* apply table s */</span><br><span class="line"></span><br><span class="line">        n = 1;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        while (m &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            int p = m % 2;</span><br><span class="line"></span><br><span class="line">            pokeBit(sr, (i + 1) * 4 - n, p == 1);</span><br><span class="line"></span><br><span class="line">            m /= 2;</span><br><span class="line"></span><br><span class="line">            n++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* permute sr using table P */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(sp, i, peekBit(sr, P[i] - 1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Processing of block of the message</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* message: an 8 byte block from the message</span><br><span class="line"></span><br><span class="line">* ks: the subkeys to use in processing</span><br><span class="line"></span><br><span class="line">* ep: space for an encoded 8 byte block allocated by the caller</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static void processMessage(const ubyte *message, subkey_t ks, ubyte *ep) &#123;</span><br><span class="line"></span><br><span class="line">    ubyte left[17][4];  /* 32 bits */</span><br><span class="line"></span><br><span class="line">    ubyte right[17][4]; /* 32 bits */</span><br><span class="line"></span><br><span class="line">    ubyte mp[8];        /* 64 bits */</span><br><span class="line"></span><br><span class="line">    ubyte e[8];         /* 64 bits */</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* permute &#x27;message&#x27; using table IP */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 64; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(mp, i, peekBit(message, IP[i] - 1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* split &#x27;mp&#x27; in half and process the resulting series of &#x27;l&#x27; and &#x27;r */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(left[0], i, peekBit(mp, i));</span><br><span class="line"></span><br><span class="line">        pokeBit(right[0], i, peekBit(mp, i + 32));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; 17; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        ubyte fs[4]; /* 32 bits */</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        memcpy(left[i], right[i - 1], 4);</span><br><span class="line"></span><br><span class="line">        f(right[i - 1], ks[i], fs);</span><br><span class="line"></span><br><span class="line">        for (j = 0; j &lt; 4; ++j) &#123;</span><br><span class="line"></span><br><span class="line">            left[i - 1][j] ^= fs[j];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memcpy(right[i], left[i - 1], 4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* amalgamate r[16] and l[16] (in that order) into &#x27;e&#x27; */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(e, i, peekBit(right[16], i));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 32; i &lt; 64; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(e, i, peekBit(left[16], i - 32));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* permute &#x27;e&#x27; using table IP2 ad return result as a hex string */</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 64; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        pokeBit(ep, i, peekBit(e, IP2[i] - 1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Encrypts a message using DES</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* key: the key to use to encrypt the message</span><br><span class="line"></span><br><span class="line">* message: the message to be encrypted</span><br><span class="line"></span><br><span class="line">* len: the length of the message</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* returns: a paring of dynamically allocated memory for the encoded message,</span><br><span class="line"></span><br><span class="line">*          and the length of the encoded message.</span><br><span class="line"></span><br><span class="line">*          the caller will need to free the memory after use.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">String encrypt(const key_t key, const ubyte *message, int len) &#123;</span><br><span class="line"></span><br><span class="line">    String result = &#123; 0, 0 &#125;;</span><br><span class="line"></span><br><span class="line">    subkey_t ks;</span><br><span class="line"></span><br><span class="line">    ubyte padByte;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    getSubKeys(key, ks);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    padByte = 8 - len % 8;</span><br><span class="line"></span><br><span class="line">    result.len = len + padByte;</span><br><span class="line"></span><br><span class="line">    result.data = (ubyte*)malloc(result.len);</span><br><span class="line"></span><br><span class="line">    memcpy(result.data, message, len);</span><br><span class="line"></span><br><span class="line">    memset(&amp;result.data[len], padByte, padByte);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; result.len; i += 8) &#123;</span><br><span class="line"></span><br><span class="line">        processMessage(&amp;result.data[i], ks, &amp;result.data[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Decrypts a message using DES</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* key: the key to use to decrypt the message</span><br><span class="line"></span><br><span class="line">* message: the message to be decrypted</span><br><span class="line"></span><br><span class="line">* len: the length of the message</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">* returns: a paring of dynamically allocated memory for the decoded message,</span><br><span class="line"></span><br><span class="line">*          and the length of the decoded message.</span><br><span class="line"></span><br><span class="line">*          the caller will need to free the memory after use.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">String decrypt(const key_t key, const ubyte *message, int len) &#123;</span><br><span class="line"></span><br><span class="line">    String result = &#123; 0, 0 &#125;;</span><br><span class="line"></span><br><span class="line">    subkey_t ks;</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    ubyte padByte;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    getSubKeys(key, ks);</span><br><span class="line"></span><br><span class="line">    /* reverse the subkeys */</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; 9; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        for (j = 0; j &lt; 6; ++j) &#123;</span><br><span class="line"></span><br><span class="line">            ubyte temp = ks[i][j];</span><br><span class="line"></span><br><span class="line">            ks[i][j] = ks[17 - i][j];</span><br><span class="line"></span><br><span class="line">            ks[17 - i][j] = temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    result.data = (ubyte*)malloc(len);</span><br><span class="line"></span><br><span class="line">    memcpy(result.data, message, len);</span><br><span class="line"></span><br><span class="line">    result.len = len;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; result.len; i += 8) &#123;</span><br><span class="line"></span><br><span class="line">        processMessage(&amp;result.data[i], ks, &amp;result.data[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    padByte = result.data[len - 1];</span><br><span class="line"></span><br><span class="line">    result.len -= padByte;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* Convienience method for showing the round trip processing of a message</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void driver(const key_t key, const ubyte *message, int len) &#123;</span><br><span class="line"></span><br><span class="line">    String encoded, decoded;</span><br><span class="line"></span><br><span class="line">    char buffer[128];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    printBytes(key, KEY_LEN, buffer);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Key     : %s\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    printBytes(message, len, buffer);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Message : %s\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    encoded = encrypt(key, message, len);</span><br><span class="line"></span><br><span class="line">    printBytes(encoded.data, encoded.len, buffer);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Encoded : %s\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    decoded = decrypt(key, encoded.data, encoded.len);</span><br><span class="line"></span><br><span class="line">    printBytes(decoded.data, decoded.len, buffer);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Decoded : %s\n\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    /* release allocated memory */</span><br><span class="line"></span><br><span class="line">    if (encoded.len &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        free(encoded.data);</span><br><span class="line"></span><br><span class="line">        encoded.data = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (decoded.len &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        free(decoded.data);</span><br><span class="line"></span><br><span class="line">        decoded.data = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------------------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    String decoded;</span><br><span class="line"></span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    //密钥</span><br><span class="line"></span><br><span class="line">    const key_t key = &#123;107, 101, 121, 33, 107, 101, 121, 33 &#125;;</span><br><span class="line"></span><br><span class="line">    //密文</span><br><span class="line"></span><br><span class="line">    const ubyte data[] = &#123;125, 234, 224, 219, 27, 214, 109, 85, 209, 233, 192, 113, 12, 1, 19, 43&#125;;</span><br><span class="line"></span><br><span class="line">    //密文长度</span><br><span class="line"></span><br><span class="line">    len = sizeof(data) / sizeof(ubyte);</span><br><span class="line"></span><br><span class="line">    decoded = decrypt(key, data, len);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Decoded:%s\n&quot;, decoded.data);</span><br><span class="line"></span><br><span class="line">    //释放内存</span><br><span class="line"></span><br><span class="line">    if (decoded.len &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        free(decoded.data);</span><br><span class="line"></span><br><span class="line">        decoded.data = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//sd77cfe8</span><br></pre></td></tr></table></figure>

<p>然后开始解skip32 网上找了一套python的源码 这里做了一个魔改 修改了一下key的长度 原本的skip32的key是10字节 这里修改为8字节 所以修改一下脚本 但是直接解没有解开 于是看一下so文件 发现对FTABLE进行了一些操作 修改了他原本的值</p>
<p><img src="/../images/Patr1ck-day2-wp-15.png" alt="Patr1ck-day2-wp-15"></p>
<p>所以hook一下这个FTABLE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    let Skip32 = Java.use(&quot;com.ex.skip.Skip32&quot;);</span><br><span class="line"></span><br><span class="line">    var FTABLE = Skip32.FTABLE.value;</span><br><span class="line"></span><br><span class="line">    console.log(FTABLE);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>164,216,10,132,249,73,247,245,180,34,22,121,154,178,176,250,232,46,78,139,207,77,203,47,83,150,218,31,79,57,69,41,11,224,3,161,24,242,97,105,19,184,123,196,234,251,62,84,151,133,108,187,243,100,155,26,125,175,230,246,248,23,107,163,58,183,124,16,194,148,130,28,239,181,27,235,209,146,48,185,86,186,219,134,64,66,192,225,91,89,129,96,103,12,217,145,54,214,193,168,52,7,102,106,70,1,149,87,110,153,156,119,152,253,179,195,177,255,220,33,226,236,215,229,222,72,75,30,67,238,159,111,74,61,206,68,40,211,8,213,223,200,104,25,138,204,49,32,142,199,144,171,201,117,221,202,94,93,50,165,113,137,98,45,160,14,44,136,81,131,85,101,39,126,4,65,53,76,29,116,210,197,254,60,205,252,128,172,231,63,92,166,174,5,36,157,21,82,35,241,42,122,114,127,0,141,15,227,13,240,189,115,118,112,56,162,237,212,143,99,140,135,17,233,9,120,18,191,147,80,37,198,51,55,158,208,244,167,188,173,95,109,170,20,88,38,182,228,190,169,59,2,6,90,43,71</code></p>
<p>再去解密还是解不开 运行了一下之前解密用户名的脚本 发现每次生成用户名的第一个字符不一样</p>
<p><img src="/../images/Patr1ck-day2-wp-14.png" alt="Patr1ck-day2-wp-14"></p>
<p>这里我直接暴力猜测第一个字符了 从0开始 尝试到7的时候 发现可以正确解出密码 所以用户名就是7d77cfe8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct  </span><br><span class="line">FTABLE = (  </span><br><span class="line">    164, 216, 10, 132, 249, 73, 247, 245, 180, 34, 22, 121, 154, 178, 176, 250, 232, 46, 78, 139, 207, 77, 203, 47, 83, 150,  </span><br><span class="line">    218, 31, 79, 57, 69, 41, 11, 224, 3, 161, 24, 242, 97, 105, 19, 184, 123, 196, 234, 251, 62, 84, 151, 133, 108, 187,  </span><br><span class="line">    243, 100, 155, 26, 125, 175, 230, 246, 248, 23, 107, 163, 58, 183, 124, 16, 194, 148, 130, 28, 239, 181, 27, 235, 209,  </span><br><span class="line">    146, 48, 185, 86, 186, 219, 134, 64, 66, 192, 225, 91, 89, 129, 96, 103, 12, 217, 145, 54, 214, 193, 168, 52, 7, 102,  </span><br><span class="line">    106, 70, 1, 149, 87, 110, 153, 156, 119, 152, 253, 179, 195, 177, 255, 220, 33, 226, 236, 215, 229, 222, 72, 75, 30, 67,  </span><br><span class="line">    238, 159, 111, 74, 61, 206, 68, 40, 211, 8, 213, 223, 200, 104, 25, 138, 204, 49, 32, 142, 199, 144, 171, 201, 117, 221,  </span><br><span class="line">    202, 94, 93, 50, 165, 113, 137, 98, 45, 160, 14, 44, 136, 81, 131, 85, 101, 39, 126, 4, 65, 53, 76, 29, 116, 210, 197,  </span><br><span class="line">    254, 60, 205, 252, 128, 172, 231, 63, 92, 166, 174, 5, 36, 157, 21, 82, 35, 241, 42, 122, 114, 127, 0, 141, 15, 227, 13,  </span><br><span class="line">    240, 189, 115, 118, 112, 56, 162, 237, 212, 143, 99, 140, 135, 17, 233, 9, 120, 18, 191, 147, 80, 37, 198, 51, 55, 158,  </span><br><span class="line">    208, 244, 167, 188, 173, 95, 109, 170, 20, 88, 38, 182, 228, 190, 169, 59, 2, 6, 90, 43, 71)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def g(key, k, w):  </span><br><span class="line">    g1 = 0xFF &amp; (w &gt;&gt; 8)  </span><br><span class="line">    g2 = 0xFF &amp; w  </span><br><span class="line">  </span><br><span class="line">    g3 = FTABLE[g2 ^ key[(4 * k + 0) % 8]] ^ g1  </span><br><span class="line">    g4 = FTABLE[g3 ^ key[(4 * k + 1) % 8]] ^ g2  </span><br><span class="line">    g5 = FTABLE[g4 ^ key[(4 * k + 2) % 8]] ^ g3  </span><br><span class="line">    g6 = FTABLE[g5 ^ key[(4 * k + 3) % 8]] ^ g4  </span><br><span class="line">  </span><br><span class="line">    return ((g5 &lt;&lt; 8) + g6)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def skip32(key, buf, encrypt):  </span><br><span class="line">    # sort out direction  </span><br><span class="line">    if encrypt:  </span><br><span class="line">        k, step = 0, 1  </span><br><span class="line">    else:  </span><br><span class="line">        k, step = 23, -1  </span><br><span class="line">  </span><br><span class="line">    # pack into words  </span><br><span class="line">    wl = (buf[0] &lt;&lt; 8) + buf[1]  </span><br><span class="line">    wr = (buf[2] &lt;&lt; 8) + buf[3]  </span><br><span class="line">  </span><br><span class="line">    # 24 feistel rounds, doubled up  </span><br><span class="line">    for _ in range(12):  </span><br><span class="line">        wr ^= g(key, k, wl) ^ k  </span><br><span class="line">        k += step  </span><br><span class="line">        wl ^= g(key, k, wr) ^ k  </span><br><span class="line">        k += step  </span><br><span class="line">  </span><br><span class="line">    # implicitly swap halves while unpacking  </span><br><span class="line">    buf[0] = (wr &gt;&gt; 8)  </span><br><span class="line">    buf[1] = (wr &amp; 0xFF)  </span><br><span class="line">    buf[2] = (wl &gt;&gt; 8)  </span><br><span class="line">    buf[3] = (wl &amp; 0xFF)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def decrypt(key, value):  </span><br><span class="line">    buf = [  </span><br><span class="line">        (value &gt;&gt; 24) &amp; 0xff,  </span><br><span class="line">        (value &gt;&gt; 16) &amp; 0xff,  </span><br><span class="line">        (value &gt;&gt; 8) &amp; 0xff,  </span><br><span class="line">        (value &gt;&gt; 0) &amp; 0xff,  </span><br><span class="line">    ]  </span><br><span class="line">    skip32(key, buf, False)  </span><br><span class="line">    return (buf[0] &lt;&lt; 24) | (buf[1] &lt;&lt; 16) | (buf[2] &lt;&lt; 8) | buf[3]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">key = b&quot;7d77cfe8&quot;  </span><br><span class="line">encrypted = [52, 142, 226, 172, 108, 94, 80, 51, 11, 251, 68, 164, 231, 6, 124, 223, 100, 62, 116, 70]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"># Decrypt the encrypted values  </span><br><span class="line">for i in range(0, 20, 4):  </span><br><span class="line">    password = (encrypted[i] &lt;&lt; 24) | (encrypted[i + 1] &lt;&lt; 16) | (encrypted[i + 2] &lt;&lt; 8) | (encrypted[i + 3])  </span><br><span class="line">    decrypted_password = decrypt(key,password)  </span><br><span class="line">    encrypted[i] = (decrypted_password &gt;&gt; 24) &amp; 0xff  </span><br><span class="line">    encrypted[i + 1] = (decrypted_password &gt;&gt; 16) &amp; 0xff  </span><br><span class="line">    encrypted[i + 2] = (decrypted_password &gt;&gt; 8) &amp; 0xff  </span><br><span class="line">    encrypted[i + 3] = decrypted_password &amp; 0xff  </span><br><span class="line">  </span><br><span class="line">result = &#x27;&#x27;.join(chr(password) for password in encrypted)  </span><br><span class="line">print(result)  </span><br><span class="line">#c58b6a2f988bc9434a45</span><br></pre></td></tr></table></figure>

<p>成功拿到flag</p>
<p><img src="/../images/Patr1ck-day2-wp-16.png" alt="Patr1ck-day2-wp-16"></p>
<h1 id="Nu1tka"><a href="#Nu1tka" class="headerlink" title="Nu1tka"></a>Nu1tka</h1><p>逻辑很简单 调试过程很折磨人<br>ida打开附件 发现是一个跳板程序 直接打个断点找到真正的程序</p>
<p><img src="/../images/Patr1ck-day2-wp-17.png" alt="Patr1ck-day2-wp-17"></p>
<p><img src="/../images/Patr1ckday2wp-17.png" alt="Patr1ckday2wp-17"></p>
<p>dump下来 ida打开dump下来的Nu1tka.exe 交叉引用_main_字符串以及动态调试 定位到关键函数</p>
<p><img src="/../images/Patr1ckday2wp-18.png" alt="Patr1ckday2wp-18"></p>
<p>随后一点一点看 分析main_0<br>这里计算了长度并且比较 得知flag长度是40</p>
<p><img src="/../images/Patr1ckday2wp-19.png" alt="Patr1ckday2wp-19"></p>
<p><img src="/../images/Patr1ckday2wp-20.png" alt="Patr1ckday2wp-20"></p>
<p>这里将输入的flag每4位转化为bytes 所以key跟enc应该是每个数组10个元素</p>
<p><img src="/../images/Patr1ckday2wp-21.png" alt="Patr1ckday2wp-21"></p>
<p>经过反复的调试 找到enc跟key 提取出来</p>
<p><img src="/../images/Patr1ckday2wp-22.png" alt="Patr1ckday2wp-22"></p>
<p>最后的加密 enc跟key异或</p>
<p><img src="/../images/Patr1ckday2wp-23.png" alt="Patr1ckday2wp-23"></p>
<p>写脚本求一下<br>发现有别的多余的字符 在程序中没发现别的运算 只有xor 所以根据文件头计算一下那些乱码异或的值 得到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *  </span><br><span class="line">key = [0x35138033, 0x185A0194, 0x34C41B8F, 0x0B1E6089, 0x0DB7419B, 0x1C6873F3, 0x049FAA92, 0x30D6B47E, 0x23AD4395, 0x33EA34C7]  </span><br><span class="line">enc = [0x1272EC55, 0x286F64EF, 0x0CA02DED, 0x3A2A4DEF, 0x299A25FA, 0x310B4BC2, 0x22A89BF4, 0x12E28553, 0x109920A3, 0x0EDD52A6]  </span><br><span class="line">flag = &quot;&quot;.join(long_to_bytes(e ^ k)[::-1].decode(&#x27;utf-8&#x27;) for e, k in zip(enc, key))  </span><br><span class="line">print(flag)  </span><br><span class="line">print((ord(&#x27;=&#x27;) ^ ord(&#x27;&#125;&#x27;)))  # 64  </span><br><span class="line">for c in &quot;\&#x27;$&amp;\&quot;&quot;:  </span><br><span class="line">    print(chr(ord(c) ^ 64))  </span><br><span class="line">#flag&#123;e50b6d8f-41ad-d18c-f17f-14b6c43af7&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>2025 BroncoCTF RE wp</title>
    <url>/2025/02/17/2025-BroncoCTF-RE-wp/</url>
    <content><![CDATA[<h1 id="Break-the-Battalion"><a href="#Break-the-Battalion" class="headerlink" title="Break the Battalion"></a>Break the Battalion</h1><p>签到题 ida打开附件 逻辑就是跟0x50异或</p>
<span id="more"></span>

<p><img src="/../images/BreaktheBattalion-1.png" alt="BreaktheBattalion-1"></p>
<p>密文是brigade</p>
<p><img src="/../images/BreaktheBattalion.png" alt="BreaktheBattalion"></p>
<p>赛博厨子跑一下得到flag</p>
<p><img src="/../images/BreaktheBattalion-2.png" alt="BreaktheBattalion-2"></p>
<p><img src="/../images/BreaktheBattalion-3.png" alt="BreaktheBattalion-3"></p>
<p>bronco{2&quot;97145}</p>
<h1 id="Reversing-for-Ophidiophiles"><a href="#Reversing-for-Ophidiophiles" class="headerlink" title="Reversing for Ophidiophiles"></a>Reversing for Ophidiophiles</h1><p>附件给了加密和key 先加在异或 </p>
<p><img src="/../images/ReversingforOphidiophiles.png" alt="ReversingforOphidiophiles"></p>
<p>题目描述给了密文 23a326c27bee9b40885df97007aa4dbe410e93<br>直接写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc = &#x27;23a326c27bee9b40885df97007aa4dbe410e93&#x27;  </span><br><span class="line">enc_bytes = bytes.fromhex(enc)  </span><br><span class="line">key = &#x27;Awesome!&#x27;  </span><br><span class="line">carry = 0  </span><br><span class="line">flag = []  </span><br><span class="line">for i, val in enumerate(enc_bytes):  </span><br><span class="line">    val ^= ord(key[i % len(key)])  </span><br><span class="line">    val -= carry  </span><br><span class="line">    val %= 256  </span><br><span class="line">    flag.append(chr(val))  </span><br><span class="line">    carry += val  </span><br><span class="line">    carry %= 256  </span><br><span class="line">print(&quot;&quot;.join(flag))</span><br><span class="line">#bronco&#123;charge_away&#125;</span><br></pre></td></tr></table></figure>

<h1 id="theflagishere"><a href="#theflagishere" class="headerlink" title="theflagishere!"></a>theflagishere!</h1><p>pyc的逆向 找个在线网站反编译一下 直接扔给deepseek跑一下 得到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 计算各个字符函数的结果并调整ASCII值  </span><br><span class="line">def get_flag():  </span><br><span class="line">    flag = [&#x27;&#x27;] * 11  # 假设flag长度为11  </span><br><span class="line">  </span><br><span class="line">    # char_0 → 0号位  </span><br><span class="line">    flag[0] = chr(ord(char_0()) - 1)  </span><br><span class="line">  </span><br><span class="line">    # char_1_4_6 → 1、4、6号位  </span><br><span class="line">    c = chr(ord(char_1_4_6()) - 1)  </span><br><span class="line">    flag[1] = flag[4] = flag[6] = c  </span><br><span class="line">  </span><br><span class="line">    # char_2_5_9 → 2、5、9号位  </span><br><span class="line">    c = chr(ord(char_2_5_9()) - 1)  </span><br><span class="line">    flag[2] = flag[5] = flag[9] = c  </span><br><span class="line">  </span><br><span class="line">    # char_3 → 3号位  </span><br><span class="line">    flag[3] = char_3()  </span><br><span class="line">  </span><br><span class="line">    # char_7 → 7号位  </span><br><span class="line">    flag[7] = chr(ord(char_7()) - 1)  </span><br><span class="line">  </span><br><span class="line">    # char_8 → 8号位  </span><br><span class="line">    flag[8] = chr(ord(char_8()) - 1)  </span><br><span class="line">  </span><br><span class="line">    # char_10 → 10号位  </span><br><span class="line">    flag[10] = chr(ord(char_10()) - 1)  </span><br><span class="line">  </span><br><span class="line">    return &#x27;&#x27;.join(flag)  </span><br><span class="line">    </span><br><span class="line"># char_0 → &#x27;j&#x27; → &#x27;i&#x27;  </span><br><span class="line"># char_1_4_6 → &#x27;`&#x27; → &#x27;_&#x27;  </span><br><span class="line"># char_2_5_9 → &#x27;b&#x27; → &#x27;a&#x27;  </span><br><span class="line"># char_3 → &#x27;m&#x27;  </span><br><span class="line"># char_7 → &#x27;g&#x27; → &#x27;f&#x27;  </span><br><span class="line"># char_8 → &#x27;m&#x27; → &#x27;l&#x27;  </span><br><span class="line"># char_10 → &#x27;h&#x27; → &#x27;g&#x27;  </span><br><span class="line">  </span><br><span class="line">flag = &quot;i_am_a_flag&quot;  </span><br><span class="line">print(flag)</span><br><span class="line">#bronco&#123;i_am_a_flag&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sus"><a href="#sus" class="headerlink" title="sus"></a>sus</h1><p>打开附件 得到的是一堆自定义的宏 将标准的C++关键字和标识符替换为非标准的术语进行混淆</p>
<p><img src="/../images/sus.png" alt="sus"></p>
<p>借助AI还原一下原来大概的代码 随后手动修改一下 逻辑大概是cook函数通过调用rando so_rando L high函数对初始化的字符串进行解密 一共解密八次 解密一次恢复一个字符 手动修复一下AI复原的代码 直接运行即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义 Flag 类</span><br><span class="line"></span><br><span class="line">class Flag &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    string flag = &quot;bronco&#123;abcdefgh&#125;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// 定义 sigmas 数组</span><br><span class="line"></span><br><span class="line">int sigmas[10][4] = &#123;</span><br><span class="line"></span><br><span class="line">    &#123;354, 859, 63143, 63863&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;441, 1117, 1074, 1612&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;491, 877, 7979, 1331&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;518, 859, 63143, 63863&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;204, 859, 631, 6386&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;197, 967, 223647, 5423434&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;69, 223, 5632, 4195&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;226, 1013, 71733, 29271&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;10, 211, 6314, 6386&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;504, 599, 7454, 7049&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// 声明 flag 对象</span><br><span class="line"></span><br><span class="line">Flag flag;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// rando 函数，用于处理某些数值计算</span><br><span class="line"></span><br><span class="line">int rando(int yeet) &#123;</span><br><span class="line"></span><br><span class="line">    int giving = 0;</span><br><span class="line"></span><br><span class="line">    int bet = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; ; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (yeet &lt; pow(10, giving)) &#123;</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        giving += 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yeet *= yeet ;</span><br><span class="line"></span><br><span class="line">    if ( giving % 2 == 0 )</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        yeet *= 10 ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string iykyk;</span><br><span class="line"></span><br><span class="line">    for (int bet = 0; yeet &gt; 0; yeet /= 10, bet++) &#123;</span><br><span class="line"></span><br><span class="line">        if (bet &gt; giving / 2) &#123;</span><br><span class="line"></span><br><span class="line">            if (bet - 1 &lt; giving / 2 + giving) &#123;</span><br><span class="line"></span><br><span class="line">                iykyk.insert(0, 1, &#x27;0&#x27; + yeet % 10);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    for (int bet = 0; giving &gt; 0; giving--, bet++) &#123;</span><br><span class="line"></span><br><span class="line">        yeet += (iykyk[giving - 1] - &#x27;0&#x27;) * pow(10, bet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    return yeet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//decode函数，用于解密</span><br><span class="line"></span><br><span class="line">int decode(int yeet) &#123;</span><br><span class="line"></span><br><span class="line">    int giving = 0;</span><br><span class="line"></span><br><span class="line">    int bet = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; ; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (yeet &lt; pow(10, giving)) &#123;</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        giving += 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yeet *= yeet ;</span><br><span class="line"></span><br><span class="line">    if ( giving % 2 == 0 )</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        yeet *= 10 ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string iykyk = to_string(yeet).substr(giving - 1, giving);</span><br><span class="line"></span><br><span class="line">    return stoi(iykyk);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// L 函数</span><br><span class="line"></span><br><span class="line">int L(int plus,int ratio, int _plus, int blocked) &#123;</span><br><span class="line"></span><br><span class="line">    int dubs = (ratio * blocked + _plus) % plus;</span><br><span class="line"></span><br><span class="line">    return dubs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// high 函数</span><br><span class="line"></span><br><span class="line">int high(int key) &#123;</span><br><span class="line"></span><br><span class="line">    string cap = to_string(key);</span><br><span class="line"></span><br><span class="line">    cap[0] = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">    return stoi(cap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// cook 函数</span><br><span class="line"></span><br><span class="line">int cook(int e, int d[], int period[] = 0) &#123;</span><br><span class="line"></span><br><span class="line">    if (period == 0) &#123;</span><br><span class="line"></span><br><span class="line">        if (decode(L(d[1], d[2], d[3], d[0])) &gt; 100) &#123;</span><br><span class="line"></span><br><span class="line">            if (decode(L(d[1], d[2], d[3], d[0])) == 144) &#123;</span><br><span class="line"></span><br><span class="line">                flag.flag[e - 1] = decode(L(sigmas[8][1], sigmas[8][2], sigmas[8][3], sigmas[8][0])) % 335;</span><br><span class="line"></span><br><span class="line">            &#125; else if (decode(L(d[1], d[2], d[3], d[0])) == 449) &#123;</span><br><span class="line"></span><br><span class="line">                flag.flag[e - 1] = decode(L(sigmas[1][1], sigmas[1][2], sigmas[1][3], sigmas[1][0])) - 30;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                flag.flag[e - 1] = decode(L(d[1], d[2], d[3], d[0]));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            flag.flag[e - 1] = high(rando(L(d[1], d[2], d[3], d[0]))) + 48;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        if (rando(L(period[1], period[2], period[3], period[0])) == 610) &#123;</span><br><span class="line"></span><br><span class="line">            flag.flag[e - 1] = rando(L(period[1], period[2], period[3], period[0]));</span><br><span class="line"></span><br><span class="line">        &#125; else if (decode(L(d[1], d[2], d[3], d[0])) &gt; 100) &#123;</span><br><span class="line"></span><br><span class="line">            if (decode(L(period[1], period[2], period[3], period[0])) &gt; 100) &#123;</span><br><span class="line"></span><br><span class="line">                flag.flag[e - 1] = decode(L(d[1], d[2], d[3], d[0])) - decode(L(period[1], period[2], period[3], period[0]));</span><br><span class="line"></span><br><span class="line">                if (flag.flag[e - 1] &lt; 100) &#123;</span><br><span class="line"></span><br><span class="line">                    flag.flag[e - 1] += 100;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                flag.flag[e - 1] = decode(L(d[1], d[2], d[3], d[0])) - rando(L(period[1], period[2], period[3], period[0]));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过cook函数对原本的flag进行操作 每一次操作修改flag的一个值</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    cook(rando(361) - 300 + 7, sigmas[0]);</span><br><span class="line"></span><br><span class="line">    cook(rando(480) - 300 + 7, sigmas[2]);</span><br><span class="line"></span><br><span class="line">    cook(rando(490) - 400 + 7, sigmas[3], sigmas[4]);</span><br><span class="line"></span><br><span class="line">    cook(rando(539) - 900 + 7, sigmas[9]);</span><br><span class="line"></span><br><span class="line">    cook(rando(557) - 100 + 7, sigmas[1]);</span><br><span class="line"></span><br><span class="line">    cook(rando(819) - 700 + 7, sigmas[6]);</span><br><span class="line"></span><br><span class="line">    cook(rando(843) - 100 + 7, sigmas[8]);</span><br><span class="line"></span><br><span class="line">    cook(rando(906) - 200 + 7, sigmas[7], sigmas[5]);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; flag.flag &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//bronco&#123;br4inr0t&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Actual-Reversing"><a href="#Actual-Reversing" class="headerlink" title="Actual Reversing"></a>Actual Reversing</h1><p>题目给了一个elf文件和一个txt 打开txt提取一下数字</p>
<p><img src="/../images/ActualReversing.png" alt="ActualReversing"></p>
<p><code>-1, -4, 0, -1, 1, 1, 3, 2, 2, 3, 3, 8, 11, 12, 12, 13, 14, 15, 14, 16, 15, 15, 14, 17,  19, 19, 19, 19, 20, 20, 19, 25, 27, 28, 28, 26, 28, 28, 28, 28, 26, 27, 25, 27, 26, 28, 28,  27, 28, 26, 32, 31, 30, 31, 31, 30, 31, 30, 30, 29, 28, 29, 31, 28, 27, 28, 29, 29, 31, 33,  33, 32, 32, 32, 32, 32, 32, 29, 32, 33, 32, 32, 28, 32, 30, 31, 30, 30, 31, 30, 33, 35, 33, 39, 37, 37, 37, 37, 37, 37, 38, 39, 41, 41, 40, 39, 39, 39, 39, 39</code></p>
<p>随后分析elf文件<br>计算字符的二进制中表示 1 的个数 且等于108个</p>
<p><img src="/../images/ActualReversing-1.png" alt="ActualReversing-1"></p>
<p>随后跟进perscribe函数</p>
<p><img src="/../images/ActualReversing-2.png" alt="ActualReversing-2"></p>
<p>就是将输入的字符串的每个字符的每一位 与TRUTH字符串进行比对</p>
<p><img src="/../images/ActualReversing-3.png" alt="ActualReversing-3"></p>
<p>直接写z3约束求flag即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from z3 import *  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def solve_flag():  </span><br><span class="line">    x_values = [  </span><br><span class="line">        -1, -4, 0, -1, 1, 1, 3, 2, 2, 3, 3, 8, 11, 12, 12, 13, 14, 15, 14, 16,  </span><br><span class="line">        15, 15, 14, 17, 19, 19, 19, 19, 20, 20, 19, 25, 27, 28, 28, 26, 28, 28,  </span><br><span class="line">        28, 28, 26, 27, 25, 27, 26, 28, 28, 27, 28, 26, 32, 31, 30, 31, 31, 30,  </span><br><span class="line">        31, 30, 30, 29, 28, 29, 31, 28, 27, 28, 29, 29, 31, 33, 33, 32, 32, 32,  </span><br><span class="line">        32, 32, 29, 32, 33, 32, 32, 28, 32, 30, 31, 30, 30, 31, 30, 33, 35, 33,  </span><br><span class="line">        39, 37, 37, 37, 37, 37, 38, 39, 41, 41, 40, 39, 39, 39, 39, 39, 39  </span><br><span class="line">    ]  </span><br><span class="line">  </span><br><span class="line">    target_phrase = &quot;Can birds even understand me?&quot;  </span><br><span class="line">  </span><br><span class="line">    bit_positions = [  </span><br><span class="line">        byte_idx * 8 + bit_offset  </span><br><span class="line">        for byte_idx, char in enumerate(target_phrase)  </span><br><span class="line">        for bit_offset in range(8)  </span><br><span class="line">        if (ord(char) &gt;&gt; bit_offset) &amp; 1  </span><br><span class="line">    ]  </span><br><span class="line">  </span><br><span class="line">    solver = Solver()  </span><br><span class="line">  </span><br><span class="line">    flag_bits = [BitVec(f&#x27;bit_&#123;i&#125;&#x27;, 1) for i in range(512)]  </span><br><span class="line">  </span><br><span class="line">    for pos, x in zip(bit_positions, x_values):  </span><br><span class="line">        target_bit = pos - x  </span><br><span class="line">        solver.add(flag_bits[target_bit] == 1)  </span><br><span class="line">  </span><br><span class="line">    solver.add(sum(flag_bits) == 108)  </span><br><span class="line">  </span><br><span class="line">    if solver.check() == sat:  </span><br><span class="line">        model = solver.model()  </span><br><span class="line">  </span><br><span class="line">        flag_bytes = bytearray()  </span><br><span class="line">        for byte_idx in range(64):  </span><br><span class="line">            byte_value = 0  </span><br><span class="line">            for bit_offset in range(8):  </span><br><span class="line">                bit_index = byte_idx * 8 + bit_offset  </span><br><span class="line">                byte_value |= model[flag_bits[bit_index]].as_long() &lt;&lt; bit_offset  </span><br><span class="line">            flag_bytes.append(byte_value)  </span><br><span class="line">  </span><br><span class="line">        return flag_bytes.decode(&#x27;latin-1&#x27;).strip(&#x27;\x00&#x27;)  </span><br><span class="line">    return &quot;No solution found&quot;  </span><br><span class="line">  </span><br><span class="line">print(solve_flag())</span><br><span class="line">#bronco&#123;r3v3r5ed_3n0ugh?&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>2024领航杯本科组 RE wp</title>
    <url>/2025/01/02/2024-%E9%A2%86%E8%88%AA%E6%9D%AF-%E6%9C%AC%E7%A7%91%E7%BB%84Re-wp/</url>
    <content><![CDATA[<h1 id="ezsystd"><a href="#ezsystd" class="headerlink" title="ezsystd"></a>ezsystd</h1><p>jadx打开文件 找到主函数</p>
<span id="more"></span>

<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd.png" alt="本科组 easystd-1"></p>
<p>分析 主要的判断在check</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-1.png" alt="本科组 easystd-1"></p>
<p>调用本地native 所以分析native层 ida打开libcma.so 进入sub_904函数 发现一个类似sbox的数组</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-6.png" alt="本科组 easystd-6"></p>
<p>跟7异或 跑一下异或之后的sbox</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [ 0xD1, 0x97, 0xEE, 0xF9, 0xCB, 0xE6, 0x3A, 0xB0, 0x11, 0xB1]  </span><br><span class="line">for i in range(len(a)):  </span><br><span class="line">    a[i]^=7  </span><br><span class="line">    print(hex(a[i]),end=&#x27; &#x27;)</span><br><span class="line">#0xd6 0x90 0xe9 0xfe 0xcc 0xe1 0x3d 0xb7 0x16 0xb6</span><br></pre></td></tr></table></figure>

<p>发现是sm4的sbox 而且轮数也是32轮 所以猜测是sm4加密 找密文和密钥<br>跟进sub_75C函数 在最下面找到密文byte_C14</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-5.png" alt="本科组 easystd-5"></p>
<p>密钥在这个地方</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-7.png" alt="本科组 easystd-7"></p>
<p>跟进之后可以发现是将后八位替换为0x5A30303939383634</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-8.png" alt="本科组 easystd-8"></p>
<p>注意是小端序存储 所以密钥应该是A11223574689900Z 扔赛博厨子里跑一下</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-9.png" alt="本科组 easystd-9"></p>
<p>得到flag</p>
<p><img src="/../images/%E6%9C%AC%E7%A7%91%E7%BB%84easystd-10.png" alt="本科组 easystd-10"></p>
]]></content>
  </entry>
  <entry>
    <title>2025 GHCTF RE wp</title>
    <url>/2025/03/10/2025-GHCTF-RE-wp/</url>
    <content><![CDATA[<p><strong>前言：RE的最后一题没有写 混淆和花太多 而且出题人的wp写的十分详细 我就不献丑了</strong></p>
<h1 id="ASM-Signin"><a href="#ASM-Signin" class="headerlink" title="ASM?Signin!"></a>ASM?Signin!</h1><p>直接扔给deekseek 得到c语言代码 </p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// 初始化数据段</span><br><span class="line"></span><br><span class="line">uint8_t DATA1[] = &#123;</span><br><span class="line"></span><br><span class="line">    0x26, 0x27, 0x24, 0x25, 0x2A, 0x2B, 0x28, 0x00,</span><br><span class="line"></span><br><span class="line">    0x2E, 0x2F, 0x2C, 0x2D, 0x32, 0x33, 0x30, 0x00,</span><br><span class="line"></span><br><span class="line">    0x36, 0x37, 0x34, 0x35, 0x3A, 0x3B, 0x38, 0x39,</span><br><span class="line"></span><br><span class="line">    0x3E, 0x3F, 0x3C, 0x3D, 0x3F, 0x27, 0x34, 0x11</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">uint8_t DATA2[] = &#123;</span><br><span class="line"></span><br><span class="line">    0x69, 0x77, 0x77, 0x66, 0x73, 0x72, 0x4F, 0x46,</span><br><span class="line"></span><br><span class="line">    0x03, 0x47, 0x6F, 0x79, 0x07, 0x41, 0x13, 0x47,</span><br><span class="line"></span><br><span class="line">    0x5E, 0x67, 0x5F, 0x09, 0x0F, 0x58, 0x63, 0x7D,</span><br><span class="line"></span><br><span class="line">    0x5F, 0x77, 0x68, 0x35, 0x62, 0x0D, 0x0D, 0x50</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">uint8_t BUFFER1[35] = &#123;0&#125;; // 33字节缓冲区+2字节头信息</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// 数据交换函数</span><br><span class="line"></span><br><span class="line">void swap_blocks(int src, int dest) &#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line"></span><br><span class="line">        uint8_t tmp = DATA1[src + i];</span><br><span class="line"></span><br><span class="line">        DATA1[src + i] = DATA1[dest + i];</span><br><span class="line"></span><br><span class="line">        DATA1[dest + i] = tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// DATA1预处理函数</span><br><span class="line"></span><br><span class="line">void preprocess_data1() &#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line"></span><br><span class="line">        int src = i * 4;</span><br><span class="line"></span><br><span class="line">        int dest = src + 4;</span><br><span class="line"></span><br><span class="line">        if (dest &gt;= 28) &#123;</span><br><span class="line"></span><br><span class="line">            dest -= 28;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap_blocks(src, dest);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// 加密函数</span><br><span class="line"></span><br><span class="line">void encrypt_buffer() &#123;</span><br><span class="line"></span><br><span class="line">    uint8_t *buf = BUFFER1 + 2; // 跳过输入头信息</span><br><span class="line"></span><br><span class="line">    uint8_t *key = DATA1;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line"></span><br><span class="line">        // 构造16位密钥字（小端模式）</span><br><span class="line"></span><br><span class="line">        uint16_t key1 = (key[2] &lt;&lt; 8) | key[1];</span><br><span class="line"></span><br><span class="line">        uint16_t key2 = (key[3] &lt;&lt; 8) | key[2];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        // 处理前两个字节</span><br><span class="line"></span><br><span class="line">        uint16_t val = *((uint16_t*)buf);</span><br><span class="line"></span><br><span class="line">        val ^= key1;</span><br><span class="line"></span><br><span class="line">        memcpy(buf, &amp;val, sizeof(val));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        // 处理后两个字节</span><br><span class="line"></span><br><span class="line">        val = *((uint16_t*)(buf + 2));</span><br><span class="line"></span><br><span class="line">        val ^= key2;</span><br><span class="line"></span><br><span class="line">        memcpy(buf + 2, &amp;val, sizeof(val));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        buf += 4;</span><br><span class="line"></span><br><span class="line">        key += 4;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Welcome to GHCTF!\nInput your flag:&quot;);</span><br><span class="line"></span><br><span class="line">    // 模拟DOS 0AH功能调用</span><br><span class="line"></span><br><span class="line">    fgets((char*)BUFFER1 + 2, sizeof(BUFFER1) - 2, stdin);</span><br><span class="line"></span><br><span class="line">    size_t len = strlen((char*)BUFFER1 + 2);</span><br><span class="line"></span><br><span class="line">    if (len &gt; 0 &amp;&amp; BUFFER1[len + 1] == &#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">        BUFFER1[len + 1] = 0;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    preprocess_data1(); // 预处理DATA1</span><br><span class="line"></span><br><span class="line">    encrypt_buffer();   // 加密输入</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    // 验证加密结果</span><br><span class="line"></span><br><span class="line">    if (memcmp(BUFFER1 + 2, DATA2, 32) == 0) &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;\nRight!\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;\nWrong!\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接对照着写解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = bytearray([</span><br><span class="line"></span><br><span class="line">    0x26, 0x27, 0x24, 0x25, 0x2A, 0x2B, 0x28, 0x00,</span><br><span class="line"></span><br><span class="line">    0x2E, 0x2F, 0x2C, 0x2D, 0x32, 0x33, 0x30, 0x00,</span><br><span class="line"></span><br><span class="line">    0x36, 0x37, 0x34, 0x35, 0x3A, 0x3B, 0x38, 0x39,</span><br><span class="line"></span><br><span class="line">    0x3E, 0x3F, 0x3C, 0x3D, 0x3F, 0x27, 0x34, 0x11</span><br><span class="line"></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">def swap_blocks(data, src, dest):</span><br><span class="line"></span><br><span class="line">    data[src:src+4], data[dest:dest+4] = data[dest:dest+4], data[src:src+4]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line"></span><br><span class="line">    src = i * 4</span><br><span class="line"></span><br><span class="line">    dest = src + 4</span><br><span class="line"></span><br><span class="line">    if dest &gt;= 28:</span><br><span class="line"></span><br><span class="line">        dest -= 28</span><br><span class="line"></span><br><span class="line">    swap_blocks(key, src, dest)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">enc = bytearray([</span><br><span class="line"></span><br><span class="line">    0x69, 0x77, 0x77, 0x66, 0x73, 0x72, 0x4F, 0x46,</span><br><span class="line"></span><br><span class="line">    0x03, 0x47, 0x6F, 0x79, 0x07, 0x41, 0x13, 0x47,</span><br><span class="line"></span><br><span class="line">    0x5E, 0x67, 0x5F, 0x09, 0x0F, 0x58, 0x63, 0x7D,</span><br><span class="line"></span><br><span class="line">    0x5F, 0x77, 0x68, 0x35, 0x62, 0x0D, 0x0D, 0x50</span><br><span class="line"></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">flag = bytearray()</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line"></span><br><span class="line">    block = enc[i*4:(i+1)*4]</span><br><span class="line"></span><br><span class="line">    k = key[i*4:(i+1)*4]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    key1 = (k[2] &lt;&lt; 8) | k[1]  </span><br><span class="line"></span><br><span class="line">    key2 = (k[3] &lt;&lt; 8) | k[2]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    enc1 = block[0] | (block[1] &lt;&lt; 8)</span><br><span class="line"></span><br><span class="line">    dec1 = enc1 ^ key1</span><br><span class="line"></span><br><span class="line">    flag.append(dec1 &amp; 0xFF)</span><br><span class="line"></span><br><span class="line">    flag.append((dec1 &gt;&gt; 8) &amp; 0xFF)</span><br><span class="line"></span><br><span class="line">    # 解密后两个字节</span><br><span class="line"></span><br><span class="line">    enc2 = block[2] | (block[3] &lt;&lt; 8)</span><br><span class="line"></span><br><span class="line">    dec2 = enc2 ^ key2</span><br><span class="line"></span><br><span class="line">    flag.append(dec2 &amp; 0xFF)</span><br><span class="line"></span><br><span class="line">    flag.append((dec2 &gt;&gt; 8) &amp; 0xFF)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">print(flag.decode(&#x27;latin-1&#x27;).strip(&#x27;\x00&#x27;))</span><br><span class="line">#NSSCTF&#123;W0w_y0u&#x27;re_g00d_@t_@5M!!&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FishingKit"><a href="#FishingKit" class="headerlink" title="FishingKit"></a>FishingKit</h1><p>ida打开附件 逻辑很清晰</p>
<p><img src="/../images/FishingKit.png" alt="FishingKit"></p>
<p>z3可以求出key</p>
<p><img src="/../images/FishingKit-1.png" alt="FishingKit-1"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from z3 import *  </span><br><span class="line">  </span><br><span class="line">a1 = [BitVec(f&#x27;a1[&#123;i&#125;]&#x27;,8) for i in range(10)]  </span><br><span class="line">solver = Solver()  </span><br><span class="line">solver.add(202 * a1[8] + 216 * a1[5] - 4 * a1[4] - 330 * a1[9] - 13 * a1[4] - 268 * a1[6] == 0xFFFFC57A)  </span><br><span class="line">solver.add(325 * a1[8] + 195 * a1[0] + 229 * a1[1] - 121 * a1[6] - 409 * a1[6] - (a1[1] &lt;&lt; 7) == 0x584E)  </span><br><span class="line">solver.add(489 * a1[1] + 480 * a1[6] + 105 * a1[2] + 367 * a1[3] - 135 * a1[4] - 482 * a1[9] == 0xF704)  </span><br><span class="line">solver.add(493 * a1[1] - 80 * a1[4] - 253 * a1[8] - 121 * a1[2] - 177 * a1[0] - 243 * a1[9] == 0xFFFF6510)  </span><br><span class="line">solver.add(275 * a1[4] + 271 * a1[6] + 473 * a1[7] - 72 * a1[5] - 260 * a1[4] - 367 * a1[4] == 0x37AF)  </span><br><span class="line">solver.add(286 * a1[0] + 196 * a1[7] + 483 * a1[2] + 442 * a1[1] - 495 * a1[8] - 351 * a1[4] == 0xA0D3)  </span><br><span class="line">solver.add(212 * a1[2] + 283 * a1[7] - 329 * a1[8] - 429 * a1[9] - 362 * a1[2] - 261 * a1[6] == 0xFFFE9F54)  </span><br><span class="line">solver.add(456 * a1[5] + 244 * a1[7] + 92 * a1[4] + 348 * a1[7] - 225 * a1[1] - 31 * a1[2] == 0x1597F)  </span><br><span class="line">solver.add(238 * a1[9] + 278 * a1[7] + 216 * a1[6] + 237 * a1[0] + 8 * a1[2] - 17 * a1[9] == 0x1477E)  </span><br><span class="line">solver.add(323 * a1[9] + 121 * a1[1] + 370 * a1[7] - (a1[4] &lt;&lt; 6) - 196 * a1[9] - 422 * a1[0] == 0x6763)  </span><br><span class="line">solver.add(166 * a1[9] + 90 * a1[1] + 499 * a1[2] + 301 * a1[8] - 31 * a1[2] - 206 * a1[2] == 0x158B7)  </span><br><span class="line">solver.add(355 * a1[0] + 282 * a1[4] + 44 * a1[9] + 359 * a1[8] - 167 * a1[5] - 62 * a1[3] == 0x12B72)  </span><br><span class="line">solver.add(488 * a1[6] + 379 * a1[9] + 318 * a1[2] - 85 * a1[1] - 357 * a1[2] - 277 * a1[5] == 0x8A46)  </span><br><span class="line">solver.add(40 * a1[0] + 281 * a1[4] + 217 * a1[5] - 241 * a1[1] - 407 * a1[7] - 309 * a1[7] == 0xFFFF7594)  </span><br><span class="line">solver.add(429 * a1[3] + 441 * a1[3] + 115 * a1[1] + 96 * a1[8] + 464 * a1[1] - 133 * a1[7] == 0x26708)  </span><br><span class="line">solutions = []  </span><br><span class="line">while solver.check() == sat:  </span><br><span class="line">    model = solver.model()  </span><br><span class="line">    solution = [model[a1[i]].as_long() for i in range(10)]  </span><br><span class="line">    solutions.append(solution)  </span><br><span class="line">    solver.add(Or([a1[i] != solution[i] for i in range(10)]))  </span><br><span class="line">for sol in solutions:  </span><br><span class="line">    for i in range(10):  </span><br><span class="line">        print(chr(sol[i]),end=&#x27;&#x27;)</span><br><span class="line">#DeluxeBait</span><br></pre></td></tr></table></figure>

<p>随后是一个异或0x14的rc4</p>
<p><img src="/../images/FishingKit-2.png" alt="FishingKit-2"></p>
<p>写脚本求出的是fake的flag<br>NSSCTF{Fake!Fake!Fake!}<br>随后看了看左边的函数 发现了一个函数很奇怪</p>
<p><img src="/../images/FishingKit-3.png" alt="FishingKit-3"></p>
<p>随后打个断点慢慢调试 发现在main函数调用之前进行了一个跳转</p>
<p><img src="/../images/FishingKit-4.png" alt="FishingKit-4"></p>
<p>继续跟进就是之前那个奇怪的函数 交叉引用函数以及变量发现了三个tea的加密</p>
<p><img src="/../images/FishingKit-5.png" alt="FishingKit-5"></p>
<p>密文就是之前奇怪的函数里的值<br><code>0xA6975621, 0xDEC4D51A, 0x4D829CA4, 0x56C845D1, 0x5C96B4A7, 0x2087494D</code><br>key就是最开始z3求出来的key 直接对着写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">void tea_decrypt(uint32_t *v0, uint32_t *v1, uint32_t key[4]) &#123;</span><br><span class="line"></span><br><span class="line">    uint32_t delta = 1719109785;</span><br><span class="line"></span><br><span class="line">    uint32_t sum = delta * 24;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 24; i++) &#123;</span><br><span class="line"></span><br><span class="line">        *v1 -= ((key[(sum &gt;&gt; 11) &amp; 3] + sum) ^ (*v0 + ((*v0 &gt;&gt; 5) ^ (*v0 * 16))));</span><br><span class="line"></span><br><span class="line">        sum -= delta;</span><br><span class="line"></span><br><span class="line">        *v0 -= ((key[sum &amp; 3] + sum) ^ (*v1 + ((*v1 &gt;&gt; 5) ^ (*v1 * 16))));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    uint32_t enc[6] = &#123;0xA6975621, 0xDEC4D51A, 0x4D829CA4, 0x56C845D1, 0x5C96B4A7, 0x2087494D&#125;;</span><br><span class="line"></span><br><span class="line">    uint32_t key[4] = &#123;0x756C6544, 0x61426578, 0x7469, 0&#125;;</span><br><span class="line"></span><br><span class="line">    uint32_t flag[6];</span><br><span class="line"></span><br><span class="line">    tea_decrypt(&amp;enc[0], &amp;enc[1], key);</span><br><span class="line"></span><br><span class="line">    tea_decrypt(&amp;enc[2], &amp;enc[3], key);</span><br><span class="line"></span><br><span class="line">    tea_decrypt(&amp;enc[4], &amp;enc[5], key);</span><br><span class="line"></span><br><span class="line">    memcpy(flag, enc, sizeof(enc));</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line"></span><br><span class="line">        uint8_t *bytes = (uint8_t *)&amp;flag[i];</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line"></span><br><span class="line">            printf(&quot;%c&quot;, bytes[j]);  // 按小端序输出字符</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//NSSCTF&#123;Wh@t_@_b1g_F1sh&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LockedSecret"><a href="#LockedSecret" class="headerlink" title="LockedSecret"></a>LockedSecret</h1><p>首先查壳 修改一下特征值 即可upx -d脱掉</p>
<p><img src="/../images/LockedSecret.png" alt="LockedSecret"></p>
<p>ida打开 逻辑很清晰 flag长度32</p>
<p><img src="/../images/LockedSecret-1.png" alt="LockedSecret-1"></p>
<p>跟进encry函数 进行了很多自定义的加密 带有混淆 很难看</p>
<p><img src="/../images/LockedSecret-2.png" alt="LockedSecret-2"></p>
<p>随后一点一点分析下面的逻辑 类似于tea加密 扔给deepseek 简化一下</p>
<p><img src="/../images/LockedSecret-6.png" alt="LockedSecret-6"></p>
<p>把这些看成一个整体 分为flag1和2</p>
<p><img src="/../images/LockedSecret-8.png" alt="LockedSecret-8"></p>
<p>随后对照着加密 写出解密脚本即可 需要注意这个地方多处理一下即可</p>
<p><img src="/../images/LockedSecret-7.png" alt="LockedSecret-7"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">uint32_t key[4] = &#123;0x423DF72D, 0x05F59A01, 0x633FCF1D, 0x77D19122&#125;;</span><br><span class="line"></span><br><span class="line">uint32_t enc[8] = &#123;0x031e45dc, 0x2776e989, 0x01234847, 0x64ced270,</span><br><span class="line"></span><br><span class="line">                   0x33467fda, 0xa34903b1, 0x2cd10027, 0x75bdb337&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">uint32_t tea1(uint32_t m, int32_t sum) &#123;</span><br><span class="line"></span><br><span class="line">    m &amp;= 0xffffffff;</span><br><span class="line"></span><br><span class="line">    return ((key[1] + (m &gt;&gt; 5)) &amp; 0xffffffff) ^ ((m + sum) &amp; 0xffffffff) ^ ((key[0] + 16 * m) &amp; 0xffffffff);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">uint32_t tea2(uint32_t m, int32_t sum) &#123;</span><br><span class="line"></span><br><span class="line">    m &amp;= 0xffffffff;</span><br><span class="line"></span><br><span class="line">    return ((key[3] + (m &gt;&gt; 5)) &amp; 0xffffffff) ^ ((m + sum) &amp; 0xffffffff) ^ ((key[2] + 16 * m) &amp; 0xffffffff);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    uint32_t flag[8];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line"></span><br><span class="line">        uint32_t flag_1 = enc[2 * i] ^ 0xf;</span><br><span class="line"></span><br><span class="line">        uint32_t flag_2 = enc[2 * i + 1] ^ 0xf;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        uint32_t v2 = (flag_2 - tea2(flag_1, -249839624)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v6 = (flag_1 - tea1(v2, -249839624)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v7 = (v2 - tea2(v6, -1829222407)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v8 = (v6 - tea1(v7, -1829222407)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v9 = (v7 - tea2(v8, 886362106)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v10 = (v8 - tea1(v9, 886362106)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v11 = (v9 - tea2(v10, -693020677)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v1 = (v10 - tea1(v11, -693020677)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v12 = (v11 - tea2(v1, 2022563836)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v100 = (v1 - tea1(v12, 2022563836)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v13 = (v12 - tea2(v100, 443181053)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v14 = (v100 - tea1(v13, 443181053)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v15 = (v13 - tea2(v14, -1136201730)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v16 = (v14 - tea1(v15, -1136201730)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        uint32_t v17 = (v15 - tea2(v16, 1579382783)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        flag[2 * i] = (v16 - tea1(v17, 1579382783)) &amp; 0xffffffff;</span><br><span class="line"></span><br><span class="line">        flag[2 * i + 1] = v17;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    uint8_t byte_data[32];</span><br><span class="line"></span><br><span class="line">    memcpy(byte_data, flag, sizeof(flag));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (byte_data[i] &gt;= 32 &amp;&amp; byte_data[i] &lt;= 126) &#123;</span><br><span class="line"></span><br><span class="line">            printf(&quot;%c&quot;, byte_data[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//NSSCTF&#123;!!!Y0u_g3t_th3_s3cr3t!!!&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mio？Ryo？Soyo？"><a href="#Mio？Ryo？Soyo？" class="headerlink" title="Mio？Ryo？Soyo？"></a>Mio？Ryo？Soyo？</h1><p>python的exe 使用pyinstxtractor解包 注意版本是3.8<br>随后找个在线网站反编译 看反编译出来的代码 变量名很长 先修改一下</p>
<p><img src="/../images/MioRyoSoyo1.png" alt="MioRyoSoyo1"></p>
<p>主要就是标准的base85 修改了码表的base45 还有凯撒<br>随后看密文以及加密过程</p>
<p><img src="/../images/MioRyoSoyo.png" alt="MioRyoSoyo"></p>
<p>加密是base45-凯撒移位7-base85-凯撒移位9<br>直接写逆向脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def caesar(enc, key):</span><br><span class="line"></span><br><span class="line">    bbb = []</span><br><span class="line"></span><br><span class="line">    for a in enc:</span><br><span class="line"></span><br><span class="line">        if &quot;a&quot; &lt;= a &lt;= &quot;z&quot;:</span><br><span class="line"></span><br><span class="line">            bbb.append(chr(ord(&quot;a&quot;)+(ord(a) - ord(&quot;a&quot;) - key) % 26))</span><br><span class="line"></span><br><span class="line">        elif &quot;0&quot; &lt;= a &lt;= &quot;9&quot;:</span><br><span class="line"></span><br><span class="line">            bbb.append(chr(ord(&quot;0&quot;) + (ord(a) - ord(&quot;0&quot;) + key) % 10))</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            bbb.append(a)</span><br><span class="line"></span><br><span class="line">    return &quot;&quot;.join(bbb)</span><br><span class="line"></span><br><span class="line">def base45_decode(encoded_str, custom_alphabet):</span><br><span class="line"></span><br><span class="line">    if len(custom_alphabet) != 45:</span><br><span class="line"></span><br><span class="line">        raise ValueError(&quot;Base45 码表长度必须为 45&quot;)</span><br><span class="line"></span><br><span class="line">    char_to_index = &#123;char: idx for idx, char in enumerate(custom_alphabet)&#125;</span><br><span class="line"></span><br><span class="line">    n = len(encoded_str)</span><br><span class="line"></span><br><span class="line">    decoded_bytes = []</span><br><span class="line"></span><br><span class="line">    i = 0</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    while i &lt; n:</span><br><span class="line"></span><br><span class="line">        if i + 3 &lt;= n:</span><br><span class="line"></span><br><span class="line">            c0, c1, c2 = encoded_str[i], encoded_str[i + 1], encoded_str[i + 2]</span><br><span class="line"></span><br><span class="line">            value = (char_to_index[c0] + char_to_index[c1] * 45 + char_to_index[c2] * 45 * 45)</span><br><span class="line"></span><br><span class="line">            decoded_bytes.extend(value.to_bytes(2, &quot;big&quot;))</span><br><span class="line"></span><br><span class="line">            i += 3</span><br><span class="line"></span><br><span class="line">        elif i + 2 &lt;= n:</span><br><span class="line"></span><br><span class="line">            c0, c1 = encoded_str[i], encoded_str[i + 1]</span><br><span class="line"></span><br><span class="line">            value = char_to_index[c0] + char_to_index[c1] * 45</span><br><span class="line"></span><br><span class="line">            if value &gt; 0xFF:</span><br><span class="line"></span><br><span class="line">                raise ValueError(&quot;无效的 Base45 编码：剩余字符解码后超出 1 字节范围&quot;)</span><br><span class="line"></span><br><span class="line">            decoded_bytes.extend(value.to_bytes(1, &quot;big&quot;))</span><br><span class="line"></span><br><span class="line">            i += 2</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            raise ValueError(&quot;无效的 Base45 编码：字符串长度不符合要求&quot;)</span><br><span class="line"></span><br><span class="line">    return bytes(decoded_bytes)</span><br><span class="line"></span><br><span class="line">base45_table = &quot;0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\&quot;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">enc = &#x27;9v!rD8us&quot;44_N(1;_U?z6!Mn16&quot;mjz&lt;\l[=3*&gt;#&amp;4C&gt;zt0L2C3;)z--3Z&#x27;</span><br><span class="line"></span><br><span class="line">enc1 = base64.a85decode(caesar(enc,9)).decode()</span><br><span class="line"></span><br><span class="line">flag = base45_decode(caesar(enc1, 7),base45_table).decode()</span><br><span class="line"></span><br><span class="line">print(flag)</span><br><span class="line">#NSSCTF&#123;Th3y&#x27;r3_a11_p1aY_Ba5e!&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TimeSpaceRescue"><a href="#TimeSpaceRescue" class="headerlink" title="TimeSpaceRescue"></a>TimeSpaceRescue</h1><p>根据题目描述 猜测需要时间戳爆破 范围是整个2024年<br>ida打开附件 有反调试 nop掉即可</p>
<p><img src="/../images/TimeSpaceRescue-1.png" alt="TimeSpaceRescue-1"></p>
<p>进入主函数 逻辑很清晰</p>
<p><img src="/../images/TimeSpaceRescue.png" alt="TimeSpaceRescue"></p>
<p>输入flag 根据当前时间的年月日 md5之后生成key 再根据key解密魔改的AES<br>跟进key_encry函数 有花 nop掉</p>
<p><img src="/../images/TimeSpaceRescue-2.png" alt="TimeSpaceRescue-2"></p>
<p>随后看sub_211210函数 找到魔改点</p>
<p><img src="/../images/TimeSpaceRescue-3.png" alt="TimeSpaceRescue-3"></p>
<p>10A0就是xor 0x5然后交换位置 1030就是xor 0xf然后交换位置 直接根据这些约束 写脚本爆破即可 爆破思路是 先爆破前16位 如果有NSSCTF字样则是正确的key 再根据这个key解密剩下的密文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib  </span><br><span class="line">from Crypto.Cipher import AES  </span><br><span class="line">  </span><br><span class="line">def sub_2110A0(data):  </span><br><span class="line">    data = bytearray(data)  </span><br><span class="line">    for i in range(0, 16, 2):  </span><br><span class="line">        if i + 1 &gt;= len(data):  </span><br><span class="line">            break  </span><br><span class="line">        a = data[i] ^ 0x05  </span><br><span class="line">        b = data[i + 1] ^ 0x05  </span><br><span class="line">        data[i], data[i + 1] = b, a  </span><br><span class="line">    return bytes(data)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def sub_211030(data):  </span><br><span class="line">    data = bytearray(data)  </span><br><span class="line">    n = len(data)  </span><br><span class="line">    for i in range(n // 2):  </span><br><span class="line">        j = n - 1 - i  </span><br><span class="line">        a = data[i] ^ 0x0F  </span><br><span class="line">        b = data[j] ^ 0x0F  </span><br><span class="line">        data[i], data[j] = b, a  </span><br><span class="line">    return bytes(data)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def generate_key(input_data):  </span><br><span class="line">    md5 = hashlib.md5(input_data).digest()  </span><br><span class="line">    key = bytes([(b ^ 0x14) ^ 0x11 for b in md5])  </span><br><span class="line">    return key  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def aes_decrypt(key, ciphertext):  </span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)  </span><br><span class="line">    try:  </span><br><span class="line">        plaintext = cipher.decrypt(ciphertext)  </span><br><span class="line">    except ValueError as e:  </span><br><span class="line">        print(f&quot;Decryption error: &#123;e&#125;&quot;)  </span><br><span class="line">        return b&#x27;&#x27;  </span><br><span class="line">    return plaintext  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">enc1 = bytes([0xcd, 0x16, 0xdb, 0xb5, 0xd1, 0x02, 0xa4, 0x82, 0x8e, 0x59, 0x73, 0x9e, 0x96, 0x26, 0x56, 0xf2])  </span><br><span class="line">days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]  </span><br><span class="line">for month in range(12):  </span><br><span class="line">    for day in range(1, days_in_month[month] + 1):  </span><br><span class="line">        input_data = bytearray(12)  </span><br><span class="line">        input_data[0:4] = day.to_bytes(4, &#x27;little&#x27;)  </span><br><span class="line">        input_data[4:8] = month.to_bytes(4, &#x27;little&#x27;)  </span><br><span class="line">        input_data[8:12] = (124).to_bytes(4, &#x27;little&#x27;)  </span><br><span class="line">        key = generate_key(bytes(input_data))  </span><br><span class="line">        encrypted_key = sub_2110A0(key)  </span><br><span class="line">        processed_cipher = sub_2110A0(enc1)  </span><br><span class="line">        decrypted = aes_decrypt(encrypted_key, processed_cipher)  </span><br><span class="line">        if not decrypted:  </span><br><span class="line">            continue  </span><br><span class="line">        flag1 = sub_211030(decrypted)  </span><br><span class="line">        if b&#x27;NSSCTF&#x27; in flag1:  </span><br><span class="line">            print(day, month + 1)  </span><br><span class="line">            print(encrypted_key)  </span><br><span class="line">            print(flag1.decode(&#x27;latin-1&#x27;))  # NSSCTF&#123;W0w_Y0u&#x27;r  </span><br><span class="line">  </span><br><span class="line">enc = bytes([  </span><br><span class="line">    0x16, 0x8e, 0x46, 0xf2, 0x55, 0x7b, 0x92, 0x31,  </span><br><span class="line">    0x30, 0xdc, 0xaa, 0x8a, 0xf3, 0x1c, 0xa0, 0xaa  </span><br><span class="line">])  </span><br><span class="line">key = b&#x27;\n\xe4\xfbFF+YTF+k\x87t&amp;\x91\x07&#x27;  </span><br><span class="line">processed_cipher = sub_2110A0(enc)  </span><br><span class="line">decrypted = aes_decrypt(key, processed_cipher)  </span><br><span class="line">flag2 = sub_211030(decrypted)  </span><br><span class="line">print(flag2.decode(&#x27;latin-1&#x27;,(errors=&#x27;replace&#x27;))</span><br><span class="line">#NSSCTF&#123;W0w_Y0u&#x27;re_@n_AE5_M@5t3r&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Room-0"><a href="#Room-0" class="headerlink" title="Room 0"></a>Room 0</h1><p>ida打开附件 有花 先去掉</p>
<p><img src="/../images/Room.png" alt="Room"></p>
<p><img src="/../images/Room0.png" alt="Room0"></p>
<p><img src="/../images/Room0-1.png" alt="Room0-1"></p>
<p>retn jzjnz花 直接nop掉 随后看主函数 逻辑很清晰</p>
<p><img src="/../images/Room0-2.png" alt="Room0-2"></p>
<p>首先计算key key需要爆破 运算后的smc是一个函数 开头就是 push ebp mov ebp esp<br>所以前三位固定 爆破第四位 后来根据hint 触发除数为零的异常去爆破</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int v2;          // [esp+0h] [ebp-1Ch]</span><br><span class="line"></span><br><span class="line">    int i;           // [esp+4h] [ebp-18h]</span><br><span class="line"></span><br><span class="line">    int v4;          // [esp+8h] [ebp-14h]</span><br><span class="line"></span><br><span class="line">    int v5;          // [esp+Ch] [ebp-10h]</span><br><span class="line"></span><br><span class="line">    int v6;          // [esp+10h] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">    int v7;          // [esp+10h] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">    unsigned int v8; // [esp+14h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">    int v9;</span><br><span class="line"></span><br><span class="line">    int key;</span><br><span class="line"></span><br><span class="line">    v9 = 0x755ff000;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 0xff, v9 &lt; 0x755ff0ff; i++, v9++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        v6 = 0;</span><br><span class="line"></span><br><span class="line">        v8 = 0x75;</span><br><span class="line"></span><br><span class="line">        v5 = 0x5f;</span><br><span class="line"></span><br><span class="line">        v4 = 0xf0;</span><br><span class="line"></span><br><span class="line">        key = v9;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; 32; ++j)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            v5 = (key + v5) ^ (8 * v4);</span><br><span class="line"></span><br><span class="line">            v4 = (key + v8) ^ (8 * v5);</span><br><span class="line"></span><br><span class="line">            v8 = (key + v4) ^ (8 * v5);</span><br><span class="line"></span><br><span class="line">            key -= v4 + v5 + v8;</span><br><span class="line"></span><br><span class="line">            if ((key - 1415881080) == 0)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                printf(&quot;%x&quot;, v9);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;//755ff0d3</span><br></pre></td></tr></table></figure>

<p>得到key之后 打个断点 触发异常跳到smc段 也是retn jzjnz花 去掉即可</p>
<p><img src="/../images/Room0-3.png" alt="Room0-3"></p>
<p>得到这么一个函数</p>
<p><img src="/../images/Room0-4.png" alt="Room0-4"></p>
<p>像是个魔改的rc4 最后的加密就是个异或 所以提取一下输入的密文加密后的值 得到密钥流异或密文即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;A&quot; * 32)  </span><br><span class="line">get = [0x2D, 0xD6, 0xB2, 0x58, 0xCB, 0xEA, 0x58, 0x56, 0x0A, 0xD7,  </span><br><span class="line">       0x1F, 0x95, 0x77, 0x95, 0x15, 0xFD, 0x52, 0xBF, 0x4C, 0x4A,  </span><br><span class="line">       0x80, 0xA5, 0x61, 0xEB, 0x3A, 0xA9, 0x44, 0xE8, 0x01, 0xAC,  </span><br><span class="line">       0xBC, 0x95]  </span><br><span class="line">enc = [0x22, 0xC4, 0xA0, 0x5A, 0xDE, 0xED, 0x62, 0x5E, 0x25, 0xE2,  </span><br><span class="line">       0x6D, 0xA6, 0x05, 0xA7, 0x20, 0x8D, 0x7D, 0x99, 0x52, 0x3E,  </span><br><span class="line">       0x8C, 0xA7, 0x7F, 0xFA, 0x09, 0xD8, 0x62, 0xDB, 0x00, 0x80,  </span><br><span class="line">       0xC2, 0xA9]  </span><br><span class="line">keystream = [(ord(&quot;A&quot;) ^ i) &amp; 0xff for i in get]  </span><br><span class="line">for i in range(len(enc)):  </span><br><span class="line">    enc[i] ^= keystream[i]  </span><br><span class="line">    enc[i] &amp;= 0xff  </span><br><span class="line">print(&quot;&quot;.join(map(chr, enc)))</span><br><span class="line">#NSSCTF&#123;Int3r3st1ng_5MC_Pr0gr@m?&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Canon"><a href="#Canon" class="headerlink" title="Canon"></a>Canon</h1><p>ida打开附件 逻辑很清晰 直接起调试dump下来加密的各个case 没用到case2 7 所以不用分析 </p>
<p><img src="/../images/Canon.png" alt="Canon"></p>
<p>注意加密的base64是换表的</p>
<p><img src="/../images/Canon-4.png" alt="Canon-4"></p>
<p>起调试dump下来</p>
<p><img src="/../images/Canon-2.png" alt="Canon-2"></p>
<p><code>stuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr</code><br>逆回去写解密即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64  </span><br><span class="line">import math  </span><br><span class="line"></span><br><span class="line">def rc4_decrypt(data, key):  </span><br><span class="line">    key = key.encode()  </span><br><span class="line">    S = list(range(256))  </span><br><span class="line">    j = 0  </span><br><span class="line">    out = []  </span><br><span class="line">  </span><br><span class="line">    for i in range(256):  </span><br><span class="line">        j = (j + S[i] + key[i % len(key)]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">  </span><br><span class="line">    i = j = 0  </span><br><span class="line">    for char in data:  </span><br><span class="line">        i = (i + 1) % 256  </span><br><span class="line">        j = (j + S[i]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">        out.append(((char - 0x39) ^ S[(S[i] + S[j]) % 256]) % 256)  </span><br><span class="line">    return bytes(out)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def decrypt(a1, a2, a3):  </span><br><span class="line">    v9 = len(a1)  </span><br><span class="line">    v21 = len(a2)  </span><br><span class="line">    if a3 == 1:  </span><br><span class="line">        output = &#x27;&#x27;  </span><br><span class="line">        for i in range(v9):  </span><br><span class="line">            v22 = ord(a2[i % v21])  </span><br><span class="line">            if &#x27;A&#x27; &lt;= a1[i] &lt;= &#x27;Z&#x27;:  </span><br><span class="line">                offset = (ord(a1[i]) - ord(&#x27;A&#x27;) - v22) % 26  </span><br><span class="line">                output += chr(offset + ord(&#x27;A&#x27;))  </span><br><span class="line">            elif &#x27;a&#x27; &lt;= a1[i] &lt;= &#x27;z&#x27;:  </span><br><span class="line">                offset = (ord(a1[i]) - ord(&#x27;a&#x27;) - v22) % 26  </span><br><span class="line">                output += chr(offset + ord(&#x27;a&#x27;))  </span><br><span class="line">            elif &#x27;0&#x27; &lt;= a1[i] &lt;= &#x27;9&#x27;:  </span><br><span class="line">                offset = (ord(a1[i]) - ord(&#x27;0&#x27;) - v22) % 10  </span><br><span class="line">                output += chr(offset + ord(&#x27;0&#x27;))  </span><br><span class="line">            else:  </span><br><span class="line">                output += a1[i]  </span><br><span class="line">        return output  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    elif a3 == 3:  </span><br><span class="line">        Ek = ord(a2[0]) % 10 + 2  </span><br><span class="line">        cipher_len = v9  </span><br><span class="line">        Dk = cipher_len // Ek  </span><br><span class="line">        remainder = cipher_len % Ek  </span><br><span class="line">        if remainder == 0:  </span><br><span class="line">            steps = [Dk] * Ek  </span><br><span class="line">        else:  </span><br><span class="line">            big_step = math.ceil(cipher_len / Ek)  </span><br><span class="line">            small_step = cipher_len // Ek  </span><br><span class="line">            steps = [big_step] * remainder + [small_step] * (Ek - remainder)  </span><br><span class="line">        output = []  </span><br><span class="line">        max_columns = math.ceil(cipher_len / Ek)  </span><br><span class="line">        for n_column in range(max_columns):  </span><br><span class="line">            count = 0  </span><br><span class="line">            for step in steps:  </span><br><span class="line">                pos = n_column + count  </span><br><span class="line">                if pos &gt;= cipher_len:  </span><br><span class="line">                    break  </span><br><span class="line">                output.append(a1[pos])  </span><br><span class="line">                count += step  </span><br><span class="line">        return &#x27;&#x27;.join(output)  </span><br><span class="line">  </span><br><span class="line">    elif a3 == 4:  </span><br><span class="line">        v25 = ord(a2[0]) % 10 + 2  </span><br><span class="line">        output = a1[v25:] + a1[:v25]  </span><br><span class="line">        return output  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    elif a3 == 5:  </span><br><span class="line">        tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">        tableNew = &quot;stuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr&quot;  </span><br><span class="line">        decoded = base64.b64decode(a1.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">        output = &#x27;&#x27;  </span><br><span class="line">        for i, char in enumerate(decoded):  </span><br><span class="line">            output += chr(char ^ ord(a2[i % v21]) + 57)  </span><br><span class="line">        return output  </span><br><span class="line">  </span><br><span class="line">    elif a3 == 6:  </span><br><span class="line">        tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;  </span><br><span class="line">        tableNew = &quot;stuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr&quot;  </span><br><span class="line">        decoded = base64.b64decode(a1.translate(str.maketrans(tableNew, tableBase64)))  </span><br><span class="line">        output = rc4_decrypt(decoded, a2)  </span><br><span class="line">        return output.decode()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">enc1 = &quot;WgvDmssEvcY326bHo3nNro3vXvvfmgrz&quot;  </span><br><span class="line">enc2 = &quot;gX+Ri9PG=bt5=00B6hscPQOL&quot;  </span><br><span class="line">enc3 = &quot;T6bHgUPL2gXUd=xT=FNHtPzV&quot;  </span><br><span class="line">  </span><br><span class="line">enc3 = decrypt(enc3, enc1, 1)  </span><br><span class="line">enc2 = decrypt(enc2, enc3, 4)  </span><br><span class="line">enc1 = decrypt(enc1, enc2, 5)  </span><br><span class="line">  </span><br><span class="line">enc3 = decrypt(enc3, enc1, 4)  </span><br><span class="line">enc2 = decrypt(enc2, enc3, 1)  </span><br><span class="line">enc1 = decrypt(enc1, enc2, 4)  </span><br><span class="line">  </span><br><span class="line">enc3 = decrypt(enc3, enc1, 3)  </span><br><span class="line">enc2 = decrypt(enc2, enc3, 4)  </span><br><span class="line">enc1 = decrypt(enc1, enc2, 1)  </span><br><span class="line">  </span><br><span class="line">enc3 = decrypt(enc3, enc1, 6)  </span><br><span class="line">enc2 = decrypt(enc2, enc3, 3)  </span><br><span class="line">enc1 = decrypt(enc1, enc2, 4)  </span><br><span class="line">  </span><br><span class="line">enc3 = decrypt(enc3, enc1, 5)  </span><br><span class="line">enc2 = decrypt(enc2, enc3, 6)  </span><br><span class="line">enc1 = decrypt(enc1, enc2, 3)  </span><br><span class="line">  </span><br><span class="line">enc3 = decrypt(enc3, enc1, 1)  </span><br><span class="line">enc2 = decrypt(enc2, enc3, 5)  </span><br><span class="line">enc1 = decrypt(enc1, enc2, 6)  </span><br><span class="line">  </span><br><span class="line">enc2 = decrypt(enc2, enc3, 1)  </span><br><span class="line">enc1 = decrypt(enc1, enc2, 5)  </span><br><span class="line">enc1 = decrypt(enc1, enc2, 1)  </span><br><span class="line">#print(enc1)  </span><br><span class="line">#print(enc2)  </span><br><span class="line">#print(enc3)  </span><br><span class="line">print(enc1 + enc2 + enc3)</span><br><span class="line">#NSSCTF&#123;P4ch3Lbel&#x27;s_C@n0n_1n_D_mAjOr&#125;</span><br></pre></td></tr></table></figure>

<h1 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h1><p>ida打开附件 查看字符串 发现input.png 所以可以知道 是对enc进行了一些操作 得到png文件 根据字符串定位到函数</p>
<p><img src="/../images/%E8%85%90%E8%9A%80.png" alt="腐蚀"></p>
<p>跟进sub_7FF7354652E0函数 发现256 最后还有xor 猜测是魔改的rc4 多xor了个0x1f</p>
<p><img src="/../images/%E8%85%90%E8%9A%80-1.png" alt="腐蚀-1"></p>
<p>起个调试取出key<br><code>0x60, 0x82, 0xAE, 0x42, 0x4E, 0x44, 0x49, 0x45, 0x1A, 0x0A, 0x0D, 0x0A, 0x4E, 0x47, 0x89, 0x50</code><br>随后在内存中看见 对输入进行了倒叙操作 所以加密流程就是 rc4 倒叙 写逆向脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def rc4_decrypt(data, key):  </span><br><span class="line">    S = list(range(256))  </span><br><span class="line">    j = 0  </span><br><span class="line">    key_len = len(key)  </span><br><span class="line">  </span><br><span class="line">    for i in range(256):  </span><br><span class="line">        j = (j + S[i] + key[i % key_len]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">  </span><br><span class="line">    i = j = 0  </span><br><span class="line">    output = []  </span><br><span class="line">  </span><br><span class="line">    for k in range(len(data)):  </span><br><span class="line">        i = (i + 1) % 256  </span><br><span class="line">        j = (j + S[i]) % 256  </span><br><span class="line">        S[i], S[j] = S[j], S[i]  </span><br><span class="line">        output.append((data[k] ^ S[(S[i] + S[j]) % 256]) ^ 0x1F)  </span><br><span class="line">  </span><br><span class="line">    return bytes(output)  </span><br><span class="line">  </span><br><span class="line">def decrypt_file(filename, key):  </span><br><span class="line">    with open(filename, &quot;rb&quot;) as f:  </span><br><span class="line">        enc_data = f.read()  </span><br><span class="line">    enc_data = enc_data[::-1]  </span><br><span class="line">    decrypted_data = rc4_decrypt(enc_data, key)  </span><br><span class="line">    return decrypted_data  </span><br><span class="line">  </span><br><span class="line">filename = &quot;./enc&quot;  </span><br><span class="line">key = bytes([0x60, 0x82, 0xAE, 0x42, 0x4E, 0x44, 0x49, 0x45, 0x1A, 0x0A, 0x0D, 0x0A, 0x4E, 0x47, 0x89, 0x50])  </span><br><span class="line">  </span><br><span class="line">decrypted_data = decrypt_file(filename, key)  </span><br><span class="line">  </span><br><span class="line">with open(&quot;./1.png&quot;, &quot;wb&quot;) as f:  </span><br><span class="line">    f.write(decrypted_data)</span><br></pre></td></tr></table></figure>

<p>打开图片得到flag</p>
<p><img src="/../images/%E8%85%90%E8%9A%80-2.png" alt="腐蚀-2"></p>
]]></content>
  </entry>
  <entry>
    <title>2025 TPCTF RE wp</title>
    <url>/2025/03/10/2025-TPCTF-RE-wp/</url>
    <content><![CDATA[<h1 id="linuxpdf"><a href="#linuxpdf" class="headerlink" title="linuxpdf"></a>linuxpdf</h1><p>打开附件 下面有个github的链接 打开之后是一个网页的linux 观察一下原本的和附件的区别 发现这里多加载了很多东西</p>
<span id="more"></span>

<p><img src="/../images/linuxpdf.png" alt="linuxpdf"></p>
<p>应该是出题人加入的 多运行几次 可以发现最后的那个a9加载完毕之后 Flag出现 所以可以猜测那个a9就是主要的文件<br>扔010里 发现了很多base64加密的字符串 写个脚本解压保存文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64  </span><br><span class="line">import zlib  </span><br><span class="line">import os  </span><br><span class="line">from pathlib import Path  </span><br><span class="line">from typing import Dict, Union  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def decode_and_inflate(encoded_data: str) -&gt; bytes:  </span><br><span class="line">    decoded = base64.b64decode(encoded_data)  </span><br><span class="line">    return zlib.decompress(decoded, wbits=15)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def save_content(  </span><br><span class="line">        output_path: Union[str, Path],  </span><br><span class="line">        binary_data: bytes,  </span><br><span class="line">        ensure_dir: bool = True  </span><br><span class="line">) -&gt; None:  </span><br><span class="line">    path = Path(output_path)  </span><br><span class="line">    if ensure_dir:  </span><br><span class="line">        path.parent.mkdir(parents=True, exist_ok=True)  </span><br><span class="line">    path.write_bytes(binary_data)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def extract_files(  </span><br><span class="line">        file_map: Dict[str, str],  </span><br><span class="line">        output_root: Union[str, Path] = &quot;&quot;  </span><br><span class="line">) -&gt; None:  </span><br><span class="line">    for filename, b64_data in file_map.items():  </span><br><span class="line">        try:  </span><br><span class="line">            uncompressed = decode_and_inflate(b64_data)  </span><br><span class="line">            target_path = Path(output_root) / filename  </span><br><span class="line">            save_content(target_path, uncompressed)  </span><br><span class="line">            print(f&quot;成功提取: &#123;target_path&#125;&quot;)  </span><br><span class="line">        except (ValueError, zlib.error) as e:  </span><br><span class="line">            print(f&quot;解码/解压失败 &#123;filename&#125;: &#123;str(e)&#125;&quot;)  </span><br><span class="line">        except OSError as e:  </span><br><span class="line">            print(f&quot;文件写入失败 &#123;filename&#125;: &#123;str(e)&#125;&quot;)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">if __name__ == &quot;__main__&quot;:  </span><br><span class="line">    file_flag = &#123;  </span><br><span class="line">        &quot;vm_64.cfg&quot;: &quot;eNpNTtFugzAMfO...&quot;  #太长了不放了</span><br><span class="line">    &#125;  </span><br><span class="line">    extract_files(file_flag, &quot;output_files&quot;)</span><br></pre></td></tr></table></figure>

<p>随后直接找a9 然后扔<strong>ida9.0</strong>里 （实测ida8.3 7.7没办法F5 不知道什么原因┭┮﹏┭┮）</p>
<p><img src="/../images/linuxpdf-1.png" alt="linuxpdf-1"></p>
<p>跟进 发现md5初始化</p>
<p><img src="/../images/linuxpdf-2.png" alt="linuxpdf-2"></p>
<p>随后看unk_4008 发现是一堆md5值 中间用00分隔开</p>
<p><img src="/../images/linuxpdf-3.png" alt="linuxpdf-3"></p>
<p>提取出来爆破一下 发现最后三个爆破的很快 结果如下 </p>
<p>CB0FC813755A45CE5984BFBA15847C1E——&gt;F}</p>
<p>DF88931E7EEFDFCC2BB80D4A4F5710FB——&gt;DF}</p>
<p>D6AF7C4FEDCF2B6777DF8E83C932F883——&gt;PDF}</p>
<p>且有规律 爆破出来的字符在上一个的前面 所以可以猜到是从后往前依次爆破 直接把所有md5值提取出来 写脚本即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib  </span><br><span class="line">import itertools  </span><br><span class="line">import sys  </span><br><span class="line">  </span><br><span class="line">chars = [chr(i) for i in range(32, 127)]  </span><br><span class="line">  </span><br><span class="line">def crack_md5_chain(target_hashes):  </span><br><span class="line">    cracked = []  </span><br><span class="line">    previous_plain = None  </span><br><span class="line">  </span><br><span class="line">    for idx, target_hash in enumerate(target_hashes):  </span><br><span class="line">        target_hash = target_hash.lower().strip()  </span><br><span class="line">        if idx == 0:  </span><br><span class="line">            for candidate in itertools.product(chars, repeat=2):  </span><br><span class="line">                plain = &#x27;&#x27;.join(candidate)  </span><br><span class="line">                if hashlib.md5(plain.encode()).hexdigest() == target_hash:  </span><br><span class="line">                    print(f&quot;[+] 成功破解第1个哈希: &#123;plain&#125;&quot;)  </span><br><span class="line">                    previous_plain = plain  </span><br><span class="line">                    cracked.append(plain)  </span><br><span class="line">                    break  </span><br><span class="line">            else:  </span><br><span class="line">                print(&quot;[-] 无法破解第一个哈希，终止流程&quot;)  </span><br><span class="line">                return None  </span><br><span class="line">        else:  # 后续哈希处理  </span><br><span class="line">            found = False  </span><br><span class="line">            for c in chars:  </span><br><span class="line">                plain = c + previous_plain  </span><br><span class="line">                if hashlib.md5(plain.encode()).hexdigest() == target_hash:  </span><br><span class="line">                    print(f&quot;[+] 成功破解第&#123;idx + 1&#125;个哈希: &#123;plain&#125;&quot;)  </span><br><span class="line">                    previous_plain = plain  </span><br><span class="line">                    cracked.append(plain)  </span><br><span class="line">                    found = True  </span><br><span class="line">                    break            if not found:  </span><br><span class="line">                print(f&quot;[-] 无法破解第&#123;idx + 1&#125;个哈希，终止流程&quot;)  </span><br><span class="line">                return None  </span><br><span class="line">    return cracked  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def main():  </span><br><span class="line">    if len(sys.argv) != 2:  </span><br><span class="line">        print(f&quot;用法: &#123;sys.argv[0]&#125; &lt;哈希文件&gt;&quot;)  </span><br><span class="line">        return  </span><br><span class="line">  </span><br><span class="line">    with open(sys.argv[1]) as f:  </span><br><span class="line">        hashes = [line.strip() for line in f if line.strip()]  </span><br><span class="line">  </span><br><span class="line">    if not hashes:  </span><br><span class="line">        print(&quot;错误：哈希文件为空&quot;)  </span><br><span class="line">        return  </span><br><span class="line">  </span><br><span class="line">    print(&quot;开始破解MD5链...&quot;)  </span><br><span class="line">    result = crack_md5_chain(hashes)  </span><br><span class="line">  </span><br><span class="line">    if result:  </span><br><span class="line">        print(&quot;\n破解结果链:&quot;)  </span><br><span class="line">        for i, plain in enumerate(result):  </span><br><span class="line">            print(f&quot;哈希&#123;i + 1&#125;: &#123;plain&#125;&quot;)  </span><br><span class="line">    else:  </span><br><span class="line">        print(&quot;\n未能完整破解哈希链&quot;)  </span><br><span class="line">  </span><br><span class="line">if __name__ == &quot;__main__&quot;:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><img src="/../images/linuxpdf-4.png" alt="linuxpdf-4"></p>
<h1 id="portable"><a href="#portable" class="headerlink" title="portable"></a>portable</h1><p>ida打开附件 查看字符串 发现flag头</p>
<p><img src="/../images/portable.png" alt="portable"></p>
<p>随后在start函数开始 往下翻函数 在最后找到输入flag的函数 sub_407F30</p>
<p><img src="/../images/portable-1.png" alt="portable-1"></p>
<p>在下面找到一个异或 下面显示输入正确</p>
<p><img src="/../images/portable-2.png" alt="portable-2"></p>
<p>找一下密文跟密钥 扔赛博厨子里解一下得到flag</p>
<p><img src="/../images/portable-3.png" alt="portable-3"></p>
<p><img src="/../images/ef8695a42a6fbbf1b93202dc9f7bb705.png" alt="ef8695a42a6fbbf1b93202dc9f7bb705"></p>
]]></content>
  </entry>
</search>
